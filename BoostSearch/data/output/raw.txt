Chapter 8. Boost.Container\3



Chapter 8. Boost.Container











Home
Libraries
People
FAQ
More








Chapter 8. Boost.Container

Ion Gaztanaga

Copyright © 2009-2018 Ion Gaztanaga


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction

Building
      Boost.Container
Tested compilers

Main features

Efficient insertion
Containers
      of Incomplete Types
SCARY iterators
Other features

Boost.Container and C++ exceptions
Non-standard containers

stable_vector
flat_(multi)map/set
      associative containers
devector
slist
static_vector
small_vector

Extended functionality:
    Basic extensions

Default
      initialization for vector-like containers
Ordered
      range insertion for associative containers (ordered_unique_range,
      ordered_range) 
Constant-time
      range splice for (s)list

Extended functionality:
    Configurable containers

Configurable
      tree-based associative ordered containers
Configurable
      vector
Configurable
      static vector
Configurable
      small vector
Configurable
      deques
Configurable
      devector

Extended functionality:
    Extended allocators
C++11/C++14/C++17 Conformance

Move and Emplace
Stateful
      allocators
Scoped allocators
Insertion
      hints in associative containers and preserving insertion ordering for elements
      with equivalent keys
Initializer
      lists
Null Forward
      Iterators
Polymorphic
      Memory Resources 
forward_list&lt;T&gt;
vector vs. std::vector
      exception guarantees
Parameter
      taken by const reference that can be changed
vector&lt;bool&gt; specialization
Non-standard
      value initialization using std::memset

Known Issues
Move
      emulation limitations in C++03 compilers
History and reasons to use
    Boost.Container

Boost.Container
      history
Why
      Boost.Container?

Indexes

Class Index
Typedef Index
Function Index

Boost.Container Header Reference

Header &lt;boost/container/adaptive_pool.hpp&gt;
Header &lt;boost/container/allocator.hpp&gt;
Header &lt;boost/container/allocator_traits.hpp&gt;
Header &lt;boost/container/container_fwd.hpp&gt;
Header &lt;boost/container/deque.hpp&gt;
Header &lt;boost/container/pmr/deque.hpp&gt;
Header &lt;boost/container/devector.hpp&gt;
Header &lt;boost/container/pmr/devector.hpp&gt;
Header &lt;boost/container/flat_map.hpp&gt;
Header &lt;boost/container/pmr/flat_map.hpp&gt;
Header &lt;boost/container/flat_set.hpp&gt;
Header &lt;boost/container/pmr/flat_set.hpp&gt;
Header &lt;boost/container/list.hpp&gt;
Header &lt;boost/container/pmr/list.hpp&gt;
Header &lt;boost/container/map.hpp&gt;
Header &lt;boost/container/pmr/map.hpp&gt;
Header &lt;boost/container/new_allocator.hpp&gt;
Header &lt;boost/container/node_allocator.hpp&gt;
Header &lt;boost/container/node_handle.hpp&gt;
Header &lt;boost/container/options.hpp&gt;
Header &lt;boost/container/pmr/global_resource.hpp&gt;
Header &lt;boost/container/pmr/memory_resource.hpp&gt;
Header &lt;boost/container/pmr/monotonic_buffer_resource.hpp&gt;
Header &lt;boost/container/pmr/polymorphic_allocator.hpp&gt;
Header &lt;boost/container/pmr/pool_options.hpp&gt;
Header &lt;boost/container/pmr/resource_adaptor.hpp&gt;
Header &lt;boost/container/pmr/synchronized_pool_resource.hpp&gt;
Header &lt;boost/container/pmr/unsynchronized_pool_resource.hpp&gt;
Header &lt;boost/container/scoped_allocator.hpp&gt;
Header &lt;boost/container/scoped_allocator_fwd.hpp&gt;
Header &lt;boost/container/pmr/set.hpp&gt;
Header &lt;boost/container/set.hpp&gt;
Header &lt;boost/container/pmr/slist.hpp&gt;
Header &lt;boost/container/slist.hpp&gt;
Header &lt;boost/container/pmr/small_vector.hpp&gt;
Header &lt;boost/container/small_vector.hpp&gt;
Header &lt;boost/container/pmr/stable_vector.hpp&gt;
Header &lt;boost/container/stable_vector.hpp&gt;
Header &lt;boost/container/static_vector.hpp&gt;
Header &lt;boost/container/pmr/string.hpp&gt;
Header &lt;boost/container/string.hpp&gt;
Header &lt;boost/container/throw_exception.hpp&gt;
Header &lt;boost/container/uses_allocator.hpp&gt;
Header &lt;boost/container/uses_allocator_fwd.hpp&gt;
Header &lt;boost/container/pmr/vector.hpp&gt;
Header &lt;boost/container/vector.hpp&gt;

Acknowledgements, notes
    and links
Release Notes

Boost
      1.82 Release
Boost
      1.81 Release
Boost
      1.80 Release
Boost
      1.79 Release
Boost
      1.78 Release
Boost
      1.77 Release
Boost
      1.76 Release
Boost
      1.75 Release
Boost
      1.74 Release
Boost
      1.72 Release
Boost
      1.71 Release
Boost
      1.70 Release
Boost
      1.69 Release
Boost
      1.68 Release
Boost
      1.67 Release
Boost
      1.66 Release
Boost
      1.65 Release
Boost
      1.64 Release
Boost
      1.63 Release
Boost
      1.62 Release
Boost
      1.61 Release
Boost
      1.60 Release
Boost
      1.59 Release
Boost
      1.58 Release
Boost
      1.57 Release
Boost
      1.56 Release
Boost
      1.55 Release
Boost
      1.54 Release
Boost
      1.53 Release
Boost
      1.52 Release
Boost
      1.51 Release
Boost
      1.50 Release
Boost
      1.49 Release
Boost
      1.48 Release





Introduction


Building
      Boost.Container
Tested compilers


      Boost.Container library implements several
      well-known containers, including STL containers. The aim of the library is
      to offer advanced features not present in standard containers or to offer the
      latest standard draft features for compilers that don't comply with the latest
      C++ standard.
    

      In short, what does Boost.Container offer?
    


          Emplacement and move semantics are implemented, including emulation for
          pre-C++11 compilers.
        

          Polymorphic allocators and memory resources, including implementation and
          emulation for pre-C++17 compilers
        

          New advanced features (e.g. recursive containers) and configurability options
          container.configurable_containers
          for containers.
        

          Containers support stateful allocators and are compatible with Boost.Interprocess (they can be safely placed in
          shared memory).
        

          Users obtain a more uniform performance across all plataforms, including
          SCARY iterators.
        

          The library offers new useful containers:
          

                flat_map,
                flat_set,
                flat_multimap
                and flat_multiset:
                drop-in replacements for standard associative containers but more
                memory friendly and with faster searches.
              

                stable_vector:
                a std::list and std::vector hybrid container: vector-like random-access
                iterators and list-like iterator stability in insertions and erasures.
              

                static_vector:
                a vector-like container that internally embeds (statically allocates)
                all needed memory up to the maximum capacity. Maximum capacity can't
                be increased and it's specified at compile time.
              

                small_vector:
                a vector-like container that internally embeds (statically allocates)
                a minimum amount of memory, but dynamically allocates elements when
                capacity has to be increased. This minimum capacity is specified
                at compile time.
              

                devector:
                is a hybrid of the standard vector and deque containers. It offers
                cheap (amortized constant time) insertion at both the front and back
                ends.
              

                slist: the classic
                pre-standard singly linked list implementation offering constant-time
                size().
                Note that C++11 forward_list
                has no size().
              

        



Building
      Boost.Container


        There is no need to compile Boost.Container,
        since it's a header-only library, just include your Boost header directory
        in your compiler include path except if you use:
      


            Extended Allocators
          

            Some Polymorphic
            Memory Resources classes.
          


        Those exceptions are are implemented as a separately compiled library, so
        in those cases you must install binaries in a location that can be found
        by your linker. If you followed the Boost
        Getting Started instructions, that's already been done for you.
      



Tested compilers


        Boost.Container requires a decent C++03
        compatibility. Some compilers known to work are:
      


            Visual C++ &gt;= 10.0
          

            GCC &gt;= 4.8
          











\3https://www.boost.org/doc/libs/1_84_0/doc/html/container.html
Macro BOOST_MPI_SUBVERSION\3



Macro BOOST_MPI_SUBVERSION











Home
Libraries
People
FAQ
More








Macro BOOST_MPI_SUBVERSION
BOOST_MPI_SUBVERSION

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

BOOST_MPI_SUBVERSION

Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MPI_SUBVERSION.html
Macro BOOST_YAP_USER_BINARY_OPERATOR\3



Macro BOOST_YAP_USER_BINARY_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_BINARY_OPERATOR
BOOST_YAP_USER_BINARY_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_BINARY_OPERATOR(op_name, expr_template, result_expr_template)

Description
Defines operator overloads for binary operator op_name that each produce an expression instantiated from the expr_template expression template. One overload is defined for each of the qualifiers const &amp;, &amp;, and &amp;&amp;. For the lvalue reference overloads, *this is captured by reference into the resulting expression. For the rvalue reference overload, *this is moved into the resulting expression.
Note that this does not work for yap::expr_kinds assign, subscript, or call. Use BOOST_YAP_USER_ASSIGN_OPERATOR, BOOST_YAP_USER_SUBSCRIPT_OPERATOR, or BOOST_YAP_USER_CALL_OPERATOR for those, respectively.
Example: 









Parameters:







expr_template
The expression template to which the overloads apply. expr_template must be an ExpressionTemplate.


op_name
The operator to be overloaded; this must be one of the binary enumerators in expr_kind, except assign, subscript, or call, without the expr_kind:: qualification.


result_expr_template
The expression template to use to instantiate the result expression. result_expr_template must be an ExpressionTemplate. 







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_2.html
Macro BOOST_UNITS_DEFINE_CONVERSION_OFFSET\3



Macro BOOST_UNITS_DEFINE_CONVERSION_OFFSET











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_DEFINE_CONVERSION_OFFSET
BOOST_UNITS_DEFINE_CONVERSION_OFFSET

Synopsis
// In header: &lt;boost/units/absolute.hpp&gt;

BOOST_UNITS_DEFINE_CONVERSION_OFFSET(From, To, type_, value_)

Description
Macro to define the offset between two absolute units. Requires the value to be in the destination units e.g 
BOOST_UNITS_DEFINE_CONVERSION_OFFSET(celsius_base_unit, fahrenheit_base_unit, double, 32.0);

 BOOST_UNITS_DEFINE_CONVERSION_FACTOR is also necessary to specify the conversion factor. Like BOOST_UNITS_DEFINE_CONVERSION_FACTOR this macro defines both forward and reverse conversions so defining, e.g., the conversion from celsius to fahrenheit as above will also define the inverse conversion from fahrenheit to celsius. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_2_4.html
Chapter 27. Boost.PolyCollection\3



Chapter 27. Boost.PolyCollection











Home
Libraries
People
FAQ
More








Chapter 27. Boost.PolyCollection

Joaquín M López Muñoz

Copyright © 2016-2021 Joaquín M López Muñoz


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
An efficient
    polymorphic data structure
Tutorial

Basics
Deeper
      into the segmented nature of Boost.PolyCollection
Insertion
      and emplacement
Exceptions
Algorithms

Performance

Container
      definitions
Insertion
      tests
Processing
      tests

Reference

Polymorphism
      models
Polymorphic
      containers
Header
      "boost/poly_collection/exception.hpp"
      synopsis
Header
      "boost/poly_collection/base_collection_fwd.hpp"
      synopsis
Header
      "boost/poly_collection/base_collection.hpp"
      synopsis
Header
      "boost/poly_collection/function_collection_fwd.hpp"
      synopsis
Header
      "boost/poly_collection/function_collection.hpp"
      synopsis
Header
      "boost/poly_collection/any_collection_fwd.hpp"
      synopsis
Header
      "boost/poly_collection/any_collection.hpp"
      synopsis
Header
      "boost/poly_collection/algorithm.hpp"
      synopsis

Future work

Alternative
      RTTI systems
Copy traits
Parallel
      algorithms
variant_collection
Ordered
      polymorphic collections

Release notes

Boost 1.76
Boost 1.74
Boost 1.73
Boost 1.72
Boost 1.71
Boost 1.70
Boost 1.69
Boost 1.67
Boost 1.66
Boost 1.65

Acknowledgments




Introduction


      Dynamic polymorphism in C++ requires that objects (such as instances of classes
      derived from an abstract base) be accessed through an indirection pointer because
      their actual type and size are not
      known at the point of usage. As a consequence, regular containers cannot store
      polymorphic objects directly: the usual workaround is to have containers of
      pointers to heap-allocated elements. In modern computer architectures this
      pattern incurs two types of inefficiency:
    


          The lack of memory contiguity produced by heap allocation degrades CPU
          cache performance.
        

          Executing virtual operations on a sequence of polymorphic objects whose
          actual types differ from one to the next results in failures in branch prediction
          and a lower execution speed.
        


      When the particular traversal order is not relevant to the user application,
      Boost.PolyCollection proposes an alternative data structure that restores memory
      contiguity and packs elements according to their concrete type. Three container
      class templates are provided:
    


          boost::base_collection
        

          boost::function_collection
        

          boost::any_collection
        


      respectively dealing with three different types of dynamic polymorphism available
      in C++:
    


          Classic base/derived or OOP polymorphism.
        

          Function wrapping in the spirit of std::function.
        

          So-called duck
          typing as implemented by Boost.TypeErasure.
        


      The interface of these containers closely follows that of standard containers.
      Additionally, the library provides versions of many of the standard library
      algorithms (including std::for_each)
      with improved performance and a special feature called type restitution
      that allows user code to provide clues on the concrete types of the elements
      stored for further opportunities of increased efficiency related to inlining
      and devirtualization.
    



Note


        Boost.PolyCollection is a header-only library. C++11 support is required.
        The library has been verified to work with Visual Studio 2015, GCC 4.8 and
        Clang 3.3.
      










\3https://www.boost.org/doc/libs/1_84_0/doc/html/poly_collection.html
Concept SignedInteger\3



Concept SignedInteger











Home
Libraries
People
FAQ
More








Concept SignedInteger
SignedInteger


Refinement of

CopyConstructible
Assignable
DefaultConstructible
EqualityComparable
LessThanComparable



Notation

T
A type playing the role of integral-type in the SignedInteger concept.

x, y, z

Objects of type T

a, b

Objects of type int



Type expressions

Conversion to int
T must be
                  convertible to int.
                



Valid expressions







Name
Expression
Type



Conversion from int
T(a)
T


Preincrement
++x
T &amp;


Predecrement
--x
T &amp;


Postincrement
x++
T


Postdecrement
x--
T


Sum
x + y
T


Sum with int
x + a
T


Sum-assignment
x += y
T &amp;


Sum-assignment with int
x += a
T &amp;


Difference
x - y
T


Difference with int
x - a
T


Product
x * y
T


Product with int
x * a
T


Product-assignment with int
x *= a
T &amp;


Product with int on left
a * x
T


Quotient
x / y
T


Quotient with int
x / a
T


Right-shift
x &gt;&gt; y
T


Right-shift with int
x &gt;&gt; a
T


Right-shift-assignment with int
x &gt;&gt;= a
T &amp;


Less-than comparison
x &lt; y
Convertible to bool


Less-than comparison with int
x &lt; a
Convertible to bool


Less-than comparison with size_t
x &lt; boost::sample_value &lt; std::size_t &gt;()
Convertible to bool


Greater-than comparison
x &gt; y
Convertible to bool


Greater-than comparison with int
x &gt; a
Convertible to bool


Less-than-or-equal comparison
x &lt;= y
Convertible to bool


Less-than-or-equal comparison with int
x &lt;= a
Convertible to bool


Greater-than-or-equal comparison
x &gt;= y
Convertible to bool


Greater-than-or-equal comparison with int
x &gt;= a
Convertible to bool


Greater-than-or-equal comparison with int on left
a &gt;= x
Convertible to bool


Equality comparison
x == y
Convertible to bool


Equality comparison with int
x == a
Convertible to bool





Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/SignedInteger.html
Macro BOOST_MOVE_RET\3



Macro BOOST_MOVE_RET











Home
Libraries
People
FAQ
More








Macro BOOST_MOVE_RET
BOOST_MOVE_RET

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_MOVE_RET(RET_TYPE, REF)

Description
This macro is used to achieve portable move return semantics. The C++11 Standard allows implicit move returns when the object to be returned is designated by a lvalue and:

The criteria for elision of a copy operation are met OR
The criteria would be met save for the fact that the source object is a function parameter



For C++11 conforming compilers this macros only yields to REF: return BOOST_MOVE_RET(RET_TYPE, REF); -&gt; return REF;
For compilers without rvalue references this macro does an explicit move if the move emulation is activated and the return type (RET_TYPE) is not a reference.
For non-conforming compilers with rvalue references like Visual 2010 &amp; 2012, an explicit move is performed if RET_TYPE is not a reference.
Caution: When using this macro in non-conforming or C++03 compilers, a move will be performed even if the C++11 standard does not allow it (e.g. returning a static variable). The user is responsible for using this macro only to return local objects that met C++11 criteria. 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MOVE_RET.html
Macro BOOST_PROTO_MAX_ARITY\3



Macro BOOST_PROTO_MAX_ARITY











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_MAX_ARITY
BOOST_PROTO_MAX_ARITY — Controls the maximum number of child nodes an expression may have.

Synopsis
// In header: &lt;boost/proto/proto_fwd.hpp&gt;

BOOST_PROTO_MAX_ARITY

Description

        BOOST_PROTO_MAX_ARITY defaults to 10. It may be set higher or lower, but not
        lower than 3. Setting it higher will have a negative effect on compile times. 
      

        See also BOOST_PROTO_MAX_FUNCTION_CALL_ARITY.
      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_MAX_ARITY.html
What's Included in This Document\3



What's Included in This Document











Home
Libraries
People
FAQ
More







What's Included in This Document
This document represents only a subset of the full Boost
    documentation: that part which is generated from BoostBook or
    QuickBook sources.  Eventually all Boost libraries may use these
    formats, but in the meantime, much of Boost's documentation is not
    available here.  Please
    see http://www.boost.org/libs
    for complete documentation.
    

      Documentation for some of the libraries described in this document is
      available in alternative formats:
       
HTML

       
PDF

    








\3https://www.boost.org/doc/libs/1_84_0/doc/html/about.html
Macro BOOST_PROTO_EXTENDS_USING_ASSIGN\3



Macro BOOST_PROTO_EXTENDS_USING_ASSIGN











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_EXTENDS_USING_ASSIGN
BOOST_PROTO_EXTENDS_USING_ASSIGN — For exposing in classes that inherit from
      proto::extends&lt;&gt;
      the overloaded assignment operators defined therein.

Synopsis
// In header: &lt;boost/proto/extends.hpp&gt;

BOOST_PROTO_EXTENDS_USING_ASSIGN(Derived)

Description

        The standard usage of
        proto::extends&lt;&gt;
        is to inherit from it. However, the derived class automatically gets a compiler-generated assignment
        operator that will hide the ones defined in
        proto::extends&lt;&gt;.
        Use BOOST_PROTO_EXTENDS_USING_ASSIGN() in the derived class to unhide the assignment
        operators defined in
        proto::extends&lt;&gt;.
      

        See proto::extends&lt;&gt;
        for an example that demonstrates usage of BOOST_PROTO_EXTENDS_USING_ASSIGN().
      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_10_8.html
Macro BOOST_MPI_CALLING_CONVENTION\3



Macro BOOST_MPI_CALLING_CONVENTION











Home
Libraries
People
FAQ
More








Macro BOOST_MPI_CALLING_CONVENTION
BOOST_MPI_CALLING_CONVENTION — Specifies the calling convention that will be used for callbacks from the underlying C MPI. 

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

BOOST_MPI_CALLING_CONVENTION

Description
This is a Windows-specific macro, which will be used internally to state the calling convention of any function that is to be used as a callback from MPI. For example, the internally-defined functions that are used in a call to MPI_Op_create. This macro is likely only to be useful to users that wish to bypass Boost.MPI, registering their own callbacks in certain cases, e.g., through MPI_Op_create. 


Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MPI_CAL_1_3_25_7_7_7.html
Chapter 7. Boost.Circular Buffer\3



Chapter 7. Boost.Circular Buffer











Home
Libraries
People
FAQ
More








Chapter 7. Boost.Circular Buffer

Jan Gaspar

Copyright © 2003-2013 Jan Gaspar


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Circular_buffer example
Rationale
Implementation 
More Examples
Header Files
Modelled Concepts
Template Parameters
Trac Tickets
Release Notes
Acknowledgements
Documentation Version Info
Boost.Circular_buffer C++ Reference

Header &lt;boost/circular_buffer.hpp&gt;
Header &lt;boost/circular_buffer/base.hpp&gt;
Header &lt;boost/circular_buffer/space_optimized.hpp&gt;

Index





Note


      A printer-friendly PDF version of this manual is also available.
    



Introduction


      A Circular Buffer.
    


      Description
    

      The term circular
      buffer (also called a ring or cyclic
      buffer) refers to an area in memory which is used to store incoming
      data. When the buffer is filled, new data is written starting at the beginning
      of the buffer and overwriting the old.
    

      boost::circular_buffer
      is a STL compliant container.
    

      It is a kind of sequence similar to std::list
      or std::deque.
      It supports random access iterators, constant time insert and erase operations
      at the beginning or the end of the buffer and interoperability with std algorithms.
    

      The circular_buffer is
      especially designed to provide fixed capacity
      storage. When its capacity is exhausted, newly inserted elements will cause
      elements to be overwritten, either at the beginning or end of the buffer (depending
      on what insert operation is used).
    

      The circular_buffer only
      allocates memory when created, when the capacity is adjusted explicitly, or
      as necessary to accommodate resizing or assign operations.
    

      
    

      There is also a circular_buffer_space_optimized
      version available.
    

      
    

      circular_buffer_space_optimized
      is an adaptation of the circular_buffer
      which does not allocate memory all at once when created,
      instead it allocates memory as needed.
    

      The predictive memory allocation is similar to typical std::vector
      implementation. Memory is automatically freed as the size of the container
      decreases.
    

      The memory allocation process of the space-optimized circular buffer. The
      min_capacity
      of the capacity controller represents the minimal guaranteed amount of allocated
      memory. The allocated memory will never drop under this value. The default
      value of the min_capacity is
      set to 0. The min_capacity
      can be set using the constructor parameter ()
      capacity_control  or the function set_capacity.
    

      The space-optimized version is, of course, a little slower.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/circular_buffer.html
Chapter 26. Boost.PFR 2.2\3



Chapter 26. Boost.PFR 2.2











Home
Libraries
People
FAQ
More








Chapter 26. Boost.PFR 2.2
Copyright © 2016-2023 Antony Polukhin


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Intro
Short Examples
    for the Impatient
Tutorial

Why
      tuples are bad and aggregates are more preferable?
Accessing
      structure member by index
Custom
      printing of aggregates
Three
      ways of getting operators 
Reflection of
      unions 
Reflection
      of field name 

Limitations and
    Configuration
How it works
Acknowledgements
Reference Section of PFR

Header &lt;boost/pfr.hpp&gt;
Header &lt;boost/pfr/config.hpp&gt;
Header &lt;boost/pfr/core.hpp&gt;
Header &lt;boost/pfr/core_name.hpp&gt;
Header &lt;boost/pfr/functions_for.hpp&gt;
Header &lt;boost/pfr/functors.hpp&gt;
Header &lt;boost/pfr/io.hpp&gt;
Header &lt;boost/pfr/io_fields.hpp&gt;
Header &lt;boost/pfr/ops.hpp&gt;
Header &lt;boost/pfr/ops_fields.hpp&gt;
Header &lt;boost/pfr/traits.hpp&gt;
Header &lt;boost/pfr/traits_fwd.hpp&gt;
Header &lt;boost/pfr/tuple_size.hpp&gt;





Intro


      Boost.PFR is a C++14 library for a very basic reflection. It gives you access
      to structure elements by index and provides other std::tuple like
      methods for user defined types without macro or boilerplate code:
    
#include &lt;iostream&gt;
#include &lt;string&gt;

#include "boost/pfr.hpp"

struct some_person {
    std::string name;
    unsigned birth_year;
};

int main() {
    some_person val{"Edgar Allan Poe", 1809};

    std::cout &lt;&lt; boost::pfr::get&lt;0&gt;(val)                // No macro!
        &lt;&lt; " was born in " &lt;&lt; boost::pfr::get&lt;1&gt;(val);  // Works with any aggregate initializables!

    std::cout &lt;&lt; boost::pfr::io(val);                   // Outputs: {"Edgar Allan Poe", 1809}
}


      Experiment with the sample online.
      See limitations.
    


      Usecase
      example
    

      Imagine that you are writing the wrapper library for a database. Depending
      on the usage of Boost.PFR users code will look differently:
    








              
                Without Boost.PFR
              
            

              
                With Boost.PFR
              
            



#include &lt;db/api.hpp&gt;

struct user_info {
    std::int64_t id;
    std::string name, email, login;
};

user_info retrieve_friend(std::string_view name) {
    std::tuple info_tuple
      = db::one_row_as&lt;std::int64_t, std::string, std::string, std::string&gt;(
        "SELECT id, name, email, login FROM user_infos WHERE name=$0",
        name
    );

    /////////////////////////////////////////////////////////////////////////////
    user_info info {
        std::move(std::get&lt;0&gt;(info_tuple)),
        std::move(std::get&lt;1&gt;(info_tuple)),
        std::move(std::get&lt;2&gt;(info_tuple)),
        std::move(std::get&lt;3&gt;(info_tuple)),
    }
    /////////////////////////////////////////////////////////////////////////////

    auto friend_info = ask_user_for_friend(std::move(info));

    db::insert(
        "INSERT INTO user_infos(id, name, email, login) VALUES ($0, $1, $2, $3)",
        friend_info.id,    //////////////////////////////////////////////////////
        friend_info.name,  // Users are forced to enumerate fields because your
        friend_info.email, // library can not iterate over the fields of a user
        friend_info.login  // provided structure
    );

    return friend_info;
}

            

#include &lt;db/api.hpp&gt;

struct user_info {
    std::int64_t id;
    std::string name, email, login;
};

user_info retrieve_friend(std::string_view name) {
    // With Boost.PFR you can put data directly into user provided structures
    user_info info = db::one_row_as&lt;user_info&gt;(
        "SELECT id, name, email, login FROM user_infos WHERE name=$0",
        name
    );

    ////////////////// No boilerplate code to move data around //////////////////






    /////////////////////////////////////////////////////////////////////////////

    auto friend_info = ask_user_for_friend(std::move(info));

    db::insert(
        "INSERT INTO user_infos(id, name, email, login) VALUES ($0, $1, $2, $3)",
        friend_info     /////////////////////////////////////////////////////////
                        // Boost.PFR allows you to iterate over all the fields
                        // of a user provided structure
                        //
    );

    return friend_info;
}

            




      Otherwise your library could require a customization point for a user type:
    








              
                Without Boost.PFR
              
            

              
                With Boost.PFR
              
            



#include &lt;db/api.hpp&gt;

struct user_info {
    std::int64_t id;
    std::string name, email, login;
};

/// Customizations via hand-written code ////////////////////////////////////////
auto db_api_tie(user_info&amp; ui) noexcept {
    return std::tie(ui.id, ui.name, ui.email, ui.login);
}

auto db_api_tie(const user_info&amp; ui) noexcept {
    return std::tie(ui.id, ui.name, ui.email, ui.login);
}
/////////////////////////////////////////////////////////////////////////////////

            

#include &lt;db/api.hpp&gt;

struct user_info {
    std::int64_t id;
    std::string name, email, login;
};

//////// With Boost.PFR there's no need in hand written customizations //////////







/////////////////////////////////////////////////////////////////////////////////

            




      Imagine that you are writing a serialization library. Serialization of user
      provided structures (and nested structures) with Boost.PFR it is just as simple
      as:
    
void Write(Writer&amp; writer, int value);
void Write(Writer&amp; writer, std::string_view value);

template &lt;typename T&gt;
std::enable_if_t&lt;std::is_aggregate_v&lt;T&gt;&gt; Write(Writer&amp; writer, const T&amp; value) {
  boost::pfr::for_each_field(
      value, [&amp;writer](const auto&amp; field) { Write(writer, field); });
}


      With Boost.PFR the code is shorter, more readable and more pleasant to write.
    



Note


        All the above examples were inspired by the Boost.PFR usage in 🐙
        userver framework.
      



      Out
      of the box functionality 
    

      Boost.PFR adds the following out-of-the-box functionality for aggregate initializable
      structures:
    


          comparison functions
        

          heterogeneous comparators
        

          hash
        

          IO streaming
        

          access to members by index or type
        

          access to member's names by index
        

          member type retrieval
        

          methods for cooperation with std::tuple
          for members
        

          methods for cooperation with std::array
          for member's names
        

          methods to visit each field of the structure
        

          trait to detect potential ability to reflect type, and ability to override
          trait's decision in user-side code
        


      Boost.PFR is a header only library that does not depend on Boost. You can just
      copy the content of the "include" folder from
      the Boost.PFR github into your project, and the library will work fine.
      For a version of the library without boost:: namespace see PFR.
    



Caution


        Recommended C++ Standards are C++20 and above. C++17 completely enough for
        a user who doesn't want accessing name of structure member. Library requires
        at least C++14! Pre C++14 compilers (C++11, C++03...) are not supported
      










\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_pfr.html
Macro BOOST_PROTO_REPEAT_FROM_TO\3



Macro BOOST_PROTO_REPEAT_FROM_TO











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_REPEAT_FROM_TO
BOOST_PROTO_REPEAT_FROM_TO — Repeatedly invoke the specified macro.

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_REPEAT_FROM_TO(FROM, TO, MACRO)

Description

        BOOST_PROTO_REPEAT_FROM_TO() is used to generate the kind of repetitive
        code that is typical of EDSLs built with Proto.
        BOOST_PROTO_REPEAT_FROM_TO(FROM, TO, MACRO)
        is equivalent to:
      

        
MACRO(FROM, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)
MACRO(FROM+1, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)
...
MACRO(TO-1, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)

      

        Example:
      

        
// Generate BOOST_PROTO_MAX_ARITY-1 overloads of the
// following construct() function template.
#define M0(N, typename_A, A_const_ref, A_const_ref_a, ref_a)      \
template&lt;typename T, typename_A(N)&gt;                               \
typename proto::result_of::make_expr&lt;                             \
    proto::tag::function                                          \
  , construct_helper&lt;T&gt;                                           \
  , A_const_ref(N)                                                \
&gt;::type const                                                     \
construct(A_const_ref_a(N))                                       \
{                                                                 \
    return proto::make_expr&lt;                                      \
        proto::tag::function                                      \
    &gt;(                                                            \
        construct_helper&lt;T&gt;()                                     \
      , ref_a(N)                                                  \
    );                                                            \
}
BOOST_PROTO_REPEAT_FROM_TO(1, BOOST_PROTO_MAX_ARITY, M0)
#undef M0

      

        The above invocation of BOOST_PROTO_REPEAT_FROM_TO()
        will generate the following code:
      

        
template&lt;typename T, typename A0&gt;
typename proto::result_of::make_expr&lt;
    proto::tag::function
  , construct_helper&lt;T&gt;
  , A0 const &amp;
&gt;::type const
construct(A0 const &amp; a0)
{
    return proto::make_expr&lt;
        proto::tag::function
    &gt;(
        construct_helper&lt;T&gt;()
      , boost::ref(a0)
    );
}

template&lt;typename T, typename A0, typename A1&gt;
typename proto::result_of::make_expr&lt;
    proto::tag::function
  , construct_helper&lt;T&gt;
  , A0 const &amp;
  , A1 const &amp;
&gt;::type const
construct(A0 const &amp; a0, A1 const &amp; a1)
{
    return proto::make_expr&lt;
        proto::tag::function
    &gt;(
        construct_helper&lt;T&gt;()
      , boost::ref(a0)
      , boost::ref(a1)
    );
}

// ... and so on, up to BOOST_PROTO_MAX_ARITY-1 arguments ...

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_REPEAT_FROM_TO.html
Redirect to generated documentation\3

  
  

      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt) --
    Redirect to generated documentation
    
  
  
    Automatic redirection failed, please go to
    http://www.boost.org/doc/libs/master/doc/html/atomic.html
  

\3https://www.boost.org/doc/libs/1_84_0/doc/html/atomic.html
Chapter 44. Boost.Xpressive\3



Chapter 44. Boost.Xpressive











Home
Libraries
People
FAQ
More








Chapter 44. Boost.Xpressive

Eric Niebler

Copyright © 2007 Eric Niebler


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Preface
User's Guide

Introduction
Installing
      xpressive
Quick Start
Creating
      a Regex Object
Matching
      and Searching
Accessing
      Results
String
      Substitutions
String
      Splitting and Tokenization
Named Captures
Grammars
      and Nested Matches
Semantic
      Actions and User-Defined Assertions
Symbol
      Tables and Attributes
Localization
      and Regex Traits
Tips 'N Tricks
Concepts
Examples

Reference

Header &lt;boost/xpressive/basic_regex.hpp&gt;
Header &lt;boost/xpressive/match_results.hpp&gt;
Header &lt;boost/xpressive/regex_actions.hpp&gt;
Header &lt;boost/xpressive/regex_algorithms.hpp&gt;
Header &lt;boost/xpressive/regex_compiler.hpp&gt;
Header &lt;boost/xpressive/regex_constants.hpp&gt;
Header &lt;boost/xpressive/regex_error.hpp&gt;
Header &lt;boost/xpressive/regex_iterator.hpp&gt;
Header &lt;boost/xpressive/regex_primitives.hpp&gt;
Header &lt;boost/xpressive/regex_token_iterator.hpp&gt;
Header &lt;boost/xpressive/regex_traits.hpp&gt;
Header &lt;boost/xpressive/sub_match.hpp&gt;
Header &lt;boost/xpressive/traits/c_regex_traits.hpp&gt;
Header &lt;boost/xpressive/traits/cpp_regex_traits.hpp&gt;
Header &lt;boost/xpressive/traits/null_regex_traits.hpp&gt;
Header &lt;boost/xpressive/xpressive.hpp&gt;
Header &lt;boost/xpressive/xpressive_dynamic.hpp&gt;
Header &lt;boost/xpressive/xpressive_fwd.hpp&gt;
Header &lt;boost/xpressive/xpressive_static.hpp&gt;
Header &lt;boost/xpressive/xpressive_typeof.hpp&gt;

Acknowledgments
Appendices

Appendix
      1: History
Appendix
      2: Not Yet Implemented
Appendix
      3: Differences from Boost.Regex
Appendix 4: Performance
      Comparison
Appendix
      5: Implementation Notes





Preface


        Wife: New Shimmer is a floor wax! Husband:
        No, new Shimmer is a dessert topping! Wife: It's
        a floor wax! Husband: It's a dessert topping!
        Wife: It's a floor wax, I'm telling you! Husband:
        It's a dessert topping, you cow! Announcer: Hey,
        hey, hey, calm down, you two. New Shimmer is both a floor wax and
        a dessert topping!
      

        -- Saturday Night Live
      


      Description
    

      xpressive is an advanced, object-oriented regular expression template library
      for C++. Regular expressions can be written as strings that are parsed at run-time,
      or as expression templates that are parsed at compile-time. Regular expressions
      can refer to each other and to themselves recursively, allowing you to build
      arbitrarily complicated grammars out of them.
    


      Motivation
    

      If you need to manipulate text in C++, you have typically had two disjoint
      options: a regular expression engine or a parser generator. Regular expression
      engines (like Boost.Regex) are powerful
      and flexible; patterns are represented as strings which can be specified at
      runtime. However, that means that syntax errors are likewise not detected until
      runtime. Also, regular expressions are ill-suited to advanced text processing
      tasks such as matching balanced, nested tags. Those tasks have traditionally
      been handled by parser generators (like the Spirit
      Parser Framework). These beasts are more powerful but less flexible.
      They generally don't allow you to arbitrarily modify your grammar rules on
      the fly. In addition, they don't have the exhaustive backtracking semantics
      of regular expressions, which can make it more challenging to author some types
      of patterns.
    

      xpressive brings these two approaches seamlessly together and occupies a unique
      niche in the world of C++ text processing. With xpressive, you can choose to
      use it much as you would use Boost.Regex,
      representing regular expressions as strings. Or you can use it as you would
      use Spirit, writing your
      regexes as C++ expressions, enjoying all the benefits of an embedded language
      dedicated to text manipulation. What's more, you can mix the two to get the
      benefits of both, writing regular expression grammars
      in which some of the regular expressions are statically bound -- hard-coded
      and syntax-checked by the compiler -- and others are dynamically bound and
      specified at runtime. These regular expressions can refer to each other recursively,
      matching patterns in strings that ordinary regular expressions cannot.
    


      Influences
      and Related Work
    

      The design of xpressive's interface has been strongly influenced by John Maddock's
      Boost.Regex library and his proposal
      to add regular expressions to the Standard Library. I also drew a great deal
      of inspiration from Joel de Guzman's Spirit
      Parser Framework, which served as the model for static xpressive. Other
      sources of inspiration are the Perl
      6 redesign and GRETA.
      (You can read a summary of the changes Perl 6 will bring to regex culture
      here.)
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/xpressive.html
Macro BOOST_PFR_CORE_NAME_PARSING\3



Macro BOOST_PFR_CORE_NAME_PARSING











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_CORE_NAME_PARSING
BOOST_PFR_CORE_NAME_PARSING

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_CORE_NAME_PARSING

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_CORE_NAM_idm2554.html
Chapter 25. Boost.MultiArray Reference Manual\3



Chapter 25. Boost.MultiArray Reference Manual











Home
Libraries
People
FAQ
More








Chapter 25. Boost.MultiArray Reference Manual


Ronald Garcia


Indiana University Open Systems Lab


Copyright © 2002 The Trustees of Indiana University


Table of Contents

Library Synopsis
MultiArray Concept

Notation
Associated Types
Valid expressions
Complexity guarantees
Invariants
Associated Types for Views
Models

Array Components

multi_array
multi_array_ref
const_multi_array_ref

Auxiliary Components

multi_array_types
extent_range
extent_gen
Global Objects
View and SubArray Generators
Memory Layout Specifiers
Range Checking



Boost.MultiArray is composed of several components.
The MultiArray concept defines a generic interface to multidimensional
containers.
multi_array is a general purpose container class
that models MultiArray. multi_array_ref
and const_multi_array_ref are adapter
classes. Using them, 
you can manipulate any block of contiguous data as though it were a
multi_array.
const_multi_array_ref differs from
multi_array_ref in that its elements cannot
be modified through its interface. Finally, several auxiliary classes are used
to create and specialize arrays and some global objects are defined as
part of the library interface.


Library Synopsis
To use Boost.MultiArray, you must include the header 
boost/multi_array.hpp in your source. This file
brings the following declarations into scope:

namespace boost {
  
  namespace multi_array_types {
    typedef *unspecified* index;
    typedef *unspecified* size_type;
    typedef *unspecified* difference_type;
    typedef *unspecified* index_range;
    typedef *unspecified* extent_range;
    typedef *unspecified* index_gen;
    typedef *unspecified* extent_gen;
  }

  template &lt;typename ValueType, 
            std::size_t NumDims, 
            typename Allocator = std::allocator&lt;ValueType&gt; &gt;
  class multi_array;

  template &lt;typename ValueType, 
            std::size_t NumDims&gt;
  class multi_array_ref;

  template &lt;typename ValueType, 
            std::size_t NumDims&gt; 
  class const_multi_array_ref;

  multi_array_types::extent_gen extents;
  multi_array_types::index_gen  indices;

  template &lt;typename Array, int N&gt; class subarray_gen;
  template &lt;typename Array, int N&gt; class const_subarray_gen;
  template &lt;typename Array, int N&gt; class array_view_gen;
  template &lt;typename Array, int N&gt; class const_array_view_gen;

  class c_storage_order; 
  class fortran_storage_order;
  template &lt;std::size_t NumDims&gt; class general_storage_order;

}










\3https://www.boost.org/doc/libs/1_84_0/doc/html/multi_array.html
Chapter 47. The BoostBook Documentation Format\3



Chapter 47. The BoostBook Documentation Format











Home
Libraries
People
FAQ
More








Chapter 47. The BoostBook Documentation Format

Douglas Gregor

Copyright © 2003-2005 Douglas Gregor

Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt).
      



Table of Contents

Introduction
Getting Started

Automatic setup for Unix-like systems
Manual setup for all systems
Running BoostBook
Troubleshooting

Documenting libraries

Defining a BoostBook library
From HTML to BoostBook
Sectioning in BoostBook

Bringing Together a BoostBook Document
Linking in BoostBook
Reference





Introduction
The BoostBook documentation format is an extension of DocBook, an SGML- or
    XML-based format for describing documentation. BoostBook augments
    DocBook with semantic markup that aids in the documentation of C++
    libraries, specifically the Boost C++ libraries, by
    providing the ability to express and refer to C++ constructs such
    as namespaces, classes, overloaded functions, templates, and
    specializations.

    BoostBook offers additional features more specific to its use for
    documenting the Boost C++
    libraries. These features are intended to eliminate or
    reduce the need for duplication of information and to aid in
    documenting portions of Boost that might otherwise not be
    documented. Examples of Boost-centric features include:
      

Testsuites:
          Testsuites in Boost are created by writing an appropriate
          Jamfile and including that Jamfile in
          status/Jamfile. If the testsuites are
          documented (as
          in the MultiArray library), the documentation is
          maintained separately from the testcase Jamfile, leading to
          duplication of information and the possibility of having the
          documentation out of sync with the Jamfile. BoostBook
          contains elements that describe a testsuite for both
          purposes: the BoostBook stylesheets can generate
          documentation for the testcases and also generate an
          appropriate Jamfile to integrate the testcases with the
          regression testing system.

Example programs:
          Example programs in documentation need to be duplicated in
          testcases to ensure that the examples compile and execute
          correctly. Keeping the two copies in sync is a tedious and
          error-prone task. For instance, the following code snippet
          persisted for six months:

std::cout &lt;&lt; f(5, 3) &gt;&gt; std::endl;

The BoostBook format allows testcases to be generated
          by weaving together program fragments from example programs
          in the documentation. This capability is integrated with
          testsuite generation so that example programs are normal
          tests in BoostBook.



    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/boostbook.html
Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR\3



Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR
BOOST_UNITS_DEFINE_CONVERSION_FACTOR

Synopsis
// In header: &lt;boost/units/conversion.hpp&gt;

BOOST_UNITS_DEFINE_CONVERSION_FACTOR(Source, Destination, type_, value_)

Description
Defines the conversion factor from a base unit to any unit or to another base unit with the correct dimensions. Uses of this macro must appear at global scope. If the destination unit is a base unit or a unit that contains only one base unit which is raised to the first power (e.g. feet-&gt;meters) the reverse (meters-&gt;feet in this example) need not be defined explicitly. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_7_3.html
Boost.Circular_buffer C++ Reference\3



Boost.Circular_buffer C++ Reference











Home
Libraries
People
FAQ
More







Boost.Circular_buffer C++ Reference

Header &lt;boost/circular_buffer.hpp&gt;
Header &lt;boost/circular_buffer/base.hpp&gt;
Header &lt;boost/circular_buffer/space_optimized.hpp&gt;



Header &lt;boost/circular_buffer.hpp&gt;
Includes &lt;boost/circular_buffer/base.hpp&gt; 


BOOST_CB_ENABLE_DEBUG



Header &lt;boost/circular_buffer/base.hpp&gt;
namespace boost {
  template&lt;typename T, typename Alloc&gt; class circular_buffer;
  template&lt;typename T, typename Alloc&gt; 
    bool operator==(const circular_buffer&lt; T, Alloc &gt; &amp;, 
                    const circular_buffer&lt; T, Alloc &gt; &amp;);
  template&lt;typename T, typename Alloc&gt; 
    bool operator&lt;(const circular_buffer&lt; T, Alloc &gt; &amp;, 
                   const circular_buffer&lt; T, Alloc &gt; &amp;);
  template&lt;typename T, typename Alloc&gt; 
    bool operator!=(const circular_buffer&lt; T, Alloc &gt; &amp;, 
                    const circular_buffer&lt; T, Alloc &gt; &amp;);
  template&lt;typename T, typename Alloc&gt; 
    bool operator&gt;(const circular_buffer&lt; T, Alloc &gt; &amp;, 
                   const circular_buffer&lt; T, Alloc &gt; &amp;);
  template&lt;typename T, typename Alloc&gt; 
    bool operator&lt;=(const circular_buffer&lt; T, Alloc &gt; &amp;, 
                    const circular_buffer&lt; T, Alloc &gt; &amp;);
  template&lt;typename T, typename Alloc&gt; 
    bool operator&gt;=(const circular_buffer&lt; T, Alloc &gt; &amp;, 
                    const circular_buffer&lt; T, Alloc &gt; &amp;);
  template&lt;typename T, typename Alloc&gt; 
    void swap(circular_buffer&lt; T, Alloc &gt; &amp;, circular_buffer&lt; T, Alloc &gt; &amp;);
}



Header &lt;boost/circular_buffer/space_optimized.hpp&gt;
namespace boost {
  template&lt;typename T, typename Alloc&gt; class circular_buffer_space_optimized;

  // Test two space optimized circular buffers for equality. 
  template&lt;typename T, typename Alloc&gt; 
    bool operator==(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs, 
                    const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);

  // Lexicographical comparison. 
  template&lt;typename T, typename Alloc&gt; 
    bool operator&lt;(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs, 
                   const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);

  // Test two space optimized circular buffers for non-equality. 
  template&lt;typename T, typename Alloc&gt; 
    bool operator!=(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs, 
                    const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);

  // Lexicographical comparison. 
  template&lt;typename T, typename Alloc&gt; 
    bool operator&gt;(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs, 
                   const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);

  // Lexicographical comparison. 
  template&lt;typename T, typename Alloc&gt; 
    bool operator&lt;=(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs, 
                    const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);

  // Lexicographical comparison. 
  template&lt;typename T, typename Alloc&gt; 
    bool operator&gt;=(const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs, 
                    const circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);

  // Swap the contents of two space optimized circular buffers. 
  template&lt;typename T, typename Alloc&gt; 
    void swap(circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; lhs, 
              circular_buffer_space_optimized&lt; T, Alloc &gt; &amp; rhs);
}


Copyright © 2003-2013 Jan Gaspar
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_circular_buffer_c___reference.html
Macro BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR\3



Macro BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR
BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR(op_name, expr_template, udt_trait)

Description
Defines a free/non-member operator overload for binary operator op_name that produces an expression instantiated from the expr_template expression template.
The lhs and rhs parameters to the defined operator overload may be any types that are not expressions. Each parameter is wrapped in a terminal expression.
At least one of the parameters to the defined operator overload must be a type T for which 
udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value 

 is true.
Example: 









Parameters:







expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate.


op_name
The operator to be overloaded; this must be one of the binary enumerators in expr_kind, without the expr_kind:: qualification.


udt_trait
A trait template to use to constrain which types are accepted as template parameters to the defined operator overload. 







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP__1_3_46_8_2_7_11.html
Macro BOOST_TYPE_INDEX_REGISTER_CLASS\3



Macro BOOST_TYPE_INDEX_REGISTER_CLASS











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_REGISTER_CLASS
BOOST_TYPE_INDEX_REGISTER_CLASS

Synopsis
// In header: &lt;boost/type_index.hpp&gt;

BOOST_TYPE_INDEX_REGISTER_CLASS

Description
BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI. Put this macro into the public section of polymorphic class to allow runtime type detection.
Depending on the typeid() availability this macro will expand to nothing or to virtual helper function virtual const type_info&amp; boost_type_info_type_id_runtime_() const noexcept.
Example: 
class A {
public:
    BOOST_TYPE_INDEX_REGISTER_CLASS
    virtual ~A(){}
};

struct B: public A {
    BOOST_TYPE_INDEX_REGISTER_CLASS
};

struct C: public B {
    BOOST_TYPE_INDEX_REGISTER_CLASS
};

...

C c1;
A* pc1 = &amp;c1;
assert(boost::typeindex::type_id&lt;C&gt;() == boost::typeindex::type_id_runtime(*pc1));

 


Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_2_4.html
Macro BOOST_RV_REF\3



Macro BOOST_RV_REF











Home
Libraries
People
FAQ
More








Macro BOOST_RV_REF
BOOST_RV_REF

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_RV_REF(TYPE)

Description
This macro is used to achieve portable syntax in move constructors and assignments for classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_RV_REF.html
Macro BOOST_PFR_USE_LOOPHOLE\3



Macro BOOST_PFR_USE_LOOPHOLE











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_USE_LOOPHOLE
BOOST_PFR_USE_LOOPHOLE

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_USE_LOOPHOLE

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_USE_LOOPHOLE.html
Macro BOOST_TYPE_ERASURE_MAX_ARITY\3



Macro BOOST_TYPE_ERASURE_MAX_ARITY











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_ERASURE_MAX_ARITY
BOOST_TYPE_ERASURE_MAX_ARITY

Synopsis
// In header: &lt;boost/type_erasure/config.hpp&gt;

BOOST_TYPE_ERASURE_MAX_ARITY

Description
The maximum number of arguments that functions in the library support. 


Copyright © 2011-2013 Steven Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE__1_3_40_13_11_2.html
Macro BOOST_PROTO_A_ref_a\3



Macro BOOST_PROTO_A_ref_a











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_A_ref_a
BOOST_PROTO_A_ref_a — 
      Generates sequences like
      
        A0 &amp; a0,
        A1 &amp; a1, …
        AN-1 &amp; aN-1
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_A_ref_a(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_A_ref_a(N) generates sequences like:
      

        
A0 &amp; a0, A1 &amp; a1, … AN-1 &amp; aN-1

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_A_ref_a.html
Macro BOOST_ACCUMULATORS_GCC_VERSION\3



Macro BOOST_ACCUMULATORS_GCC_VERSION











Home
Libraries
People
FAQ
More








Macro BOOST_ACCUMULATORS_GCC_VERSION
BOOST_ACCUMULATORS_GCC_VERSION

Synopsis
// In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;

BOOST_ACCUMULATORS_GCC_VERSION

Copyright © 2005, 2006 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_ACCUMU_1_3_2_6_2_3_5.html
Macro BOOST_CB_ENABLE_DEBUG\3



Macro BOOST_CB_ENABLE_DEBUG











Home
Libraries
People
FAQ
More








Macro BOOST_CB_ENABLE_DEBUG
BOOST_CB_ENABLE_DEBUG

Synopsis
// In header: &lt;boost/circular_buffer.hpp&gt;

BOOST_CB_ENABLE_DEBUG

Description
Debug support control. 


Copyright © 2003-2013 Jan Gaspar
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_CB_ENABLE_DEBUG.html
Macro BOOST_COPYABLE_AND_MOVABLE\3



Macro BOOST_COPYABLE_AND_MOVABLE











Home
Libraries
People
FAQ
More








Macro BOOST_COPYABLE_AND_MOVABLE
BOOST_COPYABLE_AND_MOVABLE

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_COPYABLE_AND_MOVABLE(TYPE)

Description
This macro marks a type as copyable and movable. The user will need to write a move constructor/assignment and a copy assignment as explained in the documentation to fully write a copyable and movable class. 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_COPYABLE_AND_MOVABLE.html
Macro BOOST_PROGRAM_OPTIONS_IMPLICIT_VALUE_NEXT_TOKEN\3



Macro BOOST_PROGRAM_OPTIONS_IMPLICIT_VALUE_NEXT_TOKEN











Home
Libraries
People
FAQ
More








Macro BOOST_PROGRAM_OPTIONS_IMPLICIT_VALUE_NEXT_TOKEN
BOOST_PROGRAM_OPTIONS_IMPLICIT_VALUE_NEXT_TOKEN

Synopsis
// In header: &lt;boost/program_options/version.hpp&gt;

BOOST_PROGRAM_OPTIONS_IMPLICIT_VALUE_NEXT_TOKEN

Copyright © 2002-2004 Vladimir PrusDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROGRA_1_3_30_9_12_2.html
Macro BOOST_PROTO_typename_A\3



Macro BOOST_PROTO_typename_A











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_typename_A
BOOST_PROTO_typename_A — 
      Generates sequences like
      
        typename A0,
        typename A1, …
        typename AN-1
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_typename_A(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_typename_A(N) generates sequences like:
      

        
typename A0, typename A1, … typename AN-1

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_typename_A.html
Chapter 5. Boost.Array\3



Chapter 5. Boost.Array











Home
Libraries
People
FAQ
More








Chapter 5. Boost.Array

Nicolai Josuttis

Copyright © 2001-2004 Nicolai M. Josuttis
Copyright © 2012 Marshall Clow

Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Reference
Header &lt;boost/array.hpp&gt;
Design Rationale
For more information...
Acknowledgements




Introduction
The C++ Standard Template Library STL as part of the C++
    Standard Library provides a framework for processing algorithms on
    different kind of containers. However, ordinary arrays don't
    provide the interface of STL containers (although, they provide
    the iterator interface of STL containers).
As replacement for ordinary arrays, the STL provides class
    std::vector.  However,
    std::vector&lt;&gt; provides
    the semantics of dynamic arrays. Thus, it manages data to be able
    to change the number of elements. This results in some overhead in
    case only arrays with static size are needed.
In his book, Generic Programming and the
    STL, Matthew H. Austern introduces a useful wrapper
    class for ordinary arrays with static size, called
    block.  It is safer and has no worse performance than
    ordinary arrays. In The C++ Programming
    Language, 3rd edition, Bjarne Stroustrup introduces a
    similar class, called c_array, which I (Nicolai Josuttis) present
    slightly modified in my book The C++ Standard Library -
    A Tutorial and Reference, called
    carray. This is the essence of these approaches
    spiced with many feedback from boost.
After considering different names, we decided to name this
    class simply array.
Note that this class is suggested to be part of the next
    Technical Report, which will extend the C++ Standard (see
    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1548.htm).
Update: std::array is (as of C++11) part of the C++ standard.
    The differences between boost::array and std::array are minimal.
    If you are using C++11, you should consider using std::array instead of boost::array.
    
Class array fulfills most
    but not all of the requirements of "reversible containers" (see
    Section 23.1, [lib.container.requirements] of the C++
    Standard). The reasons array is not an reversible STL container is
    because:
      

No constructors are provided.
Elements may have an undetermined initial value (see the section called “Design Rationale”).

swap() has no constant complexity.

size() is always constant, based on the second template argument of the type.
The container provides no allocator support.


    
It doesn't fulfill the requirements of a "sequence" (see Section 23.1.1, [lib.sequence.reqmts] of the C++ Standard), except that:
      


front() and back() are provided.

operator[] and at() are provided.


    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/array.html
Macro BOOST_ACCUMULATORS_MAX_ARGS\3



Macro BOOST_ACCUMULATORS_MAX_ARGS











Home
Libraries
People
FAQ
More








Macro BOOST_ACCUMULATORS_MAX_ARGS
BOOST_ACCUMULATORS_MAX_ARGS

Synopsis
// In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;

BOOST_ACCUMULATORS_MAX_ARGS

Description
The maximum number of arguments that may be specified to an accumulator_set's accumulation function. Defaults to 15. 


Copyright © 2005, 2006 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_ACCUMU_1_3_2_6_2_3_3.html
Macro BOOST_PROTO_REPEAT_EX\3



Macro BOOST_PROTO_REPEAT_EX











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_REPEAT_EX
BOOST_PROTO_REPEAT_EX — Repeatedly invoke the specified macro.

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_REPEAT_EX(MACRO, typename_A, A, A_a, a)

Description

        BOOST_PROTO_REPEAT_EX() is used to generate the kind of repetitive
        code that is typical of EDSLs built with Proto.
        BOOST_PROTO_REPEAT_EX(MACRO, typename_A, A, A_a, a)
        is equivalent to:
      

        
MACRO(1, typename_A, A, A_a, a)
MACRO(2, typename_A, A, A_a, a)
...
MACRO(BOOST_PROTO_MAX_ARITY, typename_A, A, A_a, a)

      

        Example:
      

        See BOOST_PROTO_REPEAT_FROM_TO().
      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_REPEAT_EX.html
Macro BOOST_DLL_USE_STD_FS\3



Macro BOOST_DLL_USE_STD_FS











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_USE_STD_FS
BOOST_DLL_USE_STD_FS — Define this macro to make Boost.DLL use C++17's std::filesystem::path, std::system_error and std::error_code. 

Synopsis
// In header: &lt;boost/dll/config.hpp&gt;

BOOST_DLL_USE_STD_FS

Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_USE_STD_FS.html
Chapter 4. Boost.Any 1.2\3



Chapter 4. Boost.Any 1.2











Home
Libraries
People
FAQ
More








Chapter 4. Boost.Any 1.2
Copyright © 2001 Kevlin Henney
Copyright © 2013-2023 Antony Polukhin


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Examples
ValueType requirements
Reference Section of Boost.Any

Header &lt;boost/any.hpp&gt;
Header &lt;boost/any/bad_any_cast.hpp&gt;
Header &lt;boost/any/basic_any.hpp&gt;
Header &lt;boost/any/fwd.hpp&gt;
Header &lt;boost/any/unique_any.hpp&gt;

Acknowledgements




Introduction


      There are times when a generic (in the sense of general
      as opposed to template-based programming) type is needed:
      variables that are truly variable, accommodating values of many other more
      specific types rather than C++'s normal strict and static types. We can distinguish
      three basic kinds of generic type:
    


          Converting types that can hold one of a number of possible value types,
          e.g. int and string, and freely convert between them,
          for instance interpreting 5
          as "5" or vice-versa.
          Such types are common in scripting and other interpreted languages. boost::lexical_cast supports such conversion
          functionality.
        

          Discriminated types that contain values of different types but do not attempt
          conversion between them, i.e. 5
          is held strictly as an int
          and is not implicitly convertible either to "5"
          or to 5.0. Their indifference
          to interpretation but awareness of type effectively makes them safe, generic
          containers of single values, with no scope for surprises from ambiguous
          conversions.
        

          Indiscriminate types that can refer to anything but are oblivious to the
          actual underlying type, entrusting all forms of access and interpretation
          to the programmer. This niche is dominated by void
          *, which offers plenty of scope
          for surprising, undefined behavior.
        


      The boost::any class (based on the
      class of the same name described in Valued
      Conversions by Kevlin Henney, C++ Report 12(7),
      July/August 2000) is a variant value type based on the second category. It
      supports copying of any value type and safe checked extraction of that value
      strictly against its type. A similar design, offering more appropriate operators,
      can be used for a generalized function adaptor, any_function,
      a generalized iterator adaptor, any_iterator,
      and other object types that need uniform runtime treatment but support only
      compile-time template parameter conformance.
    

      The boost::anys::unique_any
      class (based on the utils::AnyMovable
      class from the 🐙 userver framework)
      is a variant value type based on the second category. It supports safe checked
      extraction of that value strictly against its type and passing ownership of
      the value. Think of boost::anys::unique_any
      as of an alternative to boost::any
      (or to std::any) that does not require copy or move construction
      from the held type.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/any.html
Chapter 32. Boost.Random\3



Chapter 32. Boost.Random











Home
Libraries
People
FAQ
More








Chapter 32. Boost.Random

Jens Maurer

Copyright © 2000-2005 Jens Maurer
Copyright © 2009, 2010 Steven Watanabe


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Tutorial

Generating
      integers in a range
Generating
      integers with different probabilities
Generating
      a random password
Generating
      quasi-random line-sphere intersections

Reference

Concepts
Generators
Distributions
Utilities
Headers

Performance
History and
    Acknowledgements




Introduction


      Random numbers are useful in a variety of applications. The Boost Random Number
      Library (Boost.Random for short) provides a variety of generators
      and distributions
      to produce random numbers having useful properties, such as uniform distribution.
    

      You should read the concepts
      documentation for an introduction and the definition of the basic concepts.
      For a quick start, it may be sufficient to have a look at random_demo.cpp.
    

      For a very quick start, here's an example:
    
boost::random::mt19937 rng;         // produces randomness out of thin air
                                    // see pseudo-random number generators
boost::random::uniform_int_distribution&lt;&gt; six(1,6);
                                    // distribution that maps to 1..6
                                    // see random number distributions
int x = six(rng);                   // simulate rolling a die










\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_random.html
Macro BOOST_YAP_USER_CALL_OPERATOR_N\3



Macro BOOST_YAP_USER_CALL_OPERATOR_N











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_CALL_OPERATOR_N
BOOST_YAP_USER_CALL_OPERATOR_N

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_CALL_OPERATOR_N(expr_template, n)

Description
Defines operator overloads for the call operator taking N parameters ("operator()(t0, t1, ... tn-1)") that each produce an expression instantiated from the expr_template expression template. One overload is defined for each of the qualifiers const &amp;, &amp;, and &amp;&amp;. For the lvalue reference overloads, *this is captured by reference into the resulting expression. For the rvalue reference overload, *this is moved into the resulting expression.
The u parameters to each of the defined overloads may be any type, including an expression. Each non-expression is wrapped in a terminal expression.
Example: 









Parameters:







expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate.


n
The number of parameters accepted by the operator() overloads. n must be &lt;= BOOST_PP_LIMIT_REPEAT. 







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_6.html
Chapter 2. Boost String Algorithms Library\3



Chapter 2. Boost String Algorithms Library











Home
Libraries
People
FAQ
More








Chapter 2. Boost String Algorithms Library

Pavol Droba

Copyright © 2002-2004 Pavol Droba

Use, modification and distribution is subject to the Boost
                Software License, Version 1.0. (See accompanying file
                LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
            



Table of Contents

Introduction
Release Notes
Usage

First Example
Case conversion
Predicates and Classification
Trimming
Find algorithms
Replace Algorithms
Find Iterator
Split

Quick Reference

Algorithms
Finders and Formatters
Iterators
Classification

Design Topics

String Representation
Sequence Traits
Find Algorithms
Replace Algorithms
Find Iterators &amp; Split Algorithms
Exception Safety

Concepts

Definitions
Finder Concept
Formatter concept

Reference

Header &lt;boost/algorithm/string.hpp&gt;
Header &lt;boost/algorithm/string/case_conv.hpp&gt;
Header &lt;boost/algorithm/string/classification.hpp&gt;
Header &lt;boost/algorithm/string/compare.hpp&gt;
Header &lt;boost/algorithm/string/concept.hpp&gt;
Header &lt;boost/algorithm/string/constants.hpp&gt;
Header &lt;boost/algorithm/string/erase.hpp&gt;
Header &lt;boost/algorithm/string/find.hpp&gt;
Header &lt;boost/algorithm/string/find_format.hpp&gt;
Header &lt;boost/algorithm/string/find_iterator.hpp&gt;
Header &lt;boost/algorithm/string/finder.hpp&gt;
Header &lt;boost/algorithm/string/formatter.hpp&gt;
Header &lt;boost/algorithm/string/iter_find.hpp&gt;
Header &lt;boost/algorithm/string/join.hpp&gt;
Header &lt;boost/algorithm/string/predicate.hpp&gt;
Header &lt;boost/algorithm/string/regex.hpp&gt;
Header &lt;boost/algorithm/string/regex_find_format.hpp&gt;
Header &lt;boost/algorithm/string/replace.hpp&gt;
Header &lt;boost/algorithm/string/sequence_traits.hpp&gt;
Header &lt;boost/algorithm/string/split.hpp&gt;
Header &lt;boost/algorithm/string/std_containers_traits.hpp&gt;
Header &lt;boost/algorithm/string/trim.hpp&gt;
Header &lt;boost/algorithm/string/trim_all.hpp&gt;
Header &lt;boost/algorithm/string_regex.hpp&gt;

Rationale

Locales
Regular Expressions

Environment

Build
Examples
Tests
Portability

Credits
Acknowledgments




Introduction

        The String Algorithm Library provides a generic implementation of
        string-related algorithms which are missing in STL. It is an extension
        to the algorithms library of STL and it includes trimming, case conversion, 
        predicates and find/replace functions. All of them come in different variants 
        so it is easier to choose the best fit for a particular need.
    

        The implementation is not restricted to work with a particular container 
        (like std::basic_string), rather it is as generic as
        possible. This generalization is not compromising the performance since
        algorithms are using container specific features when it means a performance
        gain.
    

        
            Important note: In this documentation we use term string to 
            designate a sequence of characters stored in an arbitrary container.
            A string is not restricted to std::basic_string and 
            character does not have to be char or wchar_t,
            although these are most common candidates.
        
        Consult the design chapter to see precise specification of
        supported string types.
    
      
        The library interface functions and classes are defined in namespace boost::algorithm, and
        they are lifted into namespace boost via using declaration.
    

        The documentation is divided into several sections. For a quick start read the 
        Usage section followed by 
        Quick Reference. 
        The Design Topics,
        Concepts and Rationale
        provide some explanation about the library design and structure an explain how it should be used.
        See the Reference for the complete list of provided utilities
        and algorithms. Functions and classes in the reference are organized by the headers in which they are defined.
        The reference contains links to the detailed description for every entity in the library.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/string_algo.html
Macro BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE\3



Macro BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE
BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE

Synopsis
// In header: &lt;boost/type_erasure/config.hpp&gt;

BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE

Description
The maximum number of elements in a tuple. 


Copyright © 2011-2013 Steven Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE__1_3_40_13_11_3.html
Concept Domain\3



Concept Domain











Home
Libraries
People
FAQ
More








Concept Domain
Domain


Description

      A Domain creates an association between expressions and a so-called
      generator, which is a function that maps an expression in the default
      domain to an equivalent expression in this Domain. It also associates
      an expression with a grammar, to which all expressions within this
      Domain must conform.
    


Associated types


proto_grammar
Domain::proto_grammar

      
The grammar to which every expression in this Domain
        must conform.

    


proto_generator
Domain::proto_generator

      

        A Unary Polymorphic Function that accepts expressions in the
        default domain and emits expressions in this Domain.
      

    


proto_super_domain
Domain::proto_super_domain

      

        The Domain that is a super-domain of this domain, if
        any such domain exists. If not, it is some unspecified
        type.
      

    


result_type
boost::result_of&lt;Domain(Expr)&gt;::type

      

        The type of the result of applying
        proto_generator to
        the specified expression type. The result is required to
        model Expr. The domain type
        associated with result_type
        (result_type::proto_domain)
        is required to be the same type as this Domain.
      

    


as_expr_result_type
Domain::as_expr&lt;Object&gt;::result_type

      

        The result of converting some type to a Proto expression
        type in this domain. This is used, for instance, when
        calculating the type of a variable to hold a Proto
        expression.
        as_expr_result_type
        models
        Expr.
      

    


as_child_result_type
Domain::as_child&lt;Object&gt;::result_type

      

        The result of converting some type to a Proto expression
        type in this domain. This is used, for instance, to
        compute the type of an object suitable for storage
        as a child in an expression tree.
        as_child_result_type
        models
        Expr.
      

    




Notation

Domain
A type playing the role of domain-type in the Domain concept.
Expr
A type playing the role of expression-type in the Domain concept.
Object
A type playing the role of object-type in the Domain concept.
d
Object of type Domain
e
Object of type Expr
o
Object of type Object



Valid expressions








Name
Expression
Type
Semantics



Apply Generator
d(e)
result_type

      The result of applying proto_generator
      to the specified expression.
    


As Expression
Domain::as_expr&lt; Object &gt;()(o)
as_expr_result_type

      The result of converting some object to a Proto expression
      in this domain. It returns a Proto expression object that
      is suitable for storage in a variable. It should return a
      new object, which may be a copy of the object passed in.
    


As Child
Domain::as_child&lt; Object &gt;()(o)
as_child_result_type

      The result of converting some object to a Proto expression
      in this domain. It returns an object suitable for storage
      as a child in an expression tree, which may simply be a
      reference to the object passed in.
    





Models
boost::proto::default_domain


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/Domain.html
Macro BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS\3



Macro BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS
BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS

Synopsis
// In header: &lt;boost/units/config.hpp&gt;

BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS

Description
Enable checking to verify that a homogeneous system is actually capable of representing all the dimensions that it is used with. Off by default. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_6_3.html
Macro BOOST_PROTO_LOCAL_ITERATE\3



Macro BOOST_PROTO_LOCAL_ITERATE











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_LOCAL_ITERATE
BOOST_PROTO_LOCAL_ITERATE — Vertical repetition of a user-supplied macro.

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_LOCAL_ITERATE()

Description

        BOOST_PROTO_LOCAL_ITERATE() is used generate the kind of repetitive code that is typical
        of EDSLs built with Proto. This macro causes the user-defined macro BOOST_PROTO_LOCAL_MACRO() to
        be expanded with values in the range specified by BOOST_PROTO_LOCAL_LIMITS.
      

        Usage:
      

        
#include BOOST_PROTO_LOCAL_ITERATE()

      

        Example:
      

        
// Generate BOOST_PROTO_MAX_ARITY-1 overloads of the
// following construct() function template.
#define BOOST_PROTO_LOCAL_MACRO(N, typename_A, A_const_ref, A_const_ref_a, ref_a)\
template&lt;typename T, typename_A(N)&gt;                               \
typename proto::result_of::make_expr&lt;                             \
    proto::tag::function                                          \
  , construct_helper&lt;T&gt;                                           \
  , A_const_ref(N)                                                \
&gt;::type const                                                     \
construct(A_const_ref_a(N))                                       \
{                                                                 \
    return proto::make_expr&lt;                                      \
        proto::tag::function                                      \
    &gt;(                                                            \
        construct_helper&lt;T&gt;()                                     \
      , ref_a(N)                                                  \
    );                                                            \
}
#define BOOST_PROTO_LOCAL_LIMITS (1, BOOST_PP_DEC(BOOST_PROTO_MAX_ARITY))
#include BOOST_PROTO_LOCAL_ITERATE()

      

        The above inclusion of BOOST_PROTO_LOCAL_ITERATE()
        will generate the following code:
      

        
template&lt;typename T, typename A0&gt;
typename proto::result_of::make_expr&lt;
    proto::tag::function
  , construct_helper&lt;T&gt;
  , A0 const &amp;
&gt;::type const
construct(A0 const &amp; a0)
{
    return proto::make_expr&lt;
        proto::tag::function
    &gt;(
        construct_helper&lt;T&gt;()
      , boost::ref(a0)
    );
}

template&lt;typename T, typename A0, typename A1&gt;
typename proto::result_of::make_expr&lt;
    proto::tag::function
  , construct_helper&lt;T&gt;
  , A0 const &amp;
  , A1 const &amp;
&gt;::type const
construct(A0 const &amp; a0, A1 const &amp; a1)
{
    return proto::make_expr&lt;
        proto::tag::function
    &gt;(
        construct_helper&lt;T&gt;()
      , boost::ref(a0)
      , boost::ref(a1)
    );
}

// ... and so on, up to BOOST_PROTO_MAX_ARITY-1 arguments ...

      

        If BOOST_PROTO_LOCAL_LIMITS is not defined by the user, it defaults
        to (1, BOOST_PROTO_MAX_ARITY).
      

        At each iteration, BOOST_PROTO_LOCAL_MACRO() is invoked with the current
        iteration number and the following 4 macro parameters:
        

BOOST_PROTO_LOCAL_typename_A
BOOST_PROTO_LOCAL_A
BOOST_PROTO_LOCAL_A_a
BOOST_PROTO_LOCAL_a


        If these macros are not defined by the user, they default respectively to:
        

BOOST_PROTO_typename_A
BOOST_PROTO_A_const_ref
BOOST_PROTO_A_const_ref_a
BOOST_PROTO_ref_a


      

        After including BOOST_PROTO_LOCAL_ITERATE(), the
        following macros are automatically undefined:
        

BOOST_PROTO_LOCAL_MACRO
BOOST_PROTO_LOCAL_LIMITS
BOOST_PROTO_LOCAL_typename_A
BOOST_PROTO_LOCAL_A
BOOST_PROTO_LOCAL_A_a
BOOST_PROTO_LOCAL_a


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_LOCAL_ITERATE.html
Macro BOOST_TYPE_ERASURE_MAX_FUNCTIONS\3



Macro BOOST_TYPE_ERASURE_MAX_FUNCTIONS











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_ERASURE_MAX_FUNCTIONS
BOOST_TYPE_ERASURE_MAX_FUNCTIONS

Synopsis
// In header: &lt;boost/type_erasure/config.hpp&gt;

BOOST_TYPE_ERASURE_MAX_FUNCTIONS

Description
The maximum number of functions that an any can have. 


Copyright © 2011-2013 Steven Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE__1_3_40_13_11_1.html
Macro BOOST_DLL_SECTION\3



Macro BOOST_DLL_SECTION











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_SECTION
BOOST_DLL_SECTION — Macro that puts symbol to a specific section. On MacOS all the sections are put into "__DATA" segment. 

Synopsis
// In header: &lt;boost/dll/alias.hpp&gt;

BOOST_DLL_SECTION(SectionName, Permissions)

Description








Parameters:







Permissions
Can be "read" or "write" (without quotes!). 


SectionName
Name of the section. Must be a valid C identifier without quotes not longer than 8 bytes. 







Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_SECTION.html
Chapter 29. Boost.Program_options\3



Chapter 29. Boost.Program_options











Home
Libraries
People
FAQ
More








Chapter 29. Boost.Program_options

Vladimir Prus

Copyright © 2002-2004 Vladimir Prus

Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Tutorial

Getting Started
Option Details
Multiple Sources

Library Overview

Options Description Component
Parsers Component
Storage Component
Specific parsers
Types
Annotated List of Symbols

How To

Non-conventional Syntax
Response Files
Winmain Command Line
Option Groups and Hidden Options
Custom Validators
Unicode Support
Allowing Unknown Options
Testing Option Presence

Design Discussion
Unicode Support
Acknowledgements
Reference

Header &lt;boost/program_options/cmdline.hpp&gt;
Header &lt;boost/program_options/config.hpp&gt;
Header &lt;boost/program_options/environment_iterator.hpp&gt;
Header &lt;boost/program_options/eof_iterator.hpp&gt;
Header &lt;boost/program_options/errors.hpp&gt;
Header &lt;boost/program_options/option.hpp&gt;
Header &lt;boost/program_options/options_description.hpp&gt;
Header &lt;boost/program_options/parsers.hpp&gt;
Header &lt;boost/program_options/positional_options.hpp&gt;
Header &lt;boost/program_options/value_semantic.hpp&gt;
Header &lt;boost/program_options/variables_map.hpp&gt;
Header &lt;boost/program_options/version.hpp&gt;





Introduction
The program_options library allows program developers to obtain
    program options, that is (name, value) pairs from the user,
    via conventional methods such as command line and config file.
Why would you use such a library, and why is it better than parsing
    your command line by straightforward hand-written code?
      

It's easier. The syntax for declaring options is simple, and
          the library itself is small. Things like conversion of option values to
          desired type and storing into program variables are handled
          automatically.
          
Error reporting is better. All the problems with the command line are
            reported, while hand-written code can just misparse the input. In
            addition, the usage message can be automatically generated, to
            avoid falling out of sync with the real list of options.
Options can be read from anywhere. Sooner or later the command
          line will be not enough for your users, and you'll want config files
          or maybe even environment variables. These can be added without significant 
          effort on your part.
          


    

      Now let's see some examples of the library usage in the the section called “Tutorial”.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/program_options.html
Macro BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING\3



Macro BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING
BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING

Synopsis
// In header: &lt;boost/type_index.hpp&gt;

BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING

Description
This is a helper macro for making correct pretty_names() with RTTI off.
BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a support for compilers, that by default are not recognized by TypeIndex library.
Example: 
Imagine the situation when 
boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name() 

 returns the following string: 
"static const char *boost::detail::ctti&lt;int&gt;::n() [T = int]" 

 and 
boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name() 

 returns the following: 
"static const char *boost::detail::ctti&lt;short&gt;::n() [T = short]" 

As we may see first 39 characters are "static const char *boost::detail::ctti&lt;" and they do not depend on the type T. After first 39 characters we have a human readable type name which is duplicated at the end of a string. String always ends on ']', which consumes 1 character.
Now if we define BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING to (39, 1, false, "") we'll be getting 
"int&gt;::n() [T = int" 

 for boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name() and 
"short&gt;::n() [T = short" 

 for boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name().
Now we need to take additional care of the characters that go before the last mention of our type. We'll do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = " itself:
(39, 1, true, "T = ") 

In case of GCC or Clang command line we need to add the following line while compiling all the sources:
-DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'

 
See RTTI emulation limitations for more info. 


Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_2_6.html
Reference Section of PFR\3



Reference Section of PFR











Home
Libraries
People
FAQ
More







Reference Section of PFR

Header &lt;boost/pfr.hpp&gt;
Header &lt;boost/pfr/config.hpp&gt;
Header &lt;boost/pfr/core.hpp&gt;
Header &lt;boost/pfr/core_name.hpp&gt;
Header &lt;boost/pfr/functions_for.hpp&gt;
Header &lt;boost/pfr/functors.hpp&gt;
Header &lt;boost/pfr/io.hpp&gt;
Header &lt;boost/pfr/io_fields.hpp&gt;
Header &lt;boost/pfr/ops.hpp&gt;
Header &lt;boost/pfr/ops_fields.hpp&gt;
Header &lt;boost/pfr/traits.hpp&gt;
Header &lt;boost/pfr/traits_fwd.hpp&gt;
Header &lt;boost/pfr/tuple_size.hpp&gt;



Header &lt;boost/pfr.hpp&gt;
Includes all the Boost.PFR headers 



Header &lt;boost/pfr/config.hpp&gt;
Contains all the macros that describe Boost.PFR configuration, like BOOST_PFR_ENABLED



Note

This header file doesn't require C++14 Standard and supports all C++ compilers, even pre C++14 compilers (C++11, C++03...). 





BOOST_PFR_NOT_SUPPORTED
BOOST_PFR_USE_LOOPHOLE
BOOST_PFR_USE_CPP17
BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE
BOOST_PFR_HAS_GUARANTEED_COPY_ELISION
BOOST_PFR_ENABLE_IMPLICIT_REFLECTION
BOOST_PFR_CORE_NAME_ENABLED
BOOST_PFR_CORE_NAME_PARSING
BOOST_PFR_MAYBE_UNUSED
BOOST_PFR_ENABLED



Header &lt;boost/pfr/core.hpp&gt;
Contains all the basic tuple-like interfaces   boost::pfr::get ,   boost::pfr::tuple_size ,   boost::pfr::tuple_element_t , and others.
Synopsis: 
namespace boost {
  namespace pfr {
    typedef unspecified tuple_element;
    typedef typename tuple_element&lt; I, T &gt;::type tuple_element_t;
    template&lt;std::size_t I, typename T&gt; 
      constexpr decltype(auto) get(const T &amp;);
    template&lt;std::size_t I, typename T&gt; 
      constexpr decltype(auto) 
      get(T &amp; val, 
          std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; * = nullptr);
    template&lt;std::size_t I, typename T&gt; 
      constexpr auto 
      get(T &amp;, 
          std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; * = nullptr);
    template&lt;std::size_t I, typename T&gt; 
      constexpr auto 
      get(T &amp;&amp; val, 
          std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; * = nullptr);
    template&lt;typename U, typename T&gt; constexpr const U &amp; get(const T &amp; val);
    template&lt;typename U, typename T&gt; 
      constexpr U &amp; 
      get(T &amp; val, 
          std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; * = nullptr);
    template&lt;typename U, typename T&gt; 
      constexpr U &amp; 
      get(T &amp;, 
          std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; * = nullptr);
    template&lt;typename U, typename T&gt; 
      constexpr U &amp;&amp; 
      get(T &amp;&amp; val, 
          std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; * = nullptr);
    template&lt;typename T&gt; constexpr auto structure_to_tuple(const T &amp;);
    template&lt;typename T&gt; constexpr auto structure_tie(const T &amp;);
    template&lt;typename T&gt; 
      constexpr auto 
      structure_tie(T &amp; val, 
                    std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; * = nullptr);
    template&lt;typename T&gt; 
      constexpr auto 
      structure_tie(T &amp;, 
                    std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; * = nullptr);
    template&lt;typename T&gt; 
      constexpr auto 
      structure_tie(T &amp;&amp;, 
                    std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; * = nullptr);
    template&lt;typename T, typename F&gt; constexpr void for_each_field(T &amp;&amp;, F &amp;&amp;);
    template&lt;typename... Elements&gt; 
      unspecified tie_from_structure(Elements &amp;...);
  }
}



Header &lt;boost/pfr/core_name.hpp&gt;
Contains functions   boost::pfr::get_name  and   boost::pfr::names_as_array  to know which names each field of any   simple aggregate   has.
See Also :   'Reflection of field names'   for details.
Synopsis: 
namespace boost {
  namespace pfr {
    template&lt;std::size_t I, typename T&gt; constexpr std::string_view get_name();
    template&lt;typename T&gt; 
      constexpr std::array&lt; std::string_view, boost::pfr::tuple_size_v&lt; T &gt; &gt; 
      names_as_array();
  }
}



Header &lt;boost/pfr/functions_for.hpp&gt;
Contains BOOST_PFR_FUNCTIONS_FOR macro that defined comparison and stream operators for T along with hash_value function. Example: 
#include &lt;boost/pfr/functions_for.hpp&gt;

namespace my_namespace {
    struct my_struct {      // No operators defined for that structure
        int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
    };
    BOOST_PFR_FUNCTIONS_FOR(my_struct)
}

See Also :   'Three ways of getting operators'   for other ways to define operators and more details.
Synopsis: 


BOOST_PFR_FUNCTIONS_FOR(T)



Header &lt;boost/pfr/functors.hpp&gt;
Contains functors that are close to the Standard Library ones. Each functor calls corresponding Boost.PFR function from boost/pfr/ops.hpp
Example: 
#include &lt;boost/pfr/functors.hpp&gt;
struct my_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

std::unordered_set&lt;
    my_struct,
    boost::pfr::hash&lt;&gt;,
    boost::pfr::equal_to&lt;&gt;
&gt; my_set;

Synopsis: 
namespace boost {
  namespace pfr {
    template&lt;typename T = void&gt; struct equal_to;
    template&lt;typename T = void&gt; struct greater;
    template&lt;typename T = void&gt; struct greater_equal;
    template&lt;typename T&gt; struct hash;
    template&lt;typename T = void&gt; struct less;
    template&lt;typename T = void&gt; struct less_equal;
    template&lt;typename T = void&gt; struct not_equal;
  }
}



Header &lt;boost/pfr/io.hpp&gt;
Contains IO stream manipulator   boost::pfr::io  for types. If type is streamable using its own operator or its conversion operator, then the types operator is used.
Example: 
#include &lt;boost/pfr/io.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
std::cout &lt;&lt; boost::pfr::io(s1);  // Outputs: {0, 1, H, e, l, l, o, , , 0, 6, 7, 8, 9, 10, 11}

See Also :   'Three ways of getting operators'   for other ways to define operators and more details.
Synopsis: 
namespace boost {
  namespace pfr {
    template&lt;typename T&gt; auto io(T &amp;&amp;);
  }
}



Header &lt;boost/pfr/io_fields.hpp&gt;
Contains IO manipulator   boost::pfr::io_fields  to read/write any   simple aggregate   field-by-field.
Example: 
struct my_struct {
    int i;
    short s;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_struct&amp; x) {
    return os &lt;&lt; boost::pfr::io_fields(x);  // Equivalent to: os &lt;&lt; "{ " &lt;&lt; x.i &lt;&lt; " ," &lt;&lt;  x.s &lt;&lt; " }"
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, my_struct&amp; x) {
    return is &gt;&gt; boost::pfr::io_fields(x);  // Equivalent to: is &gt;&gt; "{ " &gt;&gt; x.i &gt;&gt; " ," &gt;&gt;  x.s &gt;&gt; " }"
}

See Also :   'Three ways of getting operators'   for other ways to define operators and more details.
Synopsis: 
namespace boost {
  namespace pfr {
    template&lt;typename T&gt; auto io_fields(T &amp;&amp;);
  }
}



Header &lt;boost/pfr/ops.hpp&gt;
Contains comparison and hashing functions. If type is comparable using its own operator or its conversion operator, then the types operator is used. Otherwise the operation is done via corresponding function from boost/pfr/ops.hpp header.
Example: 
#include &lt;boost/pfr/ops.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
comparable_struct s2 {0, 1, "Hello", false, 6,7,8,9,10,11111};
assert(boost::pfr::lt(s1, s2));

See Also :   'Three ways of getting operators'   for other ways to define operators and more details.
Synopsis: 
namespace boost {
  namespace pfr {
    template&lt;typename T, typename U&gt; unspecified eq(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      unspecified eq(const T &amp; lhs, const U &amp; rhs);
    template&lt;typename T, typename U&gt; unspecified ne(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      unspecified ne(const T &amp; lhs, const U &amp; rhs);
    template&lt;typename T, typename U&gt; unspecified lt(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      unspecified lt(const T &amp; lhs, const U &amp; rhs);
    template&lt;typename T, typename U&gt; unspecified gt(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      unspecified gt(const T &amp; lhs, const U &amp; rhs);
    template&lt;typename T, typename U&gt; unspecified le(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      unspecified le(const T &amp; lhs, const U &amp; rhs);
    template&lt;typename T, typename U&gt; unspecified ge(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      unspecified ge(const T &amp; lhs, const U &amp; rhs);
    template&lt;typename T&gt; unspecified hash_value(const T &amp;);
    template&lt;typename T&gt; unspecified hash_value(const T &amp; value);
  }
}



Header &lt;boost/pfr/ops_fields.hpp&gt;
Contains field-by-fields comparison and hash functions.
Example: 
#include &lt;boost/pfr/ops_fields.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s;
};
// ...

comparable_struct s1 {0, 1};
comparable_struct s2 {0, 2};
assert(boost::pfr::lt_fields(s1, s2));

See Also :   'Three ways of getting operators'   for other ways to define operators and more details.
Synopsis: 
namespace boost {
  namespace pfr {
    template&lt;typename T, typename U&gt; 
      constexpr bool eq_fields(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      constexpr bool ne_fields(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      constexpr bool gt_fields(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      constexpr bool lt_fields(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      constexpr bool ge_fields(const T &amp;, const U &amp;);
    template&lt;typename T, typename U&gt; 
      constexpr bool le_fields(const T &amp;, const U &amp;);
    template&lt;typename T&gt; std::size_t hash_fields(const T &amp;);
  }
}



Header &lt;boost/pfr/traits.hpp&gt;
Contains traits   boost::pfr::is_reflectable  and   boost::pfr::is_implicitly_reflectable  for detecting an ability to reflect type.
Synopsis: 
namespace boost {
  namespace pfr {
    template&lt;typename T, typename WhatFor&gt; struct is_reflectable;

    template&lt;typename T, typename WhatFor&gt; 
      struct is_reflectable&lt;const T, WhatFor&gt;;
    template&lt;typename T, typename WhatFor&gt; 
      struct is_reflectable&lt;const volatile T, WhatFor&gt;;
    template&lt;typename T, typename WhatFor&gt; 
      struct is_reflectable&lt;volatile T, WhatFor&gt;;
    typedef unspecified is_implicitly_reflectable;

    constexpr bool is_implicitly_reflectable_v;
  }
}


Header &lt;boost/pfr/traits_fwd.hpp&gt;


Header &lt;boost/pfr/tuple_size.hpp&gt;
Contains tuple-like interfaces to get fields count   boost::pfr::tuple_size ,   boost::pfr::tuple_size_v .
Synopsis: 
namespace boost {
  namespace pfr {
    typedef unspecified tuple_size;

    constexpr std::size_t tuple_size_v;
  }
}


Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/reference_section_of_pfr.html
Macro BOOST_STL_INTERFACES_NAMESPACE_V3\3



Macro BOOST_STL_INTERFACES_NAMESPACE_V3











Home
Libraries
People
FAQ
More








Macro BOOST_STL_INTERFACES_NAMESPACE_V3
BOOST_STL_INTERFACES_NAMESPACE_V3

Synopsis
// In header: &lt;boost/stl_interfaces/config.hpp&gt;

BOOST_STL_INTERFACES_NAMESPACE_V3

Copyright © 2019 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_STL__1_3_38_15_2_2_5.html
Macro BOOST_PROTO_MAX_FUNCTION_CALL_ARITY\3



Macro BOOST_PROTO_MAX_FUNCTION_CALL_ARITY











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_MAX_FUNCTION_CALL_ARITY
BOOST_PROTO_MAX_FUNCTION_CALL_ARITY — Controls the maximum number of arguments that operator() overloads
      accept.

Synopsis
// In header: &lt;boost/proto/proto_fwd.hpp&gt;

BOOST_PROTO_MAX_FUNCTION_CALL_ARITY

Description

        When setting
        
          BOOST_PROTO_MAX_ARITY
         higher than the default, compile times
        slow down considerably. That is due in large part to the explosion in the number of
        operator() overloads that must be generated for each
        Proto expression type. By setting BOOST_PROTO_MAX_FUNCTION_CALL_ARITY
        lower than BOOST_PROTO_MAX_ARITY,
        compile times can be sped up considerably.
      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_35_5.html
Macro BOOST_UNITS_NO_COMPILER_CHECK\3



Macro BOOST_UNITS_NO_COMPILER_CHECK











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_NO_COMPILER_CHECK
BOOST_UNITS_NO_COMPILER_CHECK

Synopsis
// In header: &lt;boost/units/config.hpp&gt;

BOOST_UNITS_NO_COMPILER_CHECK

Description
If defined will disable a preprocessor check that the compiler is able to handle the library. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_6_2.html
Chapter 31. Boost.Proto\3



Chapter 31. Boost.Proto











Home
Libraries
People
FAQ
More








Chapter 31. Boost.Proto

Eric Niebler

Copyright © 2008 Eric Niebler


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Preface
Users' Guide

Getting Started
Fronts Ends: Defining
      Terminals and Non-Terminals of Your EDSL
Intermediate
      Form: Understanding and Introspecting Expressions
Back Ends: Making Expression
      Templates Do Useful Work
Examples
Background and Resources
Glossary

Reference

Concepts
Classes
Functions
Header &lt;boost/proto/args.hpp&gt;
Header &lt;boost/proto/core.hpp&gt;
Header &lt;boost/proto/debug.hpp&gt;
Header &lt;boost/proto/deep_copy.hpp&gt;
Header &lt;boost/proto/domain.hpp&gt;
Header &lt;boost/proto/eval.hpp&gt;
Header &lt;boost/proto/expr.hpp&gt;
Header &lt;boost/proto/extends.hpp&gt;
Header &lt;boost/proto/functional.hpp&gt;
Header &lt;boost/proto/functional/fusion.hpp&gt;
Header &lt;boost/proto/functional/fusion/at.hpp&gt;
Header &lt;boost/proto/functional/fusion/pop_back.hpp&gt;
Header &lt;boost/proto/functional/fusion/pop_front.hpp&gt;
Header &lt;boost/proto/functional/fusion/push_back.hpp&gt;
Header &lt;boost/proto/functional/fusion/push_front.hpp&gt;
Header &lt;boost/proto/functional/fusion/reverse.hpp&gt;
Header &lt;boost/proto/functional/range/begin.hpp&gt;
Header &lt;boost/proto/functional/range/empty.hpp&gt;
Header &lt;boost/proto/functional/range/end.hpp&gt;
Header &lt;boost/proto/functional/range/rbegin.hpp&gt;
Header &lt;boost/proto/functional/range/rend.hpp&gt;
Header &lt;boost/proto/functional/range/size.hpp&gt;
Header &lt;boost/proto/functional/std.hpp&gt;
Header &lt;boost/proto/functional/std/iterator.hpp&gt;
Header &lt;boost/proto/functional/std/utility.hpp&gt;
Header &lt;boost/proto/fusion.hpp&gt;
Header &lt;boost/proto/generate.hpp&gt;
Header &lt;boost/proto/literal.hpp&gt;
Header &lt;boost/proto/make_expr.hpp&gt;
Header &lt;boost/proto/matches.hpp&gt;
Header &lt;boost/proto/operators.hpp&gt;
Header &lt;boost/proto/proto.hpp&gt;
Header &lt;boost/proto/proto_fwd.hpp&gt;
Header &lt;boost/proto/proto_typeof.hpp&gt;
Header &lt;boost/proto/repeat.hpp&gt;
Header &lt;boost/proto/tags.hpp&gt;
Header &lt;boost/proto/traits.hpp&gt;
Header &lt;boost/proto/transform.hpp&gt;
Header &lt;boost/proto/transform/arg.hpp&gt;
Header &lt;boost/proto/transform/call.hpp&gt;
Header &lt;boost/proto/transform/default.hpp&gt;
Header &lt;boost/proto/transform/env.hpp&gt;
Header &lt;boost/proto/transform/fold.hpp&gt;
Header &lt;boost/proto/transform/fold_tree.hpp&gt;
Header &lt;boost/proto/transform/impl.hpp&gt;
Header &lt;boost/proto/transform/integral_c.hpp&gt;
Header &lt;boost/proto/transform/lazy.hpp&gt;
Header &lt;boost/proto/transform/make.hpp&gt;
Header &lt;boost/proto/transform/pass_through.hpp&gt;
Header &lt;boost/proto/transform/when.hpp&gt;
Header &lt;boost/proto/context.hpp&gt;
Header &lt;boost/proto/context/callable.hpp&gt;
Header &lt;boost/proto/context/default.hpp&gt;
Header &lt;boost/proto/context/null.hpp&gt;

Appendices

Appendix A: Release
      Notes
Appendix B: History
Appendix C: Rationale
Appendix D: Implementation
      Notes
Appendix E:
      Acknowledgements





Preface


        “There are more things in heaven and earth, Horatio, than are dreamt
        of in your philosophy.”
      

        -- William Shakespeare
      


      Description
    

      Proto is a framework for building Embedded Domain-Specific Languages in C++.
      It provides tools for constructing, type-checking, transforming and executing
      expression templates[32]. More specifically, Proto provides:
    


          An expression tree data structure.
        

          A mechanism for giving expressions additional behaviors and members.
        

          Operator overloads for building the tree from an expression.
        

          Utilities for defining the grammar to which an expression must conform.
        

          An extensible mechanism for immediately executing an expression template.
        

          An extensible set of tree transformations to apply to expression trees.
        



      Motivation
    

      Expression Templates are an advanced technique that C++ library developers
      use to define embedded mini-languages that target specific problem domains.
      The technique has been used to create efficient and easy-to-use libraries for
      linear algebra as well as to define C++ parser generators with a readable syntax.
      But developing such a library involves writing an inordinate amount of unreadable
      and unmaintainable template mumbo-jumbo. Boost.Proto eases the development
      of domain-specific embedded
      languages (EDSLs). Use Proto to define the primitives of your mini-language
      and let Proto handle the operator overloading and the construction of the expression
      parse tree. Immediately evaluate the expression tree by passing it a function
      object. Or transform the expression tree by defining the grammar of your mini-language,
      decorated with an assortment of tree transforms provided by Proto or defined
      by you. Then use the grammar to give your users short and readable syntax errors
      for invalid expressions! No more mumbo-jumbo -- an expression template library
      developed with Proto is declarative and readable.
    

      In short, Proto is an EDSL for defining EDSLs.
    


      How
      to Use This Documentation
    

      This documentation makes use of the following naming and formatting conventions.
    


          Code is in fixed width
          font and is syntax-highlighted.
        

          Replaceable text that you will need to supply is in italics.
        

          If a name refers to a free function, it is specified like this: free_function();
          that is, it is in code font and its name is followed by ()
          to indicate that it is a free function.
        

          If a name refers to a class template, it is specified like this: class_template&lt;&gt;;
          that is, it is in code font and its name is followed by &lt;&gt;
          to indicate that it is a class template.
        

          If a name refers to a function-like macro, it is specified like this:
          MACRO();
          that is, it is uppercase in code font and its name is followed by () to indicate that it is a function-like
          macro. Object-like macros appear without the trailing ().
        

          Names that refer to concepts in the generic programming
          sense are specified in CamelCase.
        




Note


        In addition, notes such as this one specify non-essential information that
        provides additional background or rationale.
      


      Finally, you can mentally add the following to any code fragments in this document:
    
// Include all of Proto
#include &lt;boost/proto/proto.hpp&gt;

// Create some namespace aliases
namespace mpl = boost::mpl;
namespace fusion = boost::fusion;
namespace proto = boost::proto;

// Allow unqualified use of Proto's wildcard pattern
using proto::_;




[32] 
        See Expression
        Templates
      









\3https://www.boost.org/doc/libs/1_84_0/doc/html/proto.html
Boost.Asio\3


Boost.Asio









Home
Libraries
People
FAQ
More






Boost.Asio

Christopher Kohlhoff

Copyright © 2003-2023 Christopher M. Kohlhoff


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



    Boost.Asio is a cross-platform C++ library for network and low-level I/O programming
    that provides developers with a consistent asynchronous model using a modern
    C++ approach.
  



 Overview 

          An overview of the features included in Boost.Asio, plus rationale and
          design information.
        
 Using, Building, and Configuring Boost.Asio
      

          How to use Boost.Asio in your applications. Includes information on library
          dependencies and supported platforms.
        
 Tutorial 

          A tutorial that introduces the fundamental concepts required to use Boost.Asio,
          and shows how to use Boost.Asio to develop simple client and server programs.
        
 Examples 

          Examples that illustrate the use of Boost.Asio in more complex applications.
        
 Reference 

          Detailed class and function reference.
        
 Networking TS Compatibility
      

          Description of changes to provide compatibility with the "C++ Extensions
          for Networking" Technical Specification.
        
 Proposed Standard Executors
      

          Description of Boost.Asio's support for the proposed standard executors
          library.
        
 Revision History 

          Log of Boost.Asio changes made in each Boost release.
        
 Index 

          Book-style text index of Boost.Asio documentation.
        








\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio.html
Macro BOOST_PFR_USE_CPP17\3



Macro BOOST_PFR_USE_CPP17











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_USE_CPP17
BOOST_PFR_USE_CPP17 — in Visual Studio 2017 v15.9 PFR library with classic engine normally works 

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_USE_CPP17

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_USE_CPP17.html
Concept ObjectTransform\3



Concept ObjectTransform











Home
Libraries
People
FAQ
More








Concept ObjectTransform
ObjectTransform


Description

      An ObjectTransform is a function type or a function
      pointer type where the return type Obj is a
      an object type and the arguments are
      Transforms. is_callable&lt; Obj &gt;::value
      must be false. The ObjectTransform, when applied,
      has the effect of constructing an object of type
      Obj' (see below), passing as construction parameters
      the result(s) of applying transform(s) Tn.
    

      The type Obj may be a template specialization representing
      a compile-time lambda expression. For instance, if Obj is
      std::pair&lt; proto::_value, int &gt;, the result type of the
      ObjectTransform is computed by replacing the type proto::_value
      with the result of applying the proto::_value transform. For
      given types Obj, Expr, State and Data, we can say that the
      type Obj' represents the type Obj after all nested transforms
      have been replaced with the results of applying the transforms
      with Expr, State and Data as transform arguments.
    

      If the type Obj is not a template specialization representing
      a compile-time lambda expression, then the result type Obj' is
      the same as Obj.
    


Notation

Obj
A type playing the role of object-type in the ObjectTransform concept.
Tn
A type playing the role of transform-type in the ObjectTransform concept.
Expr
A type playing the role of expression-type in the ObjectTransform concept.
State
A type playing the role of state-type in the ObjectTransform concept.
Data
A type playing the role of data-type in the ObjectTransform concept.
expr
Object of type Expr
state
Object of type State
data
Object of type Data



Valid expressions








Name
Expression
Type
Semantics


Apply Transform
when&lt; _, Obj(Tn...)&gt;()(expr, state, data)
Obj'
Applies the transform.




Models
std::pair&lt; boost::proto::_value, int &gt;(boost::proto::_value, int())


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/ObjectTransform.html
Macro BOOST_INTRUSIVE_OPTION_TYPE\3



Macro BOOST_INTRUSIVE_OPTION_TYPE











Home
Libraries
People
FAQ
More








Macro BOOST_INTRUSIVE_OPTION_TYPE
BOOST_INTRUSIVE_OPTION_TYPE

Synopsis
// In header: &lt;boost/intrusive/pack_options.hpp&gt;

BOOST_INTRUSIVE_OPTION_TYPE(OPTION_NAME, TYPE, TYPEDEF_EXPR, TYPEDEF_NAME)

Description
Defines an option class of name OPTION_NAME that can be used to specify a type of type TYPE...
struct OPTION_NAME&lt;class TYPE&gt;
{  unspecified_content  };

...that after being combined with boost::intrusive::pack_options, will typedef TYPE as a typedef of name TYPEDEF_NAME. Example:
//[includes and namespaces omitted for brevity]

//This macro will create the following class:
//    template&lt;class VoidPointer&gt;
//    struct my_pointer
//    { unspecified_content };
BOOST_INTRUSIVE_OPTION_TYPE(my_pointer, VoidPointer, boost::remove_pointer&lt;VoidPointer&gt;::type, my_pointer_type)

struct empty_default{};

typedef pack_options&lt; empty_default, typename my_pointer&lt;void*&gt; &gt;::type::my_pointer_type type;

BOOST_STATIC_ASSERT(( boost::is_same&lt;type, void&gt;::value ));

 


Copyright © 2005 Olaf KrzikallaCopyright © 2006-2015 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_INTRUSIVE_O_idm34861.html
Chapter 34. Boost.Signals2\3



Chapter 34. Boost.Signals2











Home
Libraries
People
FAQ
More








Chapter 34. Boost.Signals2

Douglas Gregor


Frank Mori Hess

Copyright © 2001-2004 Douglas Gregor
Copyright © 2007-2009 Frank Mori Hess

Distributed under the Boost
    Software License, Version 1.0. (See accompanying file
    LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)



Table of Contents

Introduction
Signals2
Tutorial

How to Read this Tutorial
Hello, World! (Beginner)
Calling Multiple Slots
Passing Values to and from Slots
Connection Management
Example: Document-View
Giving a Slot Access to its Connection (Advanced)
Changing the Mutex Type of a Signal (Advanced).
Linking against the Signals2 library

Example programs

Miscellaneous Tutorial Examples
Document-View
Postconstructors and Predestructors with deconstruct()

Reference

Header &lt;boost/signals2.hpp&gt;
Header &lt;boost/signals2/connection.hpp&gt;
Header &lt;boost/signals2/deconstruct.hpp&gt;
Header &lt;boost/signals2/dummy_mutex.hpp&gt;
Header &lt;boost/signals2/last_value.hpp&gt;
Header &lt;boost/signals2/mutex.hpp&gt;
Header &lt;boost/signals2/optional_last_value.hpp&gt;
Header &lt;boost/signals2/shared_connection_block.hpp&gt;
Header &lt;boost/signals2/signal.hpp&gt;
Header &lt;boost/signals2/signal_base.hpp&gt;
Header &lt;boost/signals2/signal_type.hpp&gt;
Header &lt;boost/signals2/slot.hpp&gt;
Header &lt;boost/signals2/slot_base.hpp&gt;
Header &lt;boost/signals2/trackable.hpp&gt;

Thread-Safety

Introduction
Signals and combiners
Connections and other classes

Frequently Asked Questions
Design Rationale

User-level Connection Management
Automatic Connection Management
optional_last_value as the Default Combiner
Combiner Interface
Connection Interfaces: +=  operator
Signals2 Mutex Classes
Comparison with other Signal/Slot implementations

Signals2 API Changes

Porting from Boost.Signals to Boost.Signals2
Signals2 API Development

Testsuite
Acceptance tests




Introduction
Signals2
The Boost.Signals2 library is an implementation of a managed
  signals and slots system. Signals represent callbacks with multiple
  targets, and are also called publishers or events in similar
  systems. Signals are connected to some set of slots, which are
  callback receivers (also called event targets or subscribers), which
  are called when the signal is "emitted."
Signals and slots are managed, in that signals and slots (or,
  more properly, objects that occur as part of the slots) can track
  connections and are capable of automatically disconnecting signal/slot
  connections when either is destroyed. This enables the user to make
  signal/slot connections without expending a great effort to manage the
  lifetimes of those connections with regard to the lifetimes of all
  objects involved.
When signals are connected to multiple slots, there is a
  question regarding the relationship between the return values of the
  slots and the return value of the signals. Boost.Signals2 allows the
  user to specify the manner in which multiple return values are
  combined.


Signals2
This documentation describes a thread-safe variant of the
    original Boost.Signals library.  There have been some changes to
    the interface to support thread-safety, mostly with respect to
    automatic connection management.  This implementation was written by
    Frank Mori Hess.  Acknowledgements are also due to Timmo Stange, Peter
    Dimov, and Tony Van Eerd for ideas and feedback, and to Douglas Gregor
    for the original version of Boost.Signals this effort was based on.
    










\3https://www.boost.org/doc/libs/1_84_0/doc/html/signals2.html
Macro BOOST_VARIANT_DO_NOT_SPECIALIZE_STD_HASH\3



Macro BOOST_VARIANT_DO_NOT_SPECIALIZE_STD_HASH











Home
Libraries
People
FAQ
More








Macro BOOST_VARIANT_DO_NOT_SPECIALIZE_STD_HASH
BOOST_VARIANT_DO_NOT_SPECIALIZE_STD_HASH — Define this macro if you do not wish to have a std::hash specialization for
      boost::variant.

Synopsis
// In header: &lt;boost/variant/variant_fwd.hpp&gt;

BOOST_VARIANT_DO_NOT_SPECIALIZE_STD_HASH

Copyright © 2002, 2003 Eric Friedman, Itay MamanCopyright © 2014-2023 Antony PolukhinDistributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at 
    http://www.boost.org/LICENSE_1_0.txt)
    







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_VARIANT_1_3_44_5_3_6.html
Chapter 42. Boost.Units 1.1.0\3



Chapter 42. Boost.Units 1.1.0











Home
Libraries
People
FAQ
More








Chapter 42. Boost.Units 1.1.0

Matthias C. Schabel


Steven Watanabe

Copyright © 2003-2008 Matthias Christian Schabel
Copyright © 2007-2010 Steven
      Watanabe


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Quick Start
Dimensional Analysis
Units

Base Units
Scaled Base Units
Scaled Units

Quantities

Heterogeneous
      Operators
Conversions
Construction
      and Conversion of Quantities

Examples

Dimension Example
Unit Example
Quantity Example
Kitchen Sink
      Example using SI units
Conversion Example
User Defined Types
Complex Example
Performance
      Example
Radar Beam
      Height
Heterogeneous
      Unit Example
Absolute
      and Relative Temperature Example
Runtime
      Conversion Factor Example
Units
      with Non-base Dimensions
Output
      for Composite Units
Automatically Scaled
      Units
Conversion Factor
Runtime Units
Interoperability with Boost.Lambda

Utilities

Metaprogramming
      Classes
Metaprogramming
      Predicates

Reference

Units Reference
Dimensions Reference
SI System Reference
CGS System Reference
Trigonometry and Angle System Reference
Temperature System Reference
Information System Reference
Abstract System Reference
Base Units
      by Category
Alphabetical
      Listing of Base Units

Installation
FAQ

How
      does one distinguish between quantities that are physically different but have
      the same units (such as energy and torque)?
Angles are treated as
      units
Why are there
      homogeneous systems? Aren't heterogeneous systems sufficient?
Why can't
      I construct a quantity directly from the value type?
Why are conversions
      explicit by default?

Acknowledgements
Help Wanted
Version Info
Release Notes
TODO




Introduction


      The Boost.Units library is a C++ implementation of dimensional analysis in
      a general and extensible manner, treating it as a generic compile-time metaprogramming
      problem. With appropriate compiler optimization, no runtime execution cost
      is introduced, facilitating the use of this library to provide dimension checking
      in performance-critical code. Support for units and quantities (defined as
      a unit and associated value) for arbitrary unit system models and arbitrary
      value types is provided, as is a fine-grained general facility for unit conversions.
      Complete SI and CGS unit systems are provided, along with systems for angles
      measured in degrees, radians, gradians, and revolutions and systems for temperatures
      measured in Kelvin, degrees Celsius and degrees Fahrenheit. The library architecture
      has been designed with flexibility and extensibility in mind; demonstrations
      of the ease of adding new units and unit conversions are provided in the examples.
    

      In order to enable complex compile-time dimensional analysis calculations with
      no runtime overhead, Boost.Units relies heavily on the Boost Metaprogramming Library
      (MPL) and on template metaprogramming techniques, and is, as a consequence,
      fairly demanding of compiler compliance to ISO standards. At present, it has
      been successfully compiled and tested on the following compilers/platforms
      :
    


          g++ 4.0.1 on Mac OSX 10.4
        

          Intel CC 9.1, 10.0, and 10.1 on Mac OSX 10.4
        

          g++ 3.4.4, 4.2.3, and 4.3.0 on Windows XP
        

          Microsoft Visual C++ 7.1, 8.0, and 9.0 on Windows XP
        

          Comeau 4.3.10.1 beta2 on Windows XP
        

          Metrowerks CodeWarrior 9.2 on Windows XP.
        

          Sun CC 5.9 on Solaris and Linux
        


      The following compilers/platforms are known not
      to work :
    


          g++ 3.3.x
        

          Microsoft Visual C++ 6.0 on Windows XP
        

          Microsoft Visual C++ 7.0 on Windows XP
        

          Metrowerks CodeWarrior 8.0 on Windows XP.
        

          All versions of Borland.
        










\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_units.html
Macro BOOST_PROGRAM_OPTIONS_DECL\3



Macro BOOST_PROGRAM_OPTIONS_DECL











Home
Libraries
People
FAQ
More








Macro BOOST_PROGRAM_OPTIONS_DECL
BOOST_PROGRAM_OPTIONS_DECL

Synopsis
// In header: &lt;boost/program_options/config.hpp&gt;

BOOST_PROGRAM_OPTIONS_DECL

Copyright © 2002-2004 Vladimir PrusDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROGRAM_OPTIONS_DECL.html
Chapter 19. Boost.Lexical_Cast 1.0\3



Chapter 19. Boost.Lexical_Cast 1.0











Home
Libraries
People
FAQ
More








Chapter 19. Boost.Lexical_Cast 1.0
Copyright © 2000-2005 Kevlin Henney
Copyright © 2006-2010 Alexander Nasonov
Copyright © 2011-2023 Antony Polukhin


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Motivation
Examples

Strings
      to numbers conversion
Numbers
      to strings conversion
Converting
      to string without dynamic memory allocation
Converting
      part of the string
Generic
      programming (Boost.Fusion)
Generic
      programming (Boost.Variant)

Synopsis

lexical_cast
bad_lexical_cast
try_lexical_convert

Frequently
    Asked Questions
Changes
Performance

Tests
      description
GNU
      C++ version 6.1.1 20160511
GNU
      C++ version 4.8.5
Clang
      version 3.6.0 (tags/RELEASE_360/final)





Motivation


      Sometimes a value must be converted to a literal text form, such as an int represented as a std::string,
      or vice-versa, when a std::string is interpreted as an int. Such examples are common when converting
      between data types internal to a program and representation external to a program,
      such as windows and configuration files.
    

      The standard C and C++ libraries offer a number of facilities for performing
      such conversions. However, they vary with their ease of use, extensibility,
      and safety.
    

      For instance, there are a number of limitations with the family of standard
      C functions typified by atoi:
    


          Conversion is supported in one direction only: from text to internal data
          type. Converting the other way using the C library requires either the
          inconvenience and compromised safety of the sprintf
          function, or the loss of portability associated with non-standard functions
          such as itoa.
        

          The range of types supported is only a subset of the built-in numeric types,
          namely int, long, and double.
        

          The range of types cannot be extended in a uniform manner. For instance,
          conversion from string representation to complex or rational.
        


      The standard C functions typified by strtol
      have the same basic limitations, but offer finer control over the conversion
      process. However, for the common case such control is often either not required
      or not used. The scanf family
      of functions offer even greater control, but also lack safety and ease of use.
    

      The standard C++ library offers stringstream
      for the kind of in-core formatting being discussed. It offers a great deal
      of control over the formatting and conversion of I/O to and from arbitrary
      types through text. However, for simple conversions direct use of stringstream can be either clumsy (with the
      introduction of extra local variables and the loss of infix-expression convenience)
      or obscure (where stringstream
      objects are created as temporary objects in an expression). Facets provide
      a comprehensive concept and facility for controlling textual representation,
      but their perceived complexity and high entry level requires an extreme degree
      of involvement for simple conversions, and excludes all but a few programmers.
    

      The lexical_cast function template
      offers a convenient and consistent form for supporting common conversions to
      and from arbitrary types when they are represented as text. The simplification
      it offers is in expression-level convenience for such conversions. For more
      involved conversions, such as where precision or formatting need tighter control
      than is offered by the default behavior of lexical_cast,
      the conventional std::stringstream approach is recommended. Where
      the conversions are numeric to numeric, boost::numeric_cast
      may offer more reasonable behavior than lexical_cast.
    

      For a good discussion of the options and issues involved in string-based formatting,
      including comparison of stringstream,
      lexical_cast, and others, see
      Herb Sutter's article, The
      String Formatters of Manor Farm. Also, take a look at the Performance
      section.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_lexical_cast.html
Macro BOOST_TYPE_ERASURE_FREE\3



Macro BOOST_TYPE_ERASURE_FREE











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_ERASURE_FREE
BOOST_TYPE_ERASURE_FREE — Defines a primitive concept for a free function. 

Synopsis
// In header: &lt;boost/type_erasure/free.hpp&gt;

BOOST_TYPE_ERASURE_FREE(concept_name, function_name)

Description

The declaration of the concept is 
template&lt;class Sig&gt;
struct concept_name;

 where Sig is a function type giving the signature of the function.
This macro can only be used at namespace scope.
Example:
BOOST_TYPE_ERASURE_FREE(to_string)
typedef has_to_string&lt;std::string(_self const&amp;)&gt; to_string_concept;

In C++03, the macro can only be used in the global namespace and is defined as:
#define BOOST_TYPE_ERASURE_FREE(qualified_name, function_name, N)

Example:
BOOST_TYPE_ERASURE_FREE((boost)(has_to_string), to_string, 1)

For backwards compatibility, this form is always accepted. 






Parameters:







concept_name
is the name of the concept to declare. If it is omitted it defaults to has_ ## function_name 


function_name
is the name of the function.







Copyright © 2011-2013 Steven Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_ERASURE_FREE.html
Redirect to generated documentation\3

  
  

      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt) --
    Redirect to generated documentation
    
  
  
    Automatic redirection failed, please go to
    http://www.boost.org/doc/libs/master/doc/html/unordered.html
  

\3https://www.boost.org/doc/libs/1_84_0/doc/html/unordered.html
Concept PrimitiveTransform\3



Concept PrimitiveTransform











Home
Libraries
People
FAQ
More








Concept PrimitiveTransform
PrimitiveTransform


Description

      A PrimitiveTransform is a class type that
      has a nested class template called
      impl&lt;&gt; that takes
      three template parameters representing an expression
      type, a state type and a data type. Specializations
      of the nested impl template are ternary monomorphic
      function objects that accept expression, state, and
      data parameters. A PrimitiveTransform is also a
      PolymorphicFunctionObject
      implemented in terms of the nested
      impl&lt;&gt; template.
    


Associated types

result_type
typename Fn::template impl&lt;Expr, State, Data&gt;::result_type

      
The return type of the overloaded function call operator.

    



Notation

Fn
A type playing the role of primitive-transform-type in the PrimitiveTransform concept.
Expr
A type playing the role of expression-type in the PrimitiveTransform concept.
State
A type playing the role of state-type in the PrimitiveTransform concept.
Data
A type playing the role of data-type in the PrimitiveTransform concept.
fn
Object of type Fn
expr
Object of type Expr
state
Object of type State
data
Object of type Data



Valid expressions








Name
Expression
Type
Semantics



Polymorphic Function Call 1
fn(expr)
result_type
Applies the transform.


Polymorphic Function Call 2
fn(expr, state)
result_type
Applies the transform.


Polymorphic Function Call 3
fn(expr, state, data)
result_type
Applies the transform.


Monomorphic Function Call
typename Fn::template impl&lt; Expr, State, Data &gt;()(expr, state, data)
result_type
Applies the transform.





Models
boost::proto::_child_c&lt; 0 &gt;


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/PrimitiveTransform.html
Macro BOOST_XPR_ENSURE_\3



Macro BOOST_XPR_ENSURE_











Home
Libraries
People
FAQ
More








Macro BOOST_XPR_ENSURE_
BOOST_XPR_ENSURE_

Synopsis
// In header: &lt;boost/xpressive/regex_error.hpp&gt;

BOOST_XPR_ENSURE_(pred, code, msg)

Copyright © 2007 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_XPR_ENSURE_.html
Macro MPICH_IGNORE_CXX_SEEK\3



Macro MPICH_IGNORE_CXX_SEEK











Home
Libraries
People
FAQ
More








Macro MPICH_IGNORE_CXX_SEEK
MPICH_IGNORE_CXX_SEEK

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

MPICH_IGNORE_CXX_SEEK

Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/MPICH_IGNORE_CXX_SEEK.html
Macro BOOST_PROTO_BASIC_EXTENDS\3



Macro BOOST_PROTO_BASIC_EXTENDS











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_BASIC_EXTENDS
BOOST_PROTO_BASIC_EXTENDS — For creating expression wrappers that add members to a Proto expression template, like
      proto::extends&lt;&gt;,
      but while retaining POD-ness of the expression wrapper.

Synopsis
// In header: &lt;boost/proto/extends.hpp&gt;

BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, Domain)

Description

        BOOST_PROTO_BASIC_EXTENDS() adds the basic typedefs, member functions, and
        data members necessary to make a struct a valid Proto expression extension. It does not
        add any constructors, virtual functions or access control blocks that would render the containing
        struct non-POD.
      

        Expr is the Proto expression that the enclosing struct extends.
        Derived is the type of the enclosing struct.
        Domain is the Proto domain to which this expression extension belongs.
        (See proto::domain&lt;&gt;.)
        Can be preceeded with "typename" if the specified domain is a dependent type.
      
BOOST_PROTO_BASIC_EXTENDS() adds to its enclosing struct
        exactly one data member of type Expr. 
      
If the Domain parameter is dependent, you can specify it as
        typename Domain, as in
        BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, typename Domain)
      

        Example:
template&lt; class Expr &gt;
struct my_expr;

struct my_domain
  : proto::domain&lt; proto::pod_generator&lt; my_expr &gt; &gt;
{};

template&lt; class Expr &gt;
struct my_expr
{
    // OK, this makes my_expr&lt;&gt; a valid Proto expression extension.
    // my_expr&lt;&gt; does /not/ have overloaded assignment, subscript,
    // and function call operators that build expression templates, however.
    BOOST_PROTO_BASIC_EXTENDS(Expr, my_expr, my_domain)
};

// OK, my_expr&lt;&gt; is POD, so this is statically initialized:
my_expr&lt; proto::terminal&lt;int&gt;::type &gt; const _1 = {{1}};

      

        See also:
        

BOOST_PROTO_EXTENDS_ASSIGN()
BOOST_PROTO_EXTENDS_SUBSCRIPT()
BOOST_PROTO_EXTENDS_FUNCTION()
BOOST_PROTO_EXTENDS()


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_BASIC_EXTENDS.html
Macro BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE\3



Macro BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE
BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_USE_STD__idm2550.html
Macro BOOST_PROTO_REPEAT\3



Macro BOOST_PROTO_REPEAT











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_REPEAT
BOOST_PROTO_REPEAT — Repeatedly invoke the specified macro.

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_REPEAT(MACRO)

Description

        BOOST_PROTO_REPEAT() is used to generate the kind of repetitive
        code that is typical of EDSLs built with Proto.
        BOOST_PROTO_REPEAT(MACRO)
        is equivalent to:
      

        
MACRO(1, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)
MACRO(2, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)
...
MACRO(BOOST_PROTO_MAX_ARITY, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)

      

        Example:
      

        See BOOST_PROTO_REPEAT_FROM_TO().
      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_REPEAT.html
Macro BOOST_RV_REF_BEG\3



Macro BOOST_RV_REF_BEG











Home
Libraries
People
FAQ
More








Macro BOOST_RV_REF_BEG
BOOST_RV_REF_BEG

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_RV_REF_BEG

Description
This macro is used to achieve portable syntax in move constructors and assignments for template classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE. As macros have problems with comma-separated template arguments, the template argument must be preceded with BOOST_RV_REF_BEG and ended with BOOST_RV_REF_END 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_RV_REF_BEG.html
Macro BOOST_YAP_USER_UDT_UDT_BINARY_OPERATOR\3



Macro BOOST_YAP_USER_UDT_UDT_BINARY_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_UDT_UDT_BINARY_OPERATOR
BOOST_YAP_USER_UDT_UDT_BINARY_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_UDT_UDT_BINARY_OPERATOR(op_name, expr_template, t_udt_trait, u_udt_trait)

Description
Defines a free/non-member operator overload for binary operator op_name that produces an expression instantiated from the expr_template expression template.
The lhs parameter to the defined operator overload may be any type that is not an expression and for which 
t_udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value 

 is true. The parameter is wrapped in a terminal expression.
The rhs parameter to the defined operator overload may be any type that is not an expression and for which 
u_udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;U&gt;&gt;&gt;::value 

 is true. The parameter is wrapped in a terminal expression.
Example: 









Parameters:







expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate.


op_name
The operator to be overloaded; this must be one of the binary enumerators in expr_kind, without the expr_kind:: qualification.


t_udt_trait
A trait template to use to constrain which types are accepted as T template parameters to the defined operator overload.


u_udt_trait
A trait template to use to constrain which types are accepted as U template parameters to the defined operator overload. 







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP__1_3_46_8_2_7_10.html
Macro BOOST_PROTO_EXTENDS\3



Macro BOOST_PROTO_EXTENDS











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_EXTENDS
BOOST_PROTO_EXTENDS — For creating expression wrappers that add behaviors to a Proto expression template, like
      proto::extends&lt;&gt;,
      but while retaining POD-ness of the expression wrapper.

Synopsis
// In header: &lt;boost/proto/extends.hpp&gt;

BOOST_PROTO_EXTENDS(Expr, Derived, Domain)

Description

        Equivalent to:
        
BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, Domain)
BOOST_PROTO_EXTENDS_ASSIGN()
BOOST_PROTO_EXTENDS_SUBSCRIPT()
BOOST_PROTO_EXTENDS_FUNCTION()

      
If the Domain parameter is dependent, you can specify it as
        typename Domain, as in
        BOOST_PROTO_EXTENDS(Expr, Derived, typename Domain)
      

        Example:
template&lt; class Expr &gt;
struct my_expr;

struct my_domain
  : proto::domain&lt; proto::pod_generator&lt; my_expr &gt; &gt;
{};

template&lt; class Expr &gt;
struct my_expr
{
    // OK, this makes my_expr&lt;&gt; a valid Proto expression extension.
    // my_expr&lt;&gt; has overloaded assignment, subscript,
    // and function call operators that build expression templates.
    BOOST_PROTO_EXTENDS(Expr, my_expr, my_domain)
};

// OK, my_expr&lt;&gt; is POD, so this is statically initialized:
my_expr&lt; proto::terminal&lt;int&gt;::type &gt; const _1 = {{1}};

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_EXTENDS.html
Macro BOOST_PROTO_ref_a\3



Macro BOOST_PROTO_ref_a











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_ref_a
BOOST_PROTO_ref_a — 
      Generates sequences like 
      
        boost::ref(a0),
        boost::ref(a1), …
        boost::ref(aN-1)
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_ref_a(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_ref_a(N) generates sequences like:
      

        
boost::ref(a0), boost::ref(a1), … boost::ref(aN-1)

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_ref_a.html
Chapter 43. Boost.Variant\3



Chapter 43. Boost.Variant











Home
Libraries
People
FAQ
More








Chapter 43. Boost.Variant

Eric Friedman


Itay Maman

Copyright © 2002, 2003 Eric Friedman, Itay Maman
Copyright © 2014-2023 Antony Polukhin

Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at 
    http://www.boost.org/LICENSE_1_0.txt)
    



Table of Contents

Introduction

Abstract
Motivation

Tutorial

Basic Usage
Advanced Topics

Reference

Concepts
Header &lt;boost/variant.hpp&gt;
Header &lt;boost/variant/variant_fwd.hpp&gt;
Header &lt;boost/variant/variant.hpp&gt;
Header &lt;boost/variant/recursive_variant.hpp&gt;
Header &lt;boost/variant/recursive_wrapper.hpp&gt;
Header &lt;boost/variant/apply_visitor.hpp&gt;
Header &lt;boost/variant/multivisitors.hpp&gt;
Header &lt;boost/variant/get.hpp&gt;
Header &lt;boost/variant/polymorphic_get.hpp&gt;
Header &lt;boost/variant/bad_visit.hpp&gt;
Header &lt;boost/variant/static_visitor.hpp&gt;
Header &lt;boost/variant/visitor_ptr.hpp&gt;

Design Overview
"Never-Empty" Guarantee
Miscellaneous Notes

Boost.Variant vs. Boost.Any
Portability
Troubleshooting
Acknowledgments

References




Introduction

Abstract
Motivation



Abstract
The variant class template is a safe, generic, stack-based
discriminated union container, offering a simple solution for manipulating an
object from a heterogeneous set of types in a uniform manner. Whereas
standard containers such as std::vector may be thought of as
"multi-value, single type,"
variant is "multi-type,
single value."
Notable features of boost::variant
include:

Full value semantics, including adherence to standard
    overload resolution rules for conversion operations.
Compile-time type-safe value visitation via
    boost::apply_visitor.
Run-time checked explicit value retrieval via
    boost::get.
Support for recursive variant types via both
    boost::make_recursive_variant and
    boost::recursive_wrapper.
Efficient implementation -- stack-based when possible (see
    the section called “"Never-Empty" Guarantee” for more details).




Motivation

Problem
Solution: A Motivating Example



Problem
Many times, during the development of a C++ program, the
programmer finds himself in need of manipulating several distinct
types in a uniform manner. Indeed, C++ features direct language
support for such types through its union 
keyword:
union { int i; double d; } u;
u.d = 3.14;
u.i = 3; // overwrites u.d (OK: u.d is a POD type)
C++'s union construct, however, is nearly
useless in an object-oriented environment. The construct entered
the language primarily as a means for preserving compatibility with
C, which supports only POD (Plain Old Data) types, and so does not
accept types exhibiting non-trivial construction or
destruction:
union {
  int i;
  std::string s; // illegal: std::string is not a POD type!
} u;
Clearly another approach is required. Typical solutions
feature the dynamic-allocation of objects, which are subsequently
manipulated through a common base type (often a virtual base class
    [Hen01]
or, more dangerously, a void*). Objects of
concrete type may be then retrieved by way of a polymorphic downcast
construct (e.g., dynamic_cast,
boost::any_cast, etc.).
However, solutions of this sort are highly error-prone, due
to the following:


Downcast errors cannot be detected at
    compile-time. Thus, incorrect usage of downcast
    constructs will lead to bugs detectable only at run-time.

Addition of new concrete types may be 
    ignored. If a new concrete type is added to the
    hierarchy, existing downcast code will continue to work as-is,
    wholly ignoring the new type. Consequently, the programmer must
    manually locate and modify code at numerous locations, which often
    results in run-time errors that are difficult to find.

Furthermore, even when properly implemented, these solutions tend
to incur a relatively significant abstraction penalty due to the use of
the heap, virtual function calls, and polymorphic downcasts.



Solution: A Motivating Example
The boost::variant class template
addresses these issues in a safe, straightforward, and efficient manner. The
following example demonstrates how the class can be used:
#include "boost/variant.hpp"
#include &lt;iostream&gt;

class my_visitor : public boost::static_visitor&lt;int&gt;
{
public:
    int operator()(int i) const
    {
        return i;
    }
    
    int operator()(const std::string &amp; str) const
    {
        return str.length();
    }
};

int main()
{
    boost::variant&lt; int, std::string &gt; u("hello world");
    std::cout &lt;&lt; u; // output: hello world

    int result = boost::apply_visitor( my_visitor(), u );
    std::cout &lt;&lt; result; // output: 11 (i.e., length of "hello world")
}












\3https://www.boost.org/doc/libs/1_84_0/doc/html/variant.html
Chapter 41. Boost.Typeof\3



Chapter 41. Boost.Typeof











Home
Libraries
People
FAQ
More








Chapter 41. Boost.Typeof

Arkadiy Vertleyb


Peder Holt

Copyright © 2004, 2005 Arkadiy Vertleyb, Peder Holt


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at 
        http://www.boost.org/LICENSE_1_0.txt )
      



Table of Contents

Motivation
Tutorial
Reference

AUTO, AUTO_TPL
COMPLIANT
INCREMENT_REGISTRATION_GROUP
INTEGRAL
LIMIT_FUNCTION_ARITY
MESSAGES
LIMIT_SIZE
REGISTER_TYPE
REGISTER_TEMPLATE
TEMPLATE
TYPEOF, TYPEOF_TPL
TYPEOF_NESTED_TYPEDEF, TYPEOF_NESTED_TYPEDEF_TPL

Other considerations and tips

Native typeof support and emulation
The three participating parties
Supported features
What needs to be registered?
Limitations

Contributed By:
Acknowledgements




Motivation

      Today many template libraries supply object generators to simplify object creation
      by utilizing the C++ template argument deduction facility. Consider std::pair.
      In order to instantiate this class template and create a temporary object of
      this instantiation, one has to supply template parameters, as well as parameters
      to the constructor:
    
std::pair&lt;int, double&gt;(5, 3.14159);


      To avoid this duplication, STL supplies the std::make_pair
      object generator. When it is used, the types of template parameters are deduced
      from supplied function arguments:
    
std::make_pair(5, 3.14159);


      For the temporary objects it is enough. However, when a named object needs
      to be allocated, the problem appears again:
    
std::pair&lt;int, double&gt; p(5, 3.14159);


      The object generator no longer helps:
    
std::pair&lt;int, double&gt; p = std::make_pair(5, 3.14159);


      It would be nice to deduce the type of the object (on the left) from the expression
      it is initialized with (on the right), but the current C++ syntax does not
      allow for this.
    

      The above example demonstrates the essence of the problem but does not demonstrate
      its scale. Many libraries, especially expression template libraries, create
      objects of really complex types, and go a long way to hide this complexity
      behind object generators. Consider a nit Boost.Lambda functor:
    
_1 &gt; 15 &amp;&amp; _2 &lt; 20


      If one wanted to allocate a named copy of such an innocently looking functor,
      she would have to specify something like this:
    
lambda_functor&lt;
    lambda_functor_base&lt;
        logical_action&lt;and_action&gt;,
        tuple&lt;
            lambda_functor&lt;
                lambda_functor_base&lt;
                    relational_action&lt;greater_action&gt;,
                    tuple&lt;
                        lambda_functor&lt;placeholder&lt;1&gt; &gt;,
                        int const
                    &gt;
                &gt;
            &gt;,
            lambda_functor&lt;
                lambda_functor_base&lt;
                    relational_action&lt;less_action&gt;,
                    tuple&lt;
                        lambda_functor&lt;placeholder&lt;2&gt; &gt;,
                        int const
                    &gt;
                &gt;
            &gt;
        &gt;
    &gt;
&gt;
f = _1 &gt; 15 &amp;&amp; _2 &lt; 20;


      Not exactly elegant. To solve this problem (as well as some other problems),
      the C++ standard committee is considering a few additions to the standard language,
      such as typeof/decltype and auto
      (see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1607.pdf).
    

      The typeof operator (or decltype, which is a slightly different flavor
      of typeof) allows one to determine
      the type of an expression at compile time. Using typeof,
      the above example can be simplified drastically:
    
typeof(_1 &gt; 15 &amp;&amp; _2 &lt; 20) f = _1 &gt; 15 &amp;&amp; _2 &lt; 20;


      Much better, but some duplication still exists. The auto
      type solves the rest of the problem:
    
auto f = _1 &gt; 15 &amp;&amp; _2 &lt; 20;


      The purpose of the Boost.Typeof library is to provide a library-based solution,
      which could be used until the language-based facility is added to the Standard
      and becomes widely available.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/typeof.html
Array Components\3



Array Components











Home
Libraries
People
FAQ
More







Array Components

multi_array
multi_array_ref
const_multi_array_ref


Boost.MultiArray defines an array class,
multi_array, and two adapter classes,
multi_array_ref and 
const_multi_array_ref. The three classes model 
MultiArray and so they share a lot of functionality.
multi_array_ref differs from
multi_array in that the
multi_array manages its own memory, while
multi_array_ref is passed a block of memory that it
expects to be externally managed.
const_multi_array_ref differs from
multi_array_ref in that the underlying elements it
adapts cannot be modified through its interface, though some array
properties, including the array shape and index bases, can be altered.
Functionality the classes have in common is described
below.

Note: Preconditions, Effects, and Implementation. 
Throughout the following sections, small pieces of C++ code are
used to specify constraints such as preconditions, effects, and
postconditions.  These do not necessarily describe the underlying
implementation of array components; rather, they describe the 
expected input to and
behavior of the specified operations.  Failure to meet
preconditions results in undefined behavior. Not all effects
(i.e. copy constructors, etc.) must be mimicked exactly.  The code
snippets for effects intend to capture the essence of the described
operation. 

Queries. 

element* data();
const element* data() const;
This returns a pointer to the beginning of the
contiguous block that contains the array's data. If all dimensions of
the array are 0-indexed and stored in ascending order, this is 
equivalent to origin(). Note that
const_multi_array_ref only provides the const
version of this function.

element* origin();
const element* origin() const;
This returns the origin element of the
multi_array. Note that
const_multi_array_ref only provides the const
version of this function. (Required by MultiArray)

const index* index_bases();
This returns the index bases for the
multi_array. (Required by MultiArray)

const index* strides();
This returns the strides for the
multi_array. (Required by MultiArray)

const size_type* shape();
This returns the shape of the
multi_array. (Required by MultiArray)


Comparators. 


bool operator==(const *array-type*&amp; rhs);
bool operator!=(const *array-type*&amp; rhs);
bool operator&lt;(const *array-type*&amp; rhs);
bool operator&gt;(const *array-type*&amp; rhs);
bool operator&gt;=(const *array-type*&amp; rhs);
bool operator&lt;=(const *array-type*&amp; rhs);

Each comparator executes a lexicographical compare over
the value types of the two arrays.
(Required by MultiArray)

Preconditions. element must support the
comparator corresponding to that called on
multi_array.
Complexity. O(num_elements()).


Modifiers. 




template &lt;typename SizeList&gt;
void reshape(const SizeList&amp; sizes)




This changes the shape of the multi_array.  The
number of elements and the index bases remain the same, but the number
of values at each level of the nested container hierarchy may
change.
SizeList Requirements. SizeList must model
Collection.
Preconditions. 


std::accumulate(sizes.begin(),sizes.end(),size_type(1),std::times&lt;size_type&gt;()) == this-&gt;num_elements();
sizes.size() == NumDims;

Postconditions. 
std::equal(sizes.begin(),sizes.end(),this-&gt;shape) == true;





template &lt;typename BaseList&gt;
void reindex(const BaseList&amp; values);




This changes the index bases of the multi_array to
correspond to the the values in values.
BaseList Requirements. BaseList must model
Collection.
Preconditions. values.size() == NumDims;
Postconditions. std::equal(values.begin(),values.end(),this-&gt;index_bases());





void reindex(index value);




This changes the index bases of all dimensions of the
multi_array to value.
Postconditions. 



std::count_if(this-&gt;index_bases(),this-&gt;index_bases()+this-&gt;num_dimensions(),
              std::bind_2nd(std::equal_to&lt;index&gt;(),value)) == 
              this-&gt;num_dimensions();








multi_array


multi_array is a multi-dimensional container that
supports random access iteration. Its number of dimensions is
fixed at compile time, but its shape and the number of elements it
contains are specified during its construction. The number of elements
will remain fixed for the duration of a
multi_array's lifetime, but the shape of the container can
be changed. A multi_array manages its data elements
using a replaceable allocator.

Model Of. 
MultiArray,
CopyConstructible. Depending on the element type, 
it may also model EqualityComparable and LessThanComparable. 

Synopsis. 


namespace boost {

template &lt;typename ValueType, 
          std::size_t NumDims, 
          typename Allocator = std::allocator&lt;ValueType&gt; &gt;
class multi_array {
public:
// types:
  typedef ValueType                             element;
  typedef *unspecified*                         value_type;
  typedef *unspecified*                         reference;
  typedef *unspecified*                         const_reference;
  typedef *unspecified*                         difference_type;
  typedef *unspecified*                         iterator;
  typedef *unspecified*                         const_iterator;
  typedef *unspecified*                         reverse_iterator;
  typedef *unspecified*                         const_reverse_iterator;
  typedef multi_array_types::size_type          size_type;
  typedef multi_array_types::index              index;
  typedef multi_array_types::index_gen          index_gen;
  typedef multi_array_types::index_range        index_range;
  typedef multi_array_types::extent_gen         extent_gen;
  typedef multi_array_types::extent_range       extent_range;
  typedef *unspecified*                         storage_order_type;


  // template typedefs
  template &lt;std::size_t Dims&gt; struct            subarray;
  template &lt;std::size_t Dims&gt; struct            const_subarray;
  template &lt;std::size_t Dims&gt; struct            array_view;
  template &lt;std::size_t Dims&gt; struct            const_array_view;
  

  static const std::size_t dimensionality = NumDims;
  

  // constructors and destructors

  multi_array(const Allocator&amp; alloc = Allocator());

  template &lt;typename ExtentList&gt;
  explicit multi_array(const ExtentList&amp; sizes,
                       const storage_order_type&amp; store = c_storage_order(),
                       const Allocator&amp; alloc = Allocator());
  explicit multi_array(const extents_tuple&amp; ranges,
                       const storage_order_type&amp; store = c_storage_order(),
	               const Allocator&amp; alloc = Allocator());
  multi_array(const multi_array&amp; x);
  multi_array(const const_multi_array_ref&lt;ValueType,NumDims&gt;&amp; x,
              const Allocator&amp; alloc = Allocator());
  multi_array(const const_subarray&lt;NumDims&gt;::type&amp; x,
              const Allocator&amp; alloc = Allocator());
  multi_array(const const_array_view&lt;NumDims&gt;::type&amp; x,
              const Allocator&amp; alloc = Allocator());

  multi_array(const multi_array_ref&lt;ValueType,NumDims&gt;&amp; x,
              const Allocator&amp; alloc = Allocator());
  multi_array(const subarray&lt;NumDims&gt;::type&amp; x,
              const Allocator&amp; alloc = Allocator());
  multi_array(const array_view&lt;NumDims&gt;::type&amp; x,
              const Allocator&amp; alloc = Allocator());

  ~multi_array();

  // modifiers

  multi_array&amp; operator=(const multi_array&amp; x);
  template &lt;class Array&gt; multi_array&amp; operator=(const Array&amp; x);

  // iterators:
  iterator				begin();
  iterator				end();
  const_iterator			begin() const;
  const_iterator			end() const;
  reverse_iterator			rbegin();
  reverse_iterator			rend();
  const_reverse_iterator		rbegin() const;
  const_reverse_iterator		rend() const;

  // capacity:
  size_type				size() const;
  size_type				num_elements() const;
  size_type				num_dimensions() const;
 
  // element access:
  template &lt;typename IndexList&gt; 
    element&amp;			operator()(const IndexList&amp; indices);
  template &lt;typename IndexList&gt;
    const element&amp;		operator()(const IndexList&amp; indices) const;
  reference			operator[](index i);
  const_reference		operator[](index i) const;
  array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r);
  const_array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r) const;

  // queries
  element*			data();
  const element*		data() const;
  element*			origin();
  const element*		origin() const;
  const size_type*		shape() const;
  const index*			strides() const;
  const index*			index_bases() const;
  const storage_order_type&amp;     storage_order() const;

  // comparators
  bool operator==(const multi_array&amp; rhs);
  bool operator!=(const multi_array&amp; rhs);
  bool operator&lt;(const multi_array&amp; rhs);
  bool operator&gt;(const multi_array&amp; rhs);
  bool operator&gt;=(const multi_array&amp; rhs);
  bool operator&lt;=(const multi_array&amp; rhs);

  // modifiers:
  template &lt;typename InputIterator&gt;
    void			assign(InputIterator begin, InputIterator end);
  template &lt;typename SizeList&gt;
    void			reshape(const SizeList&amp; sizes)
  template &lt;typename BaseList&gt;	void reindex(const BaseList&amp; values);
    void			reindex(index value);
  template &lt;typename ExtentList&gt;
    multi_array&amp;		resize(const ExtentList&amp; extents);
  multi_array&amp;                  resize(extents_tuple&amp; extents);
};


Constructors. 

template &lt;typename ExtentList&gt;
explicit multi_array(const ExtentList&amp; sizes,
                     const storage_order_type&amp; store = c_storage_order(),
                     const Allocator&amp; alloc = Allocator());



This constructs a multi_array using the specified
parameters.  sizes specifies the shape of the
constructed multi_array.  store
specifies the storage order or layout in memory of the array
dimensions.  alloc is used to
allocate the contained elements.

ExtentList Requirements. 
ExtentList must model Collection.

Preconditions. sizes.size() == NumDims;


explicit multi_array(extent_gen::gen_type&lt;NumDims&gt;::type ranges,
                     const storage_order_type&amp; store = c_storage_order(),
                     const Allocator&amp; alloc = Allocator());


This constructs a multi_array using the specified
    parameters.  ranges specifies the shape and
index bases of the constructed multi_array. It is the result of 
NumDims chained calls to 
    extent_gen::operator[]. store
specifies the storage order or layout in memory of the array
dimensions.  alloc is the allocator used to
allocate the memory used to store multi_array
elements.


multi_array(const multi_array&amp; x);
multi_array(const const_multi_array_ref&lt;ValueType,NumDims&gt;&amp; x,
    const Allocator&amp; alloc = Allocator());
multi_array(const const_subarray&lt;NumDims&gt;::type&amp; x,
    const Allocator&amp; alloc = Allocator());
multi_array(const const_array_view&lt;NumDims&gt;::type&amp; x,
    const Allocator&amp; alloc = Allocator());
multi_array(const multi_array_ref&lt;ValueType,NumDims&gt;&amp; x,
    const Allocator&amp; alloc = Allocator());
multi_array(const subarray&lt;NumDims&gt;::type&amp; x,
    const Allocator&amp; alloc = Allocator());
multi_array(const array_view&lt;NumDims&gt;::type&amp; x,
    const Allocator&amp; alloc = Allocator());


These constructors all constructs a multi_array and 
perform a deep copy of x. 

Complexity.  This performs O(x.num_elements()) calls to
element's copy 
constructor.



multi_array();

This constructs a multi_array whose shape is (0,...,0) and contains no elements.


Note on Constructors. 
The  multi_array construction expressions,


     multi_array&lt;int,3&gt; A(boost::extents[5][4][3]);


and


     boost::array&lt;multi_array_base::index,3&gt; my_extents = {{5, 4, 3}};
     multi_array&lt;int,3&gt; A(my_extents);


are equivalent.

Modifiers. 


multi_array&amp; operator=(const multi_array&amp; x);
template &lt;class Array&gt; multi_array&amp; operator=(const Array&amp; x);



This performs an element-wise copy of x
into the current multi_array.
Array Requirements. Array must model MultiArray. 

Preconditions. 

std::equal(this-&gt;shape(),this-&gt;shape()+this-&gt;num_dimensions(),
x.shape());
Postconditions. 

(*.this) == x;


Complexity. The assignment operators perform 
O(x.num_elements()) calls to element's 
copy constructor.




template &lt;typename InputIterator&gt;
void assign(InputIterator begin, InputIterator end);



This copies the elements in the range 
[begin,end) into the array.  It is equivalent to 
std::copy(begin,end,this-&gt;data()).

Preconditions. std::distance(begin,end) == this-&gt;num_elements();

Complexity. 
The assign member function performs
O(this-&gt;num_elements()) calls to
ValueType's copy constructor.



multi_array&amp; resize(extent_gen::gen_type&lt;NumDims&gt;::type extents);
template &lt;typename ExtentList&gt;
  multi_array&amp; resize(const ExtentList&amp; extents);



This function resizes an array to the shape specified by
extents, which is either a generated list of
extents or a model of the Collection concept. The
contents of the array are preserved whenever possible; if the new
array size is smaller, then some data will be lost. Any new elements
created by resizing the array are initialized with the
element default constructor.


Queries. 


storage_order_type&amp; storage_order() const;


This query returns the storage order object associated with the 
multi_array in question.  It can be used to construct a new array with the same storage order.




multi_array_ref


multi_array_ref is a multi-dimensional container
adaptor.  It provides the MultiArray interface over any contiguous
block of elements.  multi_array_ref exports the
same interface as multi_array, with the exception
of the constructors.

Model Of. 
multi_array_ref models 
MultiArray,
CopyConstructible.
and depending on the element type, it may also model
EqualityComparable and LessThanComparable. 
Detailed descriptions are provided here only for operations that are
not described in the multi_array reference.

Synopsis. 


namespace boost {

template &lt;typename ValueType, 
          std::size_t NumDims&gt;
class multi_array_ref {
public:
// types:
  typedef ValueType                             element;
  typedef *unspecified*                         value_type;
  typedef *unspecified*                         reference;
  typedef *unspecified*                         const_reference;
  typedef *unspecified*                         difference_type;
  typedef *unspecified*                         iterator;
  typedef *unspecified*                         const_iterator;
  typedef *unspecified*                         reverse_iterator;
  typedef *unspecified*                         const_reverse_iterator;
  typedef multi_array_types::size_type          size_type;
  typedef multi_array_types::index              index;
  typedef multi_array_types::index_gen          index_gen;
  typedef multi_array_types::index_range        index_range;
  typedef multi_array_types::extent_gen         extent_gen;
  typedef multi_array_types::extent_range       extent_range;
  typedef *unspecified*                         storage_order_type;
  
  // template typedefs
  template &lt;std::size_t Dims&gt; struct            subarray;
  template &lt;std::size_t Dims&gt; struct            const_subarray;
  template &lt;std::size_t Dims&gt; struct            array_view;
  template &lt;std::size_t Dims&gt; struct            const_array_view;
  

  static const std::size_t dimensionality = NumDims;


  // constructors and destructors

  template &lt;typename ExtentList&gt;
  explicit multi_array_ref(element* data, const ExtentList&amp; sizes,
                       const storage_order_type&amp; store = c_storage_order());
  explicit multi_array_ref(element* data, const extents_tuple&amp; ranges,
                       const storage_order_type&amp; store = c_storage_order());
  multi_array_ref(const multi_array_ref&amp; x);
  ~multi_array_ref();

  // modifiers

  multi_array_ref&amp; operator=(const multi_array_ref&amp; x);
  template &lt;class Array&gt; multi_array_ref&amp; operator=(const Array&amp; x);

  // iterators:
  iterator				begin();
  iterator				end();
  const_iterator			begin() const;
  const_iterator			end() const;
  reverse_iterator			rbegin();
  reverse_iterator			rend();
  const_reverse_iterator		rbegin() const;
  const_reverse_iterator		rend() const;

  // capacity:
  size_type				size() const;
  size_type				num_elements() const;
  size_type				num_dimensions() const;
 
  // element access:
  template &lt;typename IndexList&gt; 
    element&amp;			operator()(const IndexList&amp; indices);
  template &lt;typename IndexList&gt;
    const element&amp;		operator()(const IndexList&amp; indices) const;
  reference			operator[](index i);
  const_reference		operator[](index i) const;
  array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r);
  const_array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r) const;

  // queries
  element*			data();
  const element*		data() const;
  element*			origin();
  const element*		origin() const;
  const size_type*		shape() const;
  const index*			strides() const;
  const index*			index_bases() const;
  const storage_order_type&amp;     storage_order() const;

  // comparators
  bool operator==(const multi_array_ref&amp; rhs);
  bool operator!=(const multi_array_ref&amp; rhs);
  bool operator&lt;(const multi_array_ref&amp; rhs);
  bool operator&gt;(const multi_array_ref&amp; rhs);
  bool operator&gt;=(const multi_array_ref&amp; rhs);
  bool operator&lt;=(const multi_array_ref&amp; rhs);

  // modifiers:
  template &lt;typename InputIterator&gt;
    void			assign(InputIterator begin, InputIterator end);
  template &lt;typename SizeList&gt;
    void			reshape(const SizeList&amp; sizes)
  template &lt;typename BaseList&gt;	void reindex(const BaseList&amp; values);
  void				reindex(index value);
};


Constructors. 

template &lt;typename ExtentList&gt;
explicit multi_array_ref(element* data, 
                     const ExtentList&amp; sizes,
                     const storage_order&amp; store = c_storage_order(),
                     const Allocator&amp; alloc = Allocator());



This constructs a multi_array_ref using the specified
parameters.  sizes specifies the shape of the
constructed multi_array_ref.  store
specifies the storage order or layout in memory of the array
dimensions.  alloc is used to
allocate the contained elements.

ExtentList Requirements. 
ExtentList must model Collection.

Preconditions. sizes.size() == NumDims;


explicit multi_array_ref(element* data,
                     extent_gen::gen_type&lt;NumDims&gt;::type ranges,
                     const storage_order&amp; store = c_storage_order());


This constructs a multi_array_ref using the specified
    parameters.  ranges specifies the shape and
index bases of the constructed multi_array_ref. It is the result of 
NumDims chained calls to 
    extent_gen::operator[]. store
specifies the storage order or layout in memory of the array
dimensions. 


multi_array_ref(const multi_array_ref&amp; x);


This constructs a shallow copy of x.

Complexity.  Constant time (for contrast, compare this to
the multi_array class copy constructor.



Modifiers. 


multi_array_ref&amp; operator=(const multi_array_ref&amp; x);
template &lt;class Array&gt; multi_array_ref&amp; operator=(const Array&amp; x);



This performs an element-wise copy of x
into the current multi_array_ref.
Array Requirements. Array must model MultiArray. 

Preconditions. 

std::equal(this-&gt;shape(),this-&gt;shape()+this-&gt;num_dimensions(),
x.shape());
Postconditions. 

(*.this) == x;


Complexity. The assignment operators perform 
O(x.num_elements()) calls to element's 
copy constructor.





const_multi_array_ref


const_multi_array_ref is a multi-dimensional container
adaptor.  It provides the MultiArray interface over any contiguous
block of elements.  const_multi_array_ref exports the
same interface as multi_array, with the exception
of the constructors.

Model Of. 
const_multi_array_ref models
MultiArray,
CopyConstructible.
and depending on the element type, it may also model
EqualityComparable and LessThanComparable. 

Detailed descriptions are provided here only for operations that are
not described in the multi_array reference.

Synopsis. 


namespace boost {

template &lt;typename ValueType, 
          std::size_t NumDims, 
          typename TPtr = const T*&gt;
class const_multi_array_ref {
public:
// types:
  typedef ValueType                             element;
  typedef *unspecified*                         value_type;
  typedef *unspecified*                         reference;
  typedef *unspecified*                         const_reference;
  typedef *unspecified*                         difference_type;
  typedef *unspecified*                         iterator;
  typedef *unspecified*                         const_iterator;
  typedef *unspecified*                         reverse_iterator;
  typedef *unspecified*                         const_reverse_iterator;
  typedef multi_array_types::size_type          size_type;
  typedef multi_array_types::index              index;
  typedef multi_array_types::index_gen          index_gen;
  typedef multi_array_types::index_range        index_range;
  typedef multi_array_types::extent_gen         extent_gen;
  typedef multi_array_types::extent_range       extent_range;
  typedef *unspecified*                         storage_order_type;
  
  // template typedefs
  template &lt;std::size_t Dims&gt; struct            subarray;
  template &lt;std::size_t Dims&gt; struct            const_subarray;
  template &lt;std::size_t Dims&gt; struct            array_view;
  template &lt;std::size_t Dims&gt; struct            const_array_view;
  

  // structors

  template &lt;typename ExtentList&gt;
  explicit const_multi_array_ref(TPtr data, const ExtentList&amp; sizes,
                       const storage_order_type&amp; store = c_storage_order());
  explicit const_multi_array_ref(TPtr data, const extents_tuple&amp; ranges,
                       const storage_order_type&amp; store = c_storage_order());
  const_multi_array_ref(const const_multi_array_ref&amp; x);
  ~const_multi_array_ref();



  // iterators:
  const_iterator			begin() const;
  const_iterator			end() const;
  const_reverse_iterator		rbegin() const;
  const_reverse_iterator		rend() const;

  // capacity:
  size_type				size() const;
  size_type				num_elements() const;
  size_type				num_dimensions() const;
 
  // element access:
  template &lt;typename IndexList&gt;
    const element&amp;		operator()(const IndexList&amp; indices) const;
  const_reference		operator[](index i) const;
  const_array_view&lt;Dims&gt;::type	operator[](const indices_tuple&amp; r) const;

  // queries
  const element*		data() const;
  const element*		origin() const;
  const size_type*		shape() const;
  const index*			strides() const;
  const index*			index_bases() const;
  const storage_order_type&amp;     storage_order() const;

  // comparators
  bool operator==(const const_multi_array_ref&amp; rhs);
  bool operator!=(const const_multi_array_ref&amp; rhs);
  bool operator&lt;(const const_multi_array_ref&amp; rhs);
  bool operator&gt;(const const_multi_array_ref&amp; rhs);
  bool operator&gt;=(const const_multi_array_ref&amp; rhs);
  bool operator&lt;=(const const_multi_array_ref&amp; rhs);

  // modifiers:
  template &lt;typename SizeList&gt;
  void			reshape(const SizeList&amp; sizes)
  template &lt;typename BaseList&gt;	void reindex(const BaseList&amp; values);
  void				reindex(index value);
};


Constructors. 

template &lt;typename ExtentList&gt;
explicit const_multi_array_ref(TPtr data, 
                     const ExtentList&amp; sizes,
                     const storage_order&amp; store = c_storage_order());



This constructs a const_multi_array_ref using the specified
parameters.  sizes specifies the shape of the
constructed const_multi_array_ref.  store
specifies the storage order or layout in memory of the array
dimensions.

ExtentList Requirements. 
ExtentList must model Collection.

Preconditions. sizes.size() == NumDims;


explicit const_multi_array_ref(TPtr data,
                     extent_gen::gen_type&lt;NumDims&gt;::type ranges,
                     const storage_order&amp; store = c_storage_order());

Effects. 
This constructs a const_multi_array_ref using the specified
    parameters.  ranges specifies the shape and
index bases of the constructed const_multi_array_ref. It is the result of 
NumDims chained calls to 
    extent_gen::operator[]. store
specifies the storage order or layout in memory of the array
dimensions. 


const_multi_array_ref(const const_multi_array_ref&amp; x);

Effects. This constructs a shallow copy of x.




Copyright © 2002 The Trustees of Indiana University






\3https://www.boost.org/doc/libs/1_84_0/doc/html/array_types.html
Concept CallableTransform\3



Concept CallableTransform











Home
Libraries
People
FAQ
More








Concept CallableTransform
CallableTransform


Description

      A CallableTransform is a function type or a function
      pointer type where the return type Fn is a
      PolymorphicFunctionObject and the arguments are
      Transforms. is_callable&lt; Fn &gt;::value
      must be true. The CallableTransform, when applied,
      has the effect of invoking the polymorphic function
      object Fn, passing as arguments the result(s)
      of applying transform(s) Tn.
    


Associated types

result_type
boost::result_of&lt;Fn(Transform&lt;Tn, Expr, State, Data&gt;::result_type...)&gt;::type

      
The result of applying the CallableTransform.

    



Notation

Fn
A type playing the role of polymorphic-function-object-type in the CallableTransform concept.
Tn
A type playing the role of transform-type in the CallableTransform concept.
Expr
A type playing the role of expression-type in the CallableTransform concept.
State
A type playing the role of state-type in the CallableTransform concept.
Data
A type playing the role of data-type in the CallableTransform concept.
fn
Object of type Fn
expr
Object of type Expr
state
Object of type State
data
Object of type Data



Valid expressions








Name
Expression
Type
Semantics


Apply Transform
when&lt; _, Fn(Tn...)&gt;()(expr, state, data)
result_type
Applies the transform.




Models
boost::proto::_child(boost::proto::_left)


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/CallableTransform.html
Boost.TypeIndex Header Reference\3



Boost.TypeIndex Header Reference











Home
Libraries
People
FAQ
More







Boost.TypeIndex Header Reference

Header &lt;boost/type_index.hpp&gt;
Header &lt;boost/type_index/ctti_type_index.hpp&gt;
Header &lt;boost/type_index/runtime_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/boost_shared_ptr_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/pointer_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/reference_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/register_runtime_class.hpp&gt;
Header &lt;boost/type_index/runtime_cast/std_shared_ptr_cast.hpp&gt;
Header &lt;boost/type_index/stl_type_index.hpp&gt;
Header &lt;boost/type_index/type_index_facade.hpp&gt;



Header &lt;boost/type_index.hpp&gt;
Includes minimal set of headers required to use the Boost.TypeIndex library. 
By inclusion of this file most optimal type index classes will be included and used as a boost::typeindex::type_index and boost::typeindex::type_info. 


BOOST_TYPE_INDEX_REGISTER_CLASS
BOOST_TYPE_INDEX_FUNCTION_SIGNATURE
BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING
BOOST_TYPE_INDEX_USER_TYPEINDEX
BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY
namespace boost {
  namespace typeindex {
    typedef platform_specific type_index;
    typedef type_index::type_info_t type_info;
    template&lt;typename T&gt; type_index type_id();
    template&lt;typename T&gt; type_index type_id_with_cvr();
    template&lt;typename T&gt; type_index type_id_runtime(const T &amp;);
  }
}



Header &lt;boost/type_index/ctti_type_index.hpp&gt;
Contains boost::typeindex::ctti_type_index class that is constexpr if C++14 constexpr is supported by compiler. 
boost::typeindex::ctti_type_index class can be used as a drop-in replacement for std::type_index.
It is used in situations when typeid() method is not available or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined. 
namespace boost {
  namespace typeindex {
    class ctti_type_index;

    // Helper method for getting detail::ctti_data of a template parameter T. 
    template&lt;typename T&gt; unspecified ctti_construct();
  }
}



Header &lt;boost/type_index/runtime_cast.hpp&gt;
Contains the basic utilities necessary to fully emulate dynamic_cast for language level constructs (raw pointers and references). 
boost::typeindex::runtime_cast is a drop in replacement for dynamic_cast that can be used in situations where traditional rtti is either unavailable or undesirable. 



Header &lt;boost/type_index/runtime_cast/boost_shared_ptr_cast.hpp&gt;
Contains the overload of boost::typeindex::runtime_pointer_cast for boost::shared_ptr types. 
namespace boost {
  template&lt;typename T&gt; class shared_ptr;
  namespace typeindex {
    template&lt;typename T, typename U&gt; 
      boost::shared_ptr&lt; T &gt; 
      runtime_pointer_cast(boost::shared_ptr&lt; U &gt; const &amp;);
  }
}



Header &lt;boost/type_index/runtime_cast/pointer_cast.hpp&gt;
namespace boost {
  namespace typeindex {
    template&lt;typename T, typename U&gt; T runtime_cast(U *);
    template&lt;typename T, typename U&gt; T runtime_cast(U const *);
    template&lt;typename T, typename U&gt; T * runtime_pointer_cast(U *);
    template&lt;typename T, typename U&gt; T const * runtime_pointer_cast(U const *);
  }
}



Header &lt;boost/type_index/runtime_cast/reference_cast.hpp&gt;
Contains the overload of boost::typeindex::runtime_cast for reference types. 
namespace boost {
  namespace typeindex {
    struct bad_runtime_cast;
    template&lt;typename T, typename U&gt; 
      std::add_lvalue_reference&lt; T &gt;::type runtime_cast(U &amp;);
    template&lt;typename T, typename U&gt; 
      std::add_lvalue_reference&lt; constT &gt;::type runtime_cast(U const &amp;);
  }
}



Header &lt;boost/type_index/runtime_cast/register_runtime_class.hpp&gt;
Contains the macros BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST and BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS. 


BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(...)
BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(...)
BOOST_TYPE_INDEX_NO_BASE_CLASS



Header &lt;boost/type_index/runtime_cast/std_shared_ptr_cast.hpp&gt;
Contains the overload of boost::typeindex::runtime_pointer_cast for std::shared_ptr types. 
namespace boost {
  namespace typeindex {
    template&lt;typename T, typename U&gt; 
      std::shared_ptr&lt; T &gt; runtime_pointer_cast(std::shared_ptr&lt; U &gt; const &amp;);
  }
}



Header &lt;boost/type_index/stl_type_index.hpp&gt;
Contains boost::typeindex::stl_type_index class. 
boost::typeindex::stl_type_index class can be used as a drop-in replacement for std::type_index.
It is used in situations when RTTI is enabled or typeid() method is available. When typeid() is disabled or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined boost::typeindex::ctti is usually used instead of boost::typeindex::stl_type_index. 
namespace boost {
  namespace typeindex {
    class stl_type_index;
  }
}



Header &lt;boost/type_index/type_index_facade.hpp&gt;
namespace boost {
  namespace typeindex {
    template&lt;typename Derived, typename TypeInfo&gt; class type_index_facade;

    // noexcept comparison operators for type_index_facade classes. 
    bool operator==,!=,&lt;,...(const type_index_facade &amp; lhs, 
                             const type_index_facade &amp; rhs);

    // noexcept comparison operators for type_index_facade and it's TypeInfo classes. 
    bool operator==,!=,&lt;,...(const type_index_facade &amp; lhs, 
                             const TypeInfo &amp; rhs);

    // noexcept comparison operators for type_index_facade's TypeInfo and type_index_facade classes. 
    bool operator==,!=,&lt;,...(const TypeInfo &amp; lhs, 
                             const type_index_facade &amp; rhs);

    // Ostream operator that will output demangled name. 
    template&lt;typename CharT, typename TriatT, typename Derived, 
             typename TypeInfo&gt; 
      std::basic_ostream&lt; CharT, TriatT &gt; &amp; 
      operator&lt;&lt;(std::basic_ostream&lt; CharT, TriatT &gt; &amp; ostr, 
                 const type_index_facade&lt; Derived, TypeInfo &gt; &amp; ind);
    template&lt;typename Derived, typename TypeInfo&gt; 
      std::size_t hash_value(const type_index_facade&lt; Derived, TypeInfo &gt; &amp;);
  }
}


Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_typeindex_header_reference.html
Macro BOOST_RV_REF_END_IF_CXX11\3



Macro BOOST_RV_REF_END_IF_CXX11











Home
Libraries
People
FAQ
More








Macro BOOST_RV_REF_END_IF_CXX11
BOOST_RV_REF_END_IF_CXX11

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_RV_REF_END_IF_CXX11

Description
This macro expands to BOOST_RV_REF_END if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined, empty otherwise 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_RV_REF_END_IF_CXX11.html
Chapter 23. Boost.Move\3



Chapter 23. Boost.Move











Home
Libraries
People
FAQ
More








Chapter 23. Boost.Move

Ion Gaztanaga

Copyright © 2008-2014 Ion Gaztanaga


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Tested compilers
What is Boost.Move?
Introduction
Implementing copyable
    and movable classes

Copyable
      and movable classes in C++0x
Copyable
      and movable classes in portable syntax for both C++03 and C++0x compilers

Composition or inheritance
Movable but Non-Copyable Types
Containers and move semantics
Constructor Forwarding
Implicit Move when returning a local
    object
Move iterators
Move inserters
Move algorithms
Emulation limitations

Initializing
      base classes
Template
      parameters for perfect forwarding
Binding
      of rvalue references to lvalues
Assignment
      operator in classes derived from or holding copyable and movable types
Templated
      assignment operator in copyable and movable types

How the library works
Thanks and credits
Release Notes

Boost 1.81
      Release
Boost 1.79
      Release
Boost 1.78
      Release
Boost 1.77
      Release
Boost 1.76
      Release
Boost 1.75
      Release
Boost 1.73
      Release
Boost 1.71
      Release
Boost 1.70
      Release
Boost 1.69
      Release
Boost 1.67
      Release
Boost 1.66
      Release
Boost 1.65
      Release
Boost 1.64
      Release
Boost 1.62
      Release
Boost 1.61
      Release
Boost 1.60
      Release
Boost 1.59
      Release
Boost
      1.58 Release
Boost
      1.57 Release
Boost
      1.56 Release
Boost
      1.55 Release
Boost
      1.54 Release
Boost
      1.53 Release
Boost
      1.51 Release
Boost
      1.49 Release

Reference

Header &lt;boost/move/adl_move_swap.hpp&gt;
Header &lt;boost/move/algo/adaptive_merge.hpp&gt;
Header &lt;boost/move/algo/adaptive_sort.hpp&gt;
Header &lt;boost/move/algo/predicate.hpp&gt;
Header &lt;boost/move/algo/unique.hpp&gt;
Header &lt;boost/move/algorithm.hpp&gt;
Header &lt;boost/move/core.hpp&gt;
Header &lt;boost/move/default_delete.hpp&gt;
Header &lt;boost/move/iterator.hpp&gt;
Header &lt;boost/move/make_unique.hpp&gt;
Header &lt;boost/move/algo/move.hpp&gt;
Header &lt;boost/move/move.hpp&gt;
Header &lt;boost/move/traits.hpp&gt;
Header &lt;boost/move/unique_ptr.hpp&gt;
Header &lt;boost/move/utility.hpp&gt;
Header &lt;boost/move/utility_core.hpp&gt;






Important


      To be able to use containers of movable-only values in C++03 mode you will
      need to use containers supporting move semantics, like Boost.Container
      containers
    



Tested compilers


      Boost.Move has been tested in the following
      compilers/platforms:
    


          Visual C++ &gt;= 7.1.
        

          GCC &gt;= 4.1.
        




Warning


        GCC &lt; 4.3 and MSVC &lt; 9.0 are deprecated and will be removed in the
        next version.
      










\3https://www.boost.org/doc/libs/1_84_0/doc/html/move.html
Chapter 9. The Conversion Library 1.7\3



Chapter 9. The Conversion Library 1.7











Home
Libraries
People
FAQ
More








Chapter 9. The Conversion Library 1.7


Bjarne Stroustrup


Dave Abrahams


Boris Rasin


Antony Polukhin


Copyright © 2001 Beman Dawes
Copyright © 2014-2023 Antony Polukhin


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Description
Polymorphic casts

polymorphic_downcast
polymorphic_cast
polymorphic_pointer_cast

Synopsis
History




Description


      The Conversion Library improves program safety and clarity by performing otherwise
      messy conversions. It includes cast-style function templates designed to complement
      the C++ Standard's built-in casts.
    

      To reduce coupling, particularly to standard library IOStreams, the Boost Conversion
      Library is supplied by several headers:
    


          The boost/polymorphic_cast.hpp
          header provides polymorphic_cast&lt;&gt; and polymorphic_downcast&lt;&gt;
          to perform safe casting between polymorphic types.
        

          The boost/polymorphic_pointer_cast.hpp
          header provides polymorphic_pointer_cast&lt;&gt;
          and polymorphic_pointer_downcast&lt;&gt;
        

          The boost/implicit_cast.hpp
          header provides implicit_cast&lt;&gt; to perform implicit casts only
          (no down-cast, no void*-&gt;T*, no U-&gt;T if T has only explicit constructors
          for U).
        

          The boost/lexical_cast.hpp
          header provides lexical_cast&lt;&gt;
          general literal text conversions, such as an int
          represented as a string,
          or vice-versa.
        










\3https://www.boost.org/doc/libs/1_84_0/doc/html/conversion.html
Concept Assignable\3



Concept Assignable











Home
Libraries
People
FAQ
More








Concept Assignable
Assignable


Description
Assignable types must have copy constructors,
    operator= for assignment, and the swap()
    function defined.


Refinement of
CopyConstructible


Notation

X
A type playing the role of assignable-type in the Assignable concept.

x, y

Objects of type X



Valid expressions








Name
Expression
Type
Semantics



Assignment
x = y
X &amp;
Require operator=


Swap
swap(x, y)
void
Require swap() function





Models
int


See also
CopyConstructible


Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/Assignable.html
Macro BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST\3



Macro BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST
BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST — Macro used to make a class compatible with boost::typeindex::runtime_cast without including support for boost::typeindex::type_id_runtime. 

Synopsis
// In header: &lt;boost/type_index/runtime_cast/register_runtime_class.hpp&gt;

BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(...)

Description
BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST is provided as an alternative to BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS in the event that support for boost::typeindex::type_id_runtime is undesirable.
Example: 
struct base1 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST()
    virtual ~base1();
};

struct base2 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST()
    virtual ~base2();
};

struct derived1 : base1 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(base1)
};

struct derived2 : base1, base2 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(base1, base2)
};

...

base1* pb1 = get_object();
if(derived2* pb2 = boost::typeindex::runtime_cast&lt;derived2*&gt;(pb1))
{ /* can't call boost::typeindex::type_id_runtime(*pb1) here */ }





Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_8_4.html
Macro BOOST_MPI_DECL\3



Macro BOOST_MPI_DECL











Home
Libraries
People
FAQ
More








Macro BOOST_MPI_DECL
BOOST_MPI_DECL

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

BOOST_MPI_DECL

Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MPI_DECL.html
Macro BOOST_YAP_USER_CALL_OPERATOR\3



Macro BOOST_YAP_USER_CALL_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_CALL_OPERATOR
BOOST_YAP_USER_CALL_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_CALL_OPERATOR(expr_template)

Description
Defines operator overloads for the call operator taking any number of parameters ("operator()") that each produce an expression instantiated from the expr_template expression template. One overload is defined for each of the qualifiers const &amp;, &amp;, and &amp;&amp;. For the lvalue reference overloads, *this is captured by reference into the resulting expression. For the rvalue reference overload, *this is moved into the resulting expression.
The u parameters to each of the defined overloads may be any type, including an expression. Each non-expression is wrapped in a terminal expression.
Example: 









Parameters:






expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate. 






Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_5.html
Macro BOOST_COPY_ASSIGN_REF\3



Macro BOOST_COPY_ASSIGN_REF











Home
Libraries
People
FAQ
More








Macro BOOST_COPY_ASSIGN_REF
BOOST_COPY_ASSIGN_REF

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_COPY_ASSIGN_REF(TYPE)

Description
This macro is used to achieve portable syntax in copy assignment for classes marked as BOOST_COPYABLE_AND_MOVABLE. 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_COPY_ASSIGN_REF.html
Macro BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS\3



Macro BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS
BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS — Macro used to make a class compatible with boost::typeindex::runtime_cast. 

Synopsis
// In header: &lt;boost/type_index/runtime_cast/register_runtime_class.hpp&gt;

BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(...)

Description
BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS generates a virtual function in the current class that, when combined with the supplied base class information, allows boost::typeindex::runtime_cast to accurately convert between dynamic types of instances of the current class.
BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS also adds support for boost::typeindex::type_id_runtime by including BOOST_TYPE_INDEX_REGISTER_CLASS. It is typical that these features are used together, but in the event that BOOST_TYPE_INDEX_REGISTER_CLASS is undesirable in the current class, BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST is provided.
Example: 
struct base1 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS()
    virtual ~base1();
};

struct base2 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS()
    virtual ~base2();
};

struct derived1 : base1 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(base1)
};

struct derived2 : base1, base2 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(base1, base2)
};

...

base1* pb1 = get_object();
if(derived2* pb2 = boost::typeindex::runtime_cast&lt;derived2*&gt;(pb1)) {
    assert(boost::typeindex::type_id_runtime(*pb1)) == boost::typeindex::type_id&lt;derived2&gt;());
}





Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_8_3.html
Macro BOOST_INTRUSIVE_OPTION_CONSTANT\3



Macro BOOST_INTRUSIVE_OPTION_CONSTANT











Home
Libraries
People
FAQ
More








Macro BOOST_INTRUSIVE_OPTION_CONSTANT
BOOST_INTRUSIVE_OPTION_CONSTANT

Synopsis
// In header: &lt;boost/intrusive/pack_options.hpp&gt;

BOOST_INTRUSIVE_OPTION_CONSTANT(OPTION_NAME, TYPE, VALUE, CONSTANT_NAME)

Description
Defines an option class of name OPTION_NAME that can be used to specify a constant of type TYPE with value VALUE...
struct OPTION_NAME&lt;TYPE VALUE&gt;
{  unspecified_content  };

...that after being combined with boost::intrusive::pack_options, will contain a CONSTANT_NAME static constant of value VALUE. Example:
//[includes and namespaces omitted for brevity]

//This macro will create the following class:
//    template&lt;bool Enabled&gt;
//    struct incremental
//    { unspecified_content };
BOOST_INTRUSIVE_OPTION_CONSTANT(incremental, bool, Enabled, is_incremental)

struct empty_default{};

const bool is_incremental = pack_options&lt; empty_default, incremental&lt;true&gt; &gt;::type::is_incremental;

BOOST_STATIC_ASSERT(( is_incremental == true ));

 


Copyright © 2005 Olaf KrzikallaCopyright © 2006-2015 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_INTRUSIVE_O_idm34875.html
Reference Section of Boost.Any\3



Reference Section of Boost.Any











Home
Libraries
People
FAQ
More







Reference Section of Boost.Any

Header &lt;boost/any.hpp&gt;
Header &lt;boost/any/bad_any_cast.hpp&gt;
Header &lt;boost/any/basic_any.hpp&gt;
Header &lt;boost/any/fwd.hpp&gt;
Header &lt;boost/any/unique_any.hpp&gt;



Header &lt;boost/any.hpp&gt;
A class whose instances can hold instances of any type that satisfies   ValueType  requirements.  
namespace boost {
  class any;
  void swap(any &amp;, any &amp;);
  template&lt;typename ValueType&gt; ValueType * any_cast(any *);
  template&lt;typename ValueType&gt; const ValueType * any_cast(const any *);
  template&lt;typename ValueType&gt; ValueType any_cast(any &amp;);
  template&lt;typename ValueType&gt; ValueType any_cast(const any &amp;);
  template&lt;typename ValueType&gt; ValueType any_cast(any &amp;&amp;);
}



Header &lt;boost/any/bad_any_cast.hpp&gt;
namespace boost {
  class bad_any_cast;
}



Header &lt;boost/any/basic_any.hpp&gt;
A class with customizable Small Object Optimization whose instances can hold instances of any type that satisfies   ValueType  requirements. Use boost::any instead if not sure.  
namespace boost {
  namespace anys {
    template&lt;std::size_t OptimizeForSize, std::size_t OptimizeForAlignment&gt; 
      class basic_any;
    template&lt;std::size_t OptimizeForSize, std::size_t OptimizeForAlignment&gt; 
      void swap(basic_any&lt; OptimizeForSize, OptimizeForAlignment &gt; &amp;, 
                basic_any&lt; OptimizeForSize, OptimizeForAlignment &gt; &amp;);
    template&lt;typename ValueType, std::size_t Size, std::size_t Alignment&gt; 
      ValueType * any_cast(basic_any&lt; Size, Alignment &gt; *);
    template&lt;typename ValueType, std::size_t OptimizeForSize, 
             std::size_t OptimizeForAlignment&gt; 
      const ValueType * 
      any_cast(const basic_any&lt; OptimizeForSize, OptimizeForAlignment &gt; *);
    template&lt;typename ValueType, std::size_t OptimizeForSize, 
             std::size_t OptimizeForAlignment&gt; 
      ValueType any_cast(basic_any&lt; OptimizeForSize, OptimizeForAlignment &gt; &amp;);
    template&lt;typename ValueType, std::size_t OptimizeForSize, 
             std::size_t OptimizeForAlignment&gt; 
      ValueType any_cast(const basic_any&lt; OptimizeForSize, OptimizeForAlignment &gt; &amp;);
    template&lt;typename ValueType, std::size_t OptimizeForSize, 
             std::size_t OptimizeForAlignment&gt; 
      ValueType any_cast(basic_any&lt; OptimizeForSize, OptimizeForAlignment &gt; &amp;&amp;);
  }
}



Header &lt;boost/any/fwd.hpp&gt;
Forward declarations of Boost.Any library types. 



Header &lt;boost/any/unique_any.hpp&gt;
A class whose instances can hold instances of any type (including non-copyable and non-movable types).  
namespace boost {
  namespace anys {
    template&lt;typename T&gt; struct in_place_type_t;

    class unique_any;

    constexpr in_place_type_t&lt; T &gt; in_place_type;
    void swap(unique_any &amp;, unique_any &amp;);
    template&lt;typename T&gt; T * any_cast(unique_any *);
    template&lt;typename T&gt; const T * any_cast(const unique_any *);
    template&lt;typename T&gt; T any_cast(unique_any &amp;);
    template&lt;typename T&gt; T any_cast(const unique_any &amp;);
    template&lt;typename T&gt; T any_cast(unique_any &amp;&amp;);
  }
}


Copyright © 2001 Kevlin HenneyCopyright © 2013-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/reference_section_of_boost_any.html
Chapter 12. Boost.DLL\3



Chapter 12. Boost.DLL











Home
Libraries
People
FAQ
More








Chapter 12. Boost.DLL

Renato Forti


Antony Polukhin

Copyright © 2014 Renato Tegon Forti, Antony Polukhin
Copyright © 2015 Antony Polukhin
Copyright © 2016 Antony Polukhin, Klemens Morgenstern
Copyright © 2017-2023 Antony Polukhin


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Motivation
Getting started
Tutorial

Plugin basics
Factory
      method in plugin
Searching
      for a symbol in multiple plugins
Linking
      plugin into the executable
Symbol
      shadowing problem (Linux)
Executing
      callbacks on library unload
Querying
      libraries for symbols
Advanced
      library reference counting
Importing
      a C function from Windows dll

Mangled Import

Support
      &amp; Requirements
Mangled
      Import Example
Class Import
Overloading
      qualifiers

Missuses
Reference

Shared Library Reference
Shared Library Refcountable Reference

Limitations

Exporting
      weak symbols (Fails on MinGW, Android)
User
      defined section names (Fails on SunOS + Oracle Solaris Studio Compilers)
Thread safe library
      loading (Fails on FreeBSD, MacOS, iOS and some other)
Nested Function Definitions

F.A.Q.
Design Rationale

ABI
      portability across compilers
User's
      plugin API
Performance
      and memory allocations
Self loading
Aliases
      vs Mangling

Dependencies
Revision History
Acknowledgements




Motivation


      Adding a specific features to an existing software applications at runtime
      could be useful in many cases. Such extensions, or plugins, are usually implemented
      using Dynamic Library Modules (DLL,SO/DSO) loaded at runtime.
    

      This library was designed to simplify plugin development using C++ in a portable
      cross-platform manner.
    

      Library provides a portable across platforms way to:
    


          load libraries
        

          import any native functions and variables
        

          make alias names for C++ mangled functions and symbols
        

          query libraries for sections and exported symbols
        

          self loading and self querying
        

          getting program and module location by exported symbol
        










\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_dll.html
Chapter 37. Boost.STLInterfaces\3



Chapter 37. Boost.STLInterfaces











Home
Libraries
People
FAQ
More








Chapter 37. Boost.STLInterfaces

Zach Laine

Copyright © 2019 T. Zachary Laine


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
This
    Library's Relationship to Boost.Iterator
The
    v1 and v2
    Namespaces, and the Use of C++20 Concepts
Tutorial:
    iterator_interface
Tutorial:
    view_interface
Tutorial:
    sequence_container_interface
Tutorial:
    reverse_iterator
Tutorial:
    View Adaptors
Tutorial:
    closure and adaptor
Tutorial:
    bind_back()
    and More Complicated View Adaptors
Examples

Random
      Access Iterator
Mutable
      and Constant Iterator Interoperability
Zip
      Iterator / Proxy Iterator
Reimplementing
      back_insert_iterator
Reimplementing
      reverse_iterator

Compiler Support
Reference
Headers
Rationale




Introduction


      Writing STL iterators, views, and containers is surprisingly hard. There are
      a lot of things that can subtly go wrong. It is also very tedious, which of
      course makes it error-prone.
    

      Iterators have numerous typedefs and operations, even though all the operations
      of a given iterator can be implemented in terms of at most four operations
      (and usually only three). Writing all the other operations yields very similar-looking
      code that is hard to review, and all but requires that you write full-coverage
      tests for each iterator.
    

      Writing view types like those found in std::ranges
      is also laborious, considering that most of each view type's API can be derived
      from begin()
      and end().
      C++20 has a template that does exactly this, std::ranges::view_interface;
      Boost.STLInterfaces provides a pre-C++20-friendly implementation.
    

      Due to inconsistencies in the way different compilers implement their C++20
      view adaptors' operator|
      support, its particularly thorny to try and write a view adaptor portable across
      multiple versions of C++, or even across multiple compilers building in C++20
      mode. Boost.STLInterfaces provides a type boost::stl_interfaces::range_adaptor_closure
      that is compatible with C++23's std::range_adaptor_closure,
      and which works with earlier versions of C++ as well. Boost.STLInterfaces also
      has helper templates that make it much easier to write view adaptors with
      operator|
      support.
    

      Most daunting of all is the task of writing a type or template that meets the
      container requirements in the standard. Boost.STLInterfaces provides another
      template called sequence_container_interface
      that reduces the implementation and testing burden dramatically.
    



Note


        C++20 versions of iterator_interface and sequence_container_interface
        are provided (C++20 provides std::view_interface).
        These are constrained templates using C++20 concepts. These are in the boost::stl_interfaces::v2 namespace. There is also a C++23 version
        of iterator_interface that uses
        deducing this instead of CRTP.
        If you do nothing, you'll get the latest vN
        namespace inlined, depending on your compiler's language support.
      



      A
      Quick Example
    

      Here is an example of the iterator portion of the library. Let's say that we
      wanted to make a random access iterator that represents a string of arbitrary
      length constructed by repeating a shorter string. Let's call this iterator
      repeated_chars_iterator. Here
      it is in action:
    


repeated_chars_iterator first("foo", 3, 0); // 3 is the length of "foo", 0 is this iterator's position.
repeated_chars_iterator last("foo", 3, 7);  // Same as above, but now the iterator's position is 7.
std::string result;
std::copy(first, last, std::back_inserter(result));
assert(result == "foofoof");


    

      There's nothing in the standard library that gets us that kind of behavior,
      so we have to write it. This library seeks to turn what we write from this:
    
struct repeated_chars_iterator
{
    using value_type = char;
    using difference_type = std::ptrdiff_t;
    using pointer = char const *;
    using reference = char const;
    using iterator_category = std::random_access_iterator_tag;

    constexpr repeated_chars_iterator() noexcept :
        first_(nullptr),
        size_(0),
        n_(0)
    {}
    constexpr repeated_chars_iterator(
        char const * first,
        difference_type size,
        difference_type n) noexcept :
        first_(first),
        size_(size),
        n_(n)
    {}

    constexpr reference operator*() const noexcept
    {
        return first_[n_ % size_];
    }

    constexpr value_type operator[](difference_type n) const noexcept
    {
        return first_[(n_ + n) % size_];
    }

    constexpr repeated_chars_iterator &amp; operator++() noexcept
    {
        ++n_;
        return *this;
    }
    constexpr repeated_chars_iterator operator++(int)noexcept
    {
        repeated_chars_iterator retval = *this;
        ++*this;
        return retval;
    }
    constexpr repeated_chars_iterator &amp; operator+=(difference_type n) noexcept
    {
        n_ += n;
        return *this;
    }

    constexpr repeated_chars_iterator &amp; operator--() noexcept
    {
        --n_;
        return *this;
    }
    constexpr repeated_chars_iterator operator--(int)noexcept
    {
        repeated_chars_iterator retval = *this;
        --*this;
        return retval;
    }
    constexpr repeated_chars_iterator &amp; operator-=(difference_type n) noexcept
    {
        n_ -= n;
        return *this;
    }

    friend constexpr bool operator==(
        repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
    {
        return lhs.first_ == rhs.first_ &amp;&amp; lhs.n_ == rhs.n_;
    }
    friend constexpr bool operator!=(
        repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
    {
        return !(lhs == rhs);
    }
    friend constexpr bool operator&lt;(
        repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
    {
        return lhs.first_ == rhs.first_ &amp;&amp; lhs.n_ &lt; rhs.n_;
    }
    friend constexpr bool operator&lt;=(
        repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
    {
        return lhs == rhs || lhs &lt; rhs;
    }
    friend constexpr bool operator&gt;(
        repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
    {
        return rhs &lt; lhs;
    }
    friend constexpr bool operator&gt;=(
        repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
    {
        return rhs &lt;= lhs;
    }

    friend constexpr repeated_chars_iterator
    operator+(repeated_chars_iterator lhs, difference_type rhs) noexcept
    {
        return lhs += rhs;
    }
    friend constexpr repeated_chars_iterator
    operator+(difference_type lhs, repeated_chars_iterator rhs) noexcept
    {
        return rhs += lhs;
    }
    friend constexpr repeated_chars_iterator
    operator-(repeated_chars_iterator lhs, difference_type rhs) noexcept
    {
        return lhs -= rhs;
    }
    friend constexpr difference_type operator-(
        repeated_chars_iterator lhs, repeated_chars_iterator rhs) noexcept
    {
        return lhs.n_ - rhs.n_;
    }

private:
    char const * first_;
    difference_type size_;
    difference_type n_;
};


      (that's a lot of code!) into this:
    


struct repeated_chars_iterator : boost::stl_interfaces::iterator_interface&lt;
#if !BOOST_STL_INTERFACES_USE_DEDUCED_THIS
                                     repeated_chars_iterator,
#endif
                                     std::random_access_iterator_tag,
                                     char,
                                     char&gt;
{
    constexpr repeated_chars_iterator() noexcept :
        first_(nullptr),
        size_(0),
        n_(0)
    {}
    constexpr repeated_chars_iterator(
        char const * first, difference_type size, difference_type n) noexcept :
        first_(first),
        size_(size),
        n_(n)
    {}

    constexpr char operator*() const noexcept { return first_[n_ % size_]; }
    constexpr repeated_chars_iterator &amp; operator+=(std::ptrdiff_t i) noexcept
    {
        n_ += i;
        return *this;
    }
    constexpr auto operator-(repeated_chars_iterator other) const noexcept
    {
        return n_ - other.n_;
    }

private:
    char const * first_;
    difference_type size_;
    difference_type n_;
};


    

      Ah, that's better. Both of these definitions for repeated_chars_iterator
      have the same semantics and performance profile. It's just a lot less code
      to write the second one, and writing the second one is more novice-friendly.
    



Note


        Boost.STLInterfaces's iterator_interface
        implements iterators that model the C++20 iterator concepts.
      










\3https://www.boost.org/doc/libs/1_84_0/doc/html/stl_interfaces.html
Chapter 10. Boost.CRC 1.5\3



Chapter 10. Boost.CRC 1.5











Home
Libraries
People
FAQ
More








Chapter 10. Boost.CRC 1.5

Daryle Walker

Copyright © 2001, 2003, 2012 Daryle Walker


        Distributed under the Boost Software License, Version 1.0. (See the accompanying
        file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

What is Boost.CRC?
Introduction
CRCs
Theoretical CRC Computer
Optimized CRC Computer
CRC Function
Augmented-CRC Function
Pre-Defined CRC Samples
End Matter
Reference
Header &lt;boost/crc.hpp&gt;




What is Boost.CRC?


      CRCs (cyclic redundancy codes) is one common technique to confirming data integrity
      after transmission. The Boost.CRC library
      provides access to two styles of CRC computation, one as a function template,
      the other as a function template and two computation object class templates,
      where the two class templates differ in speed.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/crc.html
Concept PolymorphicFunctionObject\3



Concept PolymorphicFunctionObject











Home
Libraries
People
FAQ
More








Concept PolymorphicFunctionObject
PolymorphicFunctionObject


Description

      A type that can be called and that follows the TR1 ResultOf
      protocol for return type calculation.
    


Associated types

result_type
result_of&lt;Fn(A0,...An)&gt;::type

      
The result of calling the Polymorphic Function Object.

    



Notation

Fn
A type playing the role of polymorphic-function-object-type in the PolymorphicFunctionObject concept.
fn
Object of type Fn
a0,...an
Object of type A0,...An



Valid expressions








Name
Expression
Type
Semantics


Function Call
fn(a0,...an)
result_type
Calls the function object.




Models
std::plus&lt;int&gt;


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/PolymorphicFunctionObject.html
Concept DefaultConstructible\3



Concept DefaultConstructible











Home
Libraries
People
FAQ
More








Concept DefaultConstructible
DefaultConstructible


Description
DefaultConstructible objects only need to have a default
  constructor.


Notation

X
A type playing the role of default-constructible-type in the DefaultConstructible concept.



Valid expressions








Name
Expression
Type
Semantics


Construction
X()
X
Construct an instance of the type with default parameters.




Models

int
std::vector&lt;double&gt;



Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/DefaultConstructible.html
Chapter 21. Boost.Tribool\3



Chapter 21. Boost.Tribool











Home
Libraries
People
FAQ
More








Chapter 21. Boost.Tribool


Douglas Gregor

&lt;dgregor -at- cs.indiana.edu&gt;

Copyright © 2002-2004 Douglas Gregor

Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)



Table of Contents

Introduction
Tutorial

Basic usage
Renaming the indeterminate state
tribool input/output

Reference

Header &lt;boost/logic/tribool.hpp&gt;
Header &lt;boost/logic/tribool_fwd.hpp&gt;
Header &lt;boost/logic/tribool_io.hpp&gt;

Testsuite
Acceptance tests




Introduction
The 3-state boolean library contains a single class,
    boost::logic::tribool, along with
    support functions and operator overloads that implement 3-state
    boolean logic. 









\3https://www.boost.org/doc/libs/1_84_0/doc/html/tribool.html
Part I. The Boost C++ Libraries (BoostBook Subset)\3



Part I. The Boost C++ Libraries (BoostBook Subset)











Home
Libraries
People
FAQ
More







Part I. The Boost C++ Libraries (BoostBook Subset)

Table of Contents

1. Boost.Accumulators

Preface
User's Guide
Acknowledgements
Reference

2. Boost String Algorithms Library

Introduction
Release Notes
Usage
Quick Reference
Design Topics
Concepts
Reference
Rationale
Environment
Credits

3. Boost.Align

Introduction
Rationale
Examples
Reference
Vocabulary
Compatibility
Acknowledgments
History

4. Boost.Any 1.2

Introduction
Examples
ValueType requirements
Reference Section of Boost.Any
Acknowledgements

5. Boost.Array

Introduction
Reference
Design Rationale
For more information...
Acknowledgements

6. Boost.Chrono 2.0.8

Overview
User's Guide
Reference 
Appendices

7. Boost.Circular Buffer

Introduction
Circular_buffer example
Rationale
Implementation 
More Examples
Header Files
Modelled Concepts
Template Parameters
Trac Tickets
Release Notes
Acknowledgements
Documentation Version Info
Boost.Circular_buffer C++ Reference
Index

8. Boost.Container

Introduction
Main features
Boost.Container and C++ exceptions
Non-standard containers
Extended functionality:
    Basic extensions
Extended functionality:
    Configurable containers
Extended functionality:
    Extended allocators
C++11/C++14/C++17 Conformance
Known Issues
History and reasons to use
    Boost.Container
Indexes
Boost.Container Header Reference
Acknowledgements, notes
    and links
Release Notes

9. The Conversion Library 1.7

Description
Polymorphic casts
Synopsis
History

10. Boost.CRC 1.5

What is Boost.CRC?
Introduction
Theoretical CRC Computer
Optimized CRC Computer
CRC Function
Augmented-CRC Function
Pre-Defined CRC Samples
End Matter
Reference

11. Boost.Date_Time

Conceptual
General Usage Examples
Gregorian
Posix Time
Local Time
Date Time Input/Output
Serialization
Details
Examples
Library Reference

12. Boost.DLL

Motivation
Getting started
Tutorial
Mangled Import
Missuses
Reference
Limitations
F.A.Q.
Design Rationale
Dependencies
Revision History
Acknowledgements

13. Boost.Foreach

Introduction
Extensibility
Portability
Pitfalls
History and Acknowledgements

14. Boost.Function

Introduction
History &amp; Compatibility Notes
Tutorial
Reference
Frequently Asked Questions
Miscellaneous Notes
Testsuite

15. Boost.Heap

Introduction &amp; Motivation
Concepts &amp; Interface
Data Structures
Reference
Acknowledgements

16. Boost.Interprocess

Introduction
Quick Guide for the Impatient
Some basic explanations
Sharing memory
    between processes
Mapping Address Independent Pointer:
    offset_ptr
Synchronization
    mechanisms
Managed Memory Segments
Allocators, containers
    and memory allocation algorithms
Memory allocation algorithms
Direct iostream formatting: vectorstream
    and bufferstream
Ownership smart pointers
Architecture and internals
Customizing Boost.Interprocess
Acknowledgements,
    notes and links
Indexes and Reference

17. Boost.Intrusive

Introduction
Intrusive and non-intrusive
    containers
How to use Boost.Intrusive
When to use?
Concept summary
Presenting Boost.Intrusive
    containers
Safe hooks
Auto-unlink hooks
Intrusive singly linked list: slist
Intrusive doubly linked list: list
Intrusive associative containers:
    set, multiset, rbtree
Semi-Intrusive
    unordered associative containers: unordered_set, unordered_multiset
Map and multimap-like interface
    for associative containers
Intrusive avl tree based associative
    containers: avl_set, avl_multiset and avltree
Intrusive splay tree based
    associative containers: splay_set, splay_multiset and , splay_tree
Intrusive scapegoat tree based
    associative containers: sg_set, sg_multiset and sgtree
Intrusive treap based associative
    containers: treap_set, treap_multiset and treap
Binary search tree hooks: bs_set_base_hook
    and bs_set_member_hook
Advanced lookup
    and insertion functions for associative containers
Erasing and disposing
    values from Boost.Intrusive containers
Cloning Boost.Intrusive containers
Using function hooks
Recursive Boost.Intrusive containers
Using smart pointers with
    Boost.Intrusive containers
Obtaining iterators
    from values
Any Hooks: A single hook for any Intrusive
    container
Concepts explained
Node algorithms with custom
    NodeTraits
Containers with custom ValueTraits
Thread safety guarantees
Boost.Intrusive Iterator
    features
Stability and insertion
    with hint in ordered associative containers with equivalent keys
Obtaining
    the same types and reducing symbol length
Design Notes
Performance
Release Notes
References
Acknowledgements
Indexes
Reference

18. Boost.Lambda

In a nutshell
Getting Started
Introduction
Using the library
Lambda expressions in details
Extending return type deduction system
Practical considerations
Relation to other Boost libraries
Contributors
Rationale for some of the design decisions
Bibliography

19. Boost.Lexical_Cast 1.0

Motivation
Examples
Synopsis
Frequently
    Asked Questions
Changes
Performance

20. Boost.Lockfree

Introduction &amp;
    Motivation
Examples
Rationale
Reference
Appendices

21. Boost.Tribool

Introduction
Tutorial
Reference
Testsuite

22. Boost.Metaparse

Description
Related publications
    and blogs
Preface
Getting
    started with Boost.Metaparse
User manual
Versioning
Performance
The design of the
    library
Reference

23. Boost.Move

Tested compilers
What is Boost.Move?
Introduction
Implementing copyable
    and movable classes
Composition or inheritance
Movable but Non-Copyable Types
Containers and move semantics
Constructor Forwarding
Implicit Move when returning a local
    object
Move iterators
Move inserters
Move algorithms
Emulation limitations
How the library works
Thanks and credits
Release Notes
Reference

24. Boost.MPI

Introduction
Getting started
Tutorial
Mapping from C MPI to Boost.MPI
Reference
Python Bindings
Design Philosophy
Performance Evaluation
Revision History
Acknowledgments

25. Boost.MultiArray Reference Manual

Library Synopsis
MultiArray Concept
Array Components
Auxiliary Components

26. Boost.PFR 2.2

Intro
Short Examples
    for the Impatient
Tutorial
Limitations and
    Configuration
How it works
Acknowledgements
Reference Section of PFR

27. Boost.PolyCollection

Introduction
An efficient
    polymorphic data structure
Tutorial
Performance
Reference
Future work
Release notes
Acknowledgments

28. Boost.Process

Introduction
Concepts
Tutorial
Design Rationale
Extensions
Frequently Asked Questions
Reference
Acknowledgements
Process V2

29. Boost.Program_options

Introduction
Tutorial
Library Overview
How To
Design Discussion
Acknowledgements
Reference

30. Boost.PropertyTree

What is Property Tree?
Five Minute Tutorial
Property Tree as a Container
Property Tree Synopsis
How to Populate a Property Tree
How to Access Data in a Property
    Tree
Appendices
Reference

31. Boost.Proto

Preface
Users' Guide
Reference
Appendices

32. Boost.Random

Introduction
Tutorial
Reference
Performance
History and
    Acknowledgements

33. Boost.Ratio 2.1.0

Overview
User's Guide
Reference 
Appendices

34. Boost.Signals2

Introduction
Tutorial
Example programs
Reference
Thread-Safety
Frequently Asked Questions
Design Rationale
Signals2 API Changes
Testsuite

35. Boost.Stacktrace 1.0

Motivation
Getting Started
Configuration and Build
Acknowledgements
Reference

36. Boost.StaticAssert

Overview and Tutorial
How it works
Test Programs

37. Boost.STLInterfaces

Introduction
This
    Library's Relationship to Boost.Iterator
The
    v1 and v2
    Namespaces, and the Use of C++20 Concepts
Tutorial:
    iterator_interface
Tutorial:
    view_interface
Tutorial:
    sequence_container_interface
Tutorial:
    reverse_iterator
Tutorial:
    View Adaptors
Tutorial:
    closure and adaptor
Tutorial:
    bind_back()
    and More Complicated View Adaptors
Examples
Compiler Support
Reference
Rationale

38. Thread 4.8.0

Overview
Using and building the library
History
Future
Thread Management
Scoped Threads
Synchronization
Thread Local Storage
Synchronized Data Structures
Parallel - Fork-Join -- EXPERIMENTAL
Time Requirements
Emulations
Acknowledgments
Conformance and Extension

39. Boost.TypeErasure

Introduction
How to read this documentation
Basic Usage
Composing Concepts
Functions with Multiple Arguments
Concepts in Depth
Using Any
Examples
Concept Definitions
Predefined Concepts
Reference
Rationale
Future Work
Acknowledgements
Related Work

40. Boost.TypeIndex 4.1

Motivation
Getting started
Configuring and building the library
How it works
Examples
Boost.TypeIndex Header Reference
Making a custom
    type_index
Space and Performance
Code bloat
RTTI emulation
    limitations
Mixing
    sources with RTTI on and RTTI off
Acknowledgements

41. Boost.Typeof

Motivation
Tutorial
Reference
Other considerations and tips
Contributed By:
Acknowledgements

42. Boost.Units 1.1.0

Introduction
Quick Start
Dimensional Analysis
Units
Quantities
Examples
Utilities
Reference
Installation
FAQ
Acknowledgements
Help Wanted
Version Info
Release Notes
TODO

43. Boost.Variant

Introduction
Tutorial
Reference
Design Overview
Miscellaneous Notes
References

44. Boost.Xpressive

Preface
User's Guide
Reference
Acknowledgments
Appendices

45. Boost.YAP

Introduction
Manual
Concepts
Compiler Support
Dependencies
Reference
Rationale

46. Boost.Concept_Check
Concept reference










\3https://www.boost.org/doc/libs/1_84_0/doc/html/libraries.html
Chapter 38. Thread 4.8.0\3



Chapter 38. Thread 4.8.0











Home
Libraries
People
FAQ
More








Chapter 38. Thread 4.8.0

Anthony Williams


Vicente J. Botet Escriba

Copyright © 2007 -11 Anthony Williams
Copyright © 2011 -17 Vicente J. Botet Escriba


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Overview
Using and building the library

Configuration
Limitations

History
Future
Thread Management

Synopsis
Tutorial
Class thread
Namespace this_thread
Class thread_group EXTENSION

Scoped Threads

Motivation
Tutorial
Free Thread Functors
Class strict_scoped_thread
Class scoped_thread
Non-member function
      swap(scoped_thread&amp;,scoped_thread&amp;)

Synchronization

Tutorial
Mutex Concepts
Lock Options
Lock Guard
With Lock Guard
Lock Concepts
Lock Types
Other Lock Types
      - EXTENSION
Lock functions
Lock Factories
      - EXTENSION
Mutex Types
Condition Variables
One-time Initialization
Barriers -- EXTENSION
Latches -- EXPERIMENTAL
Executors and Schedulers
      -- EXPERIMENTAL
Futures

Thread Local Storage
Class
      thread_specific_ptr
Synchronized Data Structures

Synchronized Values
      - EXPERIMENTAL
Synchronized Queues --
      EXPERIMENTAL

Parallel - Fork-Join -- EXPERIMENTAL

Fork-Join
Reference -- EXPERIMENTAL

Time Requirements
Deprecated
Emulations

=delete emulation
Move semantics
Bool explicit
      conversion
Scoped Enums

Acknowledgments
Conformance and Extension

C++11 standard Thread library
C++14 standard Thread library
      - accepted changes
C++14 TS Extensions for Concurrency
      V1 
C++1z TS Concurrency - On going
      proposals





Overview


      Boost.Thread enables the use of multiple threads
      of execution with shared data in portable C++ code. It provides classes and
      functions for managing the threads themselves, along with others for synchronizing
      data between the threads or providing separate copies of data specific to individual
      threads.
    

      The Boost.Thread library was originally written
      and designed by William E. Kempf (version 1).
    

      Anthony Williams version (version 2) was a major rewrite designed to closely
      follow the proposals presented to the C++ Standards Committee, in particular
      N2497,
      N2320,
      N2184,
      N2139,
      and N2094
    

      Vicente J. Botet Escriba started (version 3) the adaptation to comply with
      the accepted Thread C++11 library (Make use of Boost.Chrono and Boost.Move)
      and the Shared
      Locking Howard Hinnant proposal except for the upward conversions.
      Some minor non-standard features have been added also as thread attributes,
      reverse_lock, shared_lock_guard.
    

      In order to use the classes and functions described here, you can either include
      the specific headers specified by the descriptions of each class or function,
      or include the master thread library header:
    
#include &lt;boost/thread.hpp&gt;


      which includes all the other headers in turn.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/thread.html
Macro BOOST_STL_INTERFACES_STATIC_ASSERT_CONCEPT\3



Macro BOOST_STL_INTERFACES_STATIC_ASSERT_CONCEPT











Home
Libraries
People
FAQ
More








Macro BOOST_STL_INTERFACES_STATIC_ASSERT_CONCEPT
BOOST_STL_INTERFACES_STATIC_ASSERT_CONCEPT

Synopsis
// In header: &lt;boost/stl_interfaces/iterator_interface.hpp&gt;

BOOST_STL_INTERFACES_STATIC_ASSERT_CONCEPT(type, concept_name)

Description
static_asserts that type type models concept concept_name. This is useful for checking that an iterator, view, etc. that you write using one of the *_interface templates models the right C++ concept.
For example: BOOST_STL_INTERFACES_STATIC_ASSERT_CONCEPT(my_iter,
std::input_iterator).



Note

This macro expands to nothing when __cpp_lib_concepts is not defined. 





Copyright © 2019 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_STL__1_3_38_15_2_4_2.html
Chapter 40. Boost.TypeIndex 4.1\3



Chapter 40. Boost.TypeIndex 4.1











Home
Libraries
People
FAQ
More








Chapter 40. Boost.TypeIndex 4.1
Copyright © 2012-2023 Antony Polukhin


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Motivation
Getting started

How to use
Example
      with Boost.Any
Example
      with Boost.Variant

Configuring and building the library
How it works
Examples

Getting
      human readable and mangled type names
Storing
      information about a type in container 
Getting
      through the inheritance to receive a real type name 
Using
      runtime_cast where RTTI is unavailable or undesirable 
Exact
      type matching: storing type with const, volatile and reference qualifiers
Table
      of raw_name() and pretty_name() outputs with and without RTTI 
C++14:
      Checking namespace at compile time 
C++14:
      Checking lexigraphical order of provided types 

Boost.TypeIndex Header Reference

Header &lt;boost/type_index.hpp&gt;
Header &lt;boost/type_index/ctti_type_index.hpp&gt;
Header &lt;boost/type_index/runtime_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/boost_shared_ptr_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/pointer_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/reference_cast.hpp&gt;
Header &lt;boost/type_index/runtime_cast/register_runtime_class.hpp&gt;
Header &lt;boost/type_index/runtime_cast/std_shared_ptr_cast.hpp&gt;
Header &lt;boost/type_index/stl_type_index.hpp&gt;
Header &lt;boost/type_index/type_index_facade.hpp&gt;

Making a custom
    type_index

Basics
Getting
      type infos at runtime
Using
      new type infos all around the code

Space and Performance
Code bloat
RTTI emulation
    limitations

Define
      the BOOST_TYPE_INDEX_FUNCTION_SIGNATURE macro
Fixing
      pretty_name() output

Mixing
    sources with RTTI on and RTTI off
Acknowledgements




Motivation


      Sometimes getting and storing information about a type at runtime is required.
      For such cases a construction like &amp;typeid(T) or C++11 class std::type_index
      is usually used, which is where problems start:
    


          typeid(T) and
          std::type_index require Run Time Type Info
          (RTTI)
        

          some implementations of typeid(T)
          erroneously do not strip const, volatile and references from type
        

          some compilers have bugs and do not correctly compare std::type_info
          objects across shared libraries
        

          only a few implementations of Standard Library currently provide std::type_index
        

          no easy way to store type info without stripping const, volatile and references
        

          no nice and portable way to get human readable type names
        

          no way to easily make your own type info class
        


      Boost.TypeIndex library was designed to work around all those issues.
    



Note


        T means type here. Think
        of it as of T in template &lt;class T&gt;
      










\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_typeindex.html
Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS\3



Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS











Home
Libraries
People
FAQ
More








Macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS
BOOST_VARIANT_ENUM_SHIFTED_PARAMS — Enumerate all but the first parameter for use with
        variant.

Synopsis
// In header: &lt;boost/variant/variant_fwd.hpp&gt;

BOOST_VARIANT_ENUM_SHIFTED_PARAMS(param)

Description
 Expands to variadic template list in the following manner:
        
            BOOST_VARIANT_ENUM_SHIFTED_PARAMS(T)                    =&gt; TN...
            BOOST_VARIANT_ENUM_SHIFTED_PARAMS(class T)              =&gt; class... TN
            BOOST_VARIANT_ENUM_SHIFTED_PARAMS(class Something)      =&gt; class... SomethingN
            BOOST_VARIANT_ENUM_SHIFTED_PARAMS(typename Something)   =&gt; typename... SomethingN
            BOOST_VARIANT_ENUM_SHIFTED_PARAMS(Something)            =&gt; SomethingN...
            BOOST_VARIANT_ENUM_SHIFTED_PARAMS(Something)            =&gt; SomethingN...
        
      

        Otherwise expands to a comma-separated sequence of length
        BOOST_VARIANT_LIMIT_TYPES - 1,
        where each element in the sequence consists of the concatenation of
        param with its one-based index into the sequence.
        That is,
        param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1.
Note: This macro results in the
        same expansion as
        BOOST_VARIANT_ENUM_PARAMS -- but
        without the first term.


Copyright © 2002, 2003 Eric Friedman, Itay MamanCopyright © 2014-2023 Antony PolukhinDistributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at 
    http://www.boost.org/LICENSE_1_0.txt)
    







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_VARIANT_1_3_44_5_3_4.html
Chapter 18. Boost.Lambda\3



Chapter 18. Boost.Lambda











Home
Libraries
People
FAQ
More








Chapter 18. Boost.Lambda


Jaakko Järvi

&lt;jarvi at cs tamu edu&gt;

Copyright © 1999-2004 Jaakko Järvi, Gary Powell

Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)



Table of Contents

In a nutshell
Getting Started

Installing the library
Conventions used in this document

Introduction

Motivation
Introduction to lambda expressions

Using the library

Introductory Examples
Parameter and return types of lambda functors
About actual arguments to lambda functors
Storing bound arguments in lambda functions

Lambda expressions in details

Placeholders
Operator expressions
Bind expressions
Overriding the deduced return type
Delaying constants and variables
Lambda expressions for control structures
Exceptions
Construction and destruction
Special lambda expressions
Casts, sizeof and typeid
Nesting STL algorithm invocations

Extending return type deduction system
Practical considerations

Performance
About compiling
Portability

Relation to other Boost libraries

Boost Function
Boost Bind

Contributors
Rationale for some of the design decisions

Lambda functor arity

Bibliography




In a nutshell


      The Boost Lambda Library (BLL in the sequel) is a C++ template
      library, which implements a form of lambda abstractions for C++.
The term originates from functional programming and lambda calculus, where a lambda abstraction defines an unnamed function.
      The primary motivation for the BLL is to provide flexible and
      convenient means to define unnamed function objects for STL algorithms.
In explaining what the library is about, a line of code says more than a thousand words; the
      following line outputs the elements of some STL container
      a separated by spaces:

      
for_each(a.begin(), a.end(), std::cout &lt;&lt; _1 &lt;&lt; ' ');


      The expression std::cout &lt;&lt; _1 &lt;&lt; ' ' defines a unary function object. 
      The variable _1 is the parameter of this function, a placeholder for the actual argument. 
      Within each iteration of for_each, the function is
      called with an element of a as the actual argument.
      This actual argument is substituted for the placeholder, and the “body” of the function is evaluated.
    
The essence of BLL is letting you define small unnamed function objects, such as the one above, directly on the call site of an STL algorithm.
    



Bibliography

[STL94] A. A. Stepanov and M. Lee. The Standard Template Library. Hewlett-Packard Laboratories. 1994. 
www.hpl.hp.com/techreports
. 


[SGI02] The SGI Standard Template Library. 2002. www.boost.org/sgi/stl/. 


[C++98] International Standard, Programming Languages – C++. ISO/IEC:14882. 1998. 


[Jär99] 
Jaakko Järvi. 
C++ Function Object Binders Made Easy. 
. Lecture Notes in Computer Science. 1977. Springer. 2000. 


[Jär00] Jaakko Järvi. Gary Powell. The Lambda Library : Lambda Abstraction in C++. Turku Centre for Computer Science. Technical Report . 378. 2000. www.tucs.fi/publications. 


[Jär01] Jaakko Järvi. Gary Powell. The Lambda Library : Lambda Abstraction in C++. Second  Workshop on C++ Template Programming. Tampa Bay, OOPSLA'01. . 2001. www.oonumerics.org/tmpw01/. 


[Jär03] 

Jaakko Järvi. 

Gary Powell. 

Andrew Lumsdaine. 
The Lambda Library : unnamed functions in C++. 

. Software - Practice and Expreience. 33:259-291. 2003. 


[tuple] The Boost Tuple Library. www.boost.org/libs/tuple/doc/tuple_users_guide.html
. 2002. 


[type_traits] The Boost type_traits. www.boost.org/libs/type_traits/
. 2002. 


[ref] Boost ref. www.boost.org/libs/bind/ref.html
. 2002. 


[bind] Boost Bind Library. www.boost.org/libs/bind/bind.html
. 2002. 


[function] Boost Function Library. www.boost.org/libs/function/
. 2002. 


[fc++] The FC++ library: Functional Programming in C++. Yannis Smaragdakis. Brian McNamara. yanniss.github.io/fc++/ 
. 2002. 










\3https://www.boost.org/doc/libs/1_84_0/doc/html/lambda.html
Chapter 48. Quickbook 1.7\3



Chapter 48. Quickbook 1.7











Home
Libraries
People
FAQ
More








Chapter 48. Quickbook 1.7


Joel de Guzman


Eric Niebler


Copyright © 2002, 2004, 2006 Joel de Guzman,
      Eric Niebler
Copyright © 2010-2017 Daniel James


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Change Log
Command Line Usage
Command Line Options
Syntax Summary
Comments
Document Structure

Document
      Info
Sections

Phrase Level Elements

Font
      Styles
Replaceable
Quotations
Simple
      formatting
Role
Inline
      code
Code
      blocks
Source
      Mode
line-break
Anchors
Links
Anchor
      links
refentry
      links
Code
      Links
Escape
Single
      char escape
Unicode
      escape
Images
Footnotes
Macro
      Expansion
Template
      Expansion
Conditional
      Generation

Block Level Elements

xinclude
Paragraphs
Lists
Code
Escaping
      Back To QuickBook
Preformatted
Blockquote
Admonitions
Headings
Generic
      Heading
Macros
Predefined
      Macros
Templates
Blurbs
Tables
Variable
      Lists
Include
Import
Plain
      blocks

Language Versions

Upgrading to a new version
Stable Versions
Quickbook 1.6
Quickbook 1.7

Installation and configuration

Mac OS X
Windows 2000, XP, 2003, Vista,
      7
Debian, Ubuntu

Editor Support

Scintilla Text Editor
KDE Support

Frequently Asked Questions
Quick Reference




Introduction


        “Why program by hand in five days what
        you can spend five years of your life automating?”
      

        -- Terrence Parr, author ANTLR/PCCTS
      


      Well, QuickBook started as a weekend hack. It was originally intended to be
      a sample application using Spirit.
      What is it? What you are viewing now, this documentation, is autogenerated
      by QuickBook. These files were generated from one master:
    

        quickbook.qbk
      

      Originally named QuickDoc, this funky tool that never dies, evolved into a
      funkier tool thanks to Eric Niebler who resurrected the project making it generate
      BoostBook
      instead of HTML. The BoostBook
      documentation format is an extension of DocBook,
      an SGML or XML based format for describing documentation.
    



Tip


        You don't need to know anything about BoostBook
        or DocBook to use QuickBook.
        A basic understanding of DocBook
        might help, but shouldn't be necessary. For really advanced stuff you will
        need to know DocBook, but you
        can ignore it at first, and maybe continue to do so.
      


      QuickBook is a WikiWiki style documentation tool geared towards C++ documentation
      using simple rules and markup for simple formatting tasks. QuickBook extends
      the WikiWiki concept. Like the WikiWiki, QuickBook documents are simple text
      files. A single QuickBook document can generate a fully linked set of nice
      HTML and PostScript/PDF documents complete with images and syntax- colorized
      source code.
    

      Features include:
    


          generate BoostBook
          xml, to generate HTML, PostScript and PDF
        

          simple markup to link to Doxygen-generated entities
        

          macro system for simple text substitution
        

          simple markup for italics, bold, preformatted, blurbs, code samples, tables,
          URLs, anchors, images, etc.
        

          automatic syntax coloring of code samples
        

          CSS support
        










\3https://www.boost.org/doc/libs/1_84_0/doc/html/quickbook.html
Macro BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT\3



Macro BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT
BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT — For exposing in classes that inherit from
      proto::extends&lt;&gt;
      the overloaded assignment operators defined therein. Unlike the
      BOOST_PROTO_EXTENDS_USING_ASSIGN() macro,
      BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT() is for use in non-dependent
      contexts.
      

Synopsis
// In header: &lt;boost/proto/extends.hpp&gt;

BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT(Derived)

Description

        The standard usage of
        proto::extends&lt;&gt;
        is to define a class template that inherits from it. The derived class template automatically gets a
        compiler-generated assignment operator that hides the ones defined in
        proto::extends&lt;&gt;.
        Using BOOST_PROTO_EXTENDS_USING_ASSIGN() in the derived class solves this problem.
      

        However, if the expression extension is an ordinary class and not a class template, the usage of
        BOOST_PROTO_EXTENDS_USING_ASSIGN() is in a so-called non-dependent context. In plain English,
        it means it is illegal to use typename in some places where it is required in a class template. 
        In those cases, you should use BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT() instead.
      

		See also:
		

proto::extends&lt;&gt;
BOOST_PROTO_EXTENDS_USING_ASSIGN()


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_10_9.html
Macro BOOST_PFR_NOT_SUPPORTED\3



Macro BOOST_PFR_NOT_SUPPORTED











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_NOT_SUPPORTED
BOOST_PFR_NOT_SUPPORTED

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_NOT_SUPPORTED

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_NOT_SUPPORTED.html
Macro BOOST_PFR_CORE_NAME_ENABLED\3



Macro BOOST_PFR_CORE_NAME_ENABLED











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_CORE_NAME_ENABLED
BOOST_PFR_CORE_NAME_ENABLED

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_CORE_NAME_ENABLED

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_CORE_NAM_idm2553.html
Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT\3



Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT











Home
Libraries
People
FAQ
More








Macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT
BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT — Indicates absence of support for specifying the bounded types
        of a variant by the elements of a
        type sequence.

Synopsis
// In header: &lt;boost/variant/variant_fwd.hpp&gt;

BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT

Description
Defined only if
        make_variant_over and
        make_recursive_variant_over
        are not supported for some reason on the target compiler.


Copyright © 2002, 2003 Eric Friedman, Itay MamanCopyright © 2014-2023 Antony PolukhinDistributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at 
    http://www.boost.org/LICENSE_1_0.txt)
    







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_VARIANT_1_3_44_5_3_5.html
Macro BOOST_RV_REF_END\3



Macro BOOST_RV_REF_END











Home
Libraries
People
FAQ
More








Macro BOOST_RV_REF_END
BOOST_RV_REF_END

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_RV_REF_END

Description
This macro is used to achieve portable syntax in move constructors and assignments for template classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE. As macros have problems with comma-separated template arguments, the template argument must be preceded with BOOST_RV_REF_BEG and ended with BOOST_RV_REF_END 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_RV_REF_END.html
Macro BOOST_STL_INTERFACES_USE_CONCEPTS\3



Macro BOOST_STL_INTERFACES_USE_CONCEPTS











Home
Libraries
People
FAQ
More








Macro BOOST_STL_INTERFACES_USE_CONCEPTS
BOOST_STL_INTERFACES_USE_CONCEPTS

Synopsis
// In header: &lt;boost/stl_interfaces/config.hpp&gt;

BOOST_STL_INTERFACES_USE_CONCEPTS

Copyright © 2019 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_STL__1_3_38_15_2_2_1.html
Concept ForwardIterator\3



Concept ForwardIterator











Home
Libraries
People
FAQ
More








Concept ForwardIterator
ForwardIterator


Description
A forward iterator is an iterator that can read through a sequence of
  values.  It is multi-pass (old values of the iterator can be
  re-used), and can be either mutable (data pointed to by it can be
  changed) or not mutable.
An iterator represents a position in a sequence.  Therefore, the
  iterator can point into the sequence (returning a value when dereferenced
  and being incrementable), or be off-the-end (and not dereferenceable or
  incrementable).


Refinement of

InputIterator
OutputIterator



Associated types


value_type
std::iterator_traits&lt;Iter&gt;::value_type
The value type of the iterator


category
std::iterator_traits&lt;Iter&gt;::iterator_category
The category of the iterator




Notation

Iter
A type playing the role of iterator-type in the ForwardIterator concept.

i, j

Objects of type Iter
x
Object of type value_type



Type expressions

Category tag
category must be
                  derived from std::forward_iterator_tag.
                



Valid expressions










Name
Expression
Type
Precondition
Semantics
Postcondition



Dereference
*i
const-if-not-mutable value_type &amp;
i is incrementable (not
    off-the-end)
 
 


Member access
i-&gt;{member-name} (return type is pointer-to-object type)
const-if-not-mutable value_type *
i is incrementable (not
    off-the-end)
 
 


Preincrement
++i
Iter &amp;
i is incrementable (not
    off-the-end)
 
 


Postincrement
i++
Iter
i is incrementable (not
    off-the-end)
Equivalent to {Iter j = i; ++i; return j;}
i is dereferenceable or
    off-the-end





Complexity

  All iterator operations must take amortized constant time.
  


Invariants

Predecrement must return object

  &amp;i = &amp;(++i)
  
Unique path through sequence

  i == j implies ++i == ++j
  



Models

T *
std::hash_set&lt;T&gt;::iterator



Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/ForwardIterator.html
Macro BOOST_CRC_OPTIMAL_NAME\3



Macro BOOST_CRC_OPTIMAL_NAME











Home
Libraries
People
FAQ
More








Macro BOOST_CRC_OPTIMAL_NAME
BOOST_CRC_OPTIMAL_NAME

Synopsis
// In header: &lt;boost/crc.hpp&gt;

BOOST_CRC_OPTIMAL_NAME

Copyright © 2001, 2003, 2012 Daryle Walker
        Distributed under the Boost Software License, Version 1.0. (See the accompanying
        file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_CRC_OPTIMAL_NAME.html
Macro BOOST_MOVE_BASE\3



Macro BOOST_MOVE_BASE











Home
Libraries
People
FAQ
More








Macro BOOST_MOVE_BASE
BOOST_MOVE_BASE — defined(BOOST_MOVE_MSVC_AUTO_MOVE_RETURN_BUG) || defined(BOOST_MOVE_DOXYGEN_INVOKED) 

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_MOVE_BASE(BASE_TYPE, ARG)

Description
This macro is used to achieve portable optimal move constructors.
When implementing the move constructor, in C++03 compilers the moved-from argument must be cast to the base type before calling boost::move() due to rvalue reference limitations.
In C++11 compilers the cast from a rvalue reference of a derived type to a rvalue reference of a base type is implicit. 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MOVE_BASE.html
Macro BOOST_YAP_USER_SUBSCRIPT_OPERATOR\3



Macro BOOST_YAP_USER_SUBSCRIPT_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_SUBSCRIPT_OPERATOR
BOOST_YAP_USER_SUBSCRIPT_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_SUBSCRIPT_OPERATOR(expr_template)

Description
Defines operator overloads for operator[]() that each produce an expression instantiated from the expr_template expression template. One overload is defined for each of the qualifiers const &amp;, &amp;, and &amp;&amp;. For the lvalue reference overloads, *this is captured by reference into the resulting expression. For the rvalue reference overload, *this is moved into the resulting expression.
The rhs parameter to each of the defined overloads may be any type, including an expression, except that the overloads are constrained by std::enable_if&lt;&gt; not to conflict with the assignment and move assignement operators. If rhs is a non-expression, it is wrapped in a terminal expression.
Example: 









Parameters:






expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate. 






Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_4.html
Macro BOOST_VARIANT_ENUM_PARAMS\3



Macro BOOST_VARIANT_ENUM_PARAMS











Home
Libraries
People
FAQ
More








Macro BOOST_VARIANT_ENUM_PARAMS
BOOST_VARIANT_ENUM_PARAMS — Enumerate parameters for use with
        variant.

Synopsis
// In header: &lt;boost/variant/variant_fwd.hpp&gt;

BOOST_VARIANT_ENUM_PARAMS(param)

Description
 Expands to variadic template list in the following manner:
        
            BOOST_VARIANT_ENUM_PARAMS(T)                    =&gt; T0, TN...
            BOOST_VARIANT_ENUM_PARAMS(class T)              =&gt; class T0, class... TN
            BOOST_VARIANT_ENUM_PARAMS(class Something)      =&gt; class Something0, class... SomethingN
            BOOST_VARIANT_ENUM_PARAMS(typename Something)   =&gt; typename Something0, typename... SomethingN
            BOOST_VARIANT_ENUM_PARAMS(Something)            =&gt; Something0, SomethingN...
            BOOST_VARIANT_ENUM_PARAMS(Something)            =&gt; Something0, SomethingN...
        
      

        Otherwise expands to a comma-separated sequence of length
        BOOST_VARIANT_LIMIT_TYPES, where
        each element in the sequence consists of the concatenation of
        param with its zero-based index into the
        sequence. That is,
        param ## 0, param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1.
Rationale: This macro greatly
        simplifies for the user the process of declaring
        variant types
        in function templates or explicit partial specializations of class
        templates, as shown in the
        tutorial.


Copyright © 2002, 2003 Eric Friedman, Itay MamanCopyright © 2014-2023 Antony PolukhinDistributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at 
    http://www.boost.org/LICENSE_1_0.txt)
    







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_VARIANT_ENUM_PARAMS.html
Macro BOOST_TYPE_INDEX_NO_BASE_CLASS\3



Macro BOOST_TYPE_INDEX_NO_BASE_CLASS











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_NO_BASE_CLASS
BOOST_TYPE_INDEX_NO_BASE_CLASS — Instructs BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS and BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST that this class has no base classes. 

Synopsis
// In header: &lt;boost/type_index/runtime_cast/register_runtime_class.hpp&gt;

BOOST_TYPE_INDEX_NO_BASE_CLASS

Description
&lt;xrefsect&gt;&lt;xreftitle&gt;Deprecated&lt;/xreftitle&gt;&lt;xrefdescription&gt;Just remove and use BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS() or BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST() 
&lt;/xrefdescription&gt;&lt;/xrefsect&gt;


Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_8_5.html
Macro BOOST_DLL_FORCE_ALIAS_INSTANTIATION\3



Macro BOOST_DLL_FORCE_ALIAS_INSTANTIATION











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_FORCE_ALIAS_INSTANTIATION
BOOST_DLL_FORCE_ALIAS_INSTANTIATION

Synopsis
// In header: &lt;boost/dll/alias.hpp&gt;

BOOST_DLL_FORCE_ALIAS_INSTANTIATION

Description
Define this macro to explicitly specify translation unit in which alias must be instantiated. See section 'Limitations' for more info. You may find usage examples in source codes of almost each tutorial. Must be used in code, when  BOOST_DLL_FORCE_NO_WEAK_EXPORTS is defined 


Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_FORCE_AL_idm4164.html
Macro BOOST_PROTO_ASSERT_MATCHES_NOT\3



Macro BOOST_PROTO_ASSERT_MATCHES_NOT











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_ASSERT_MATCHES_NOT
BOOST_PROTO_ASSERT_MATCHES_NOT — 
      Assert at compile time that a particular expression
      does not match the specified grammar.
    

Synopsis
// In header: &lt;boost/proto/debug.hpp&gt;

BOOST_PROTO_ASSERT_MATCHES_NOT(expr, Grammar)

Description

        Use BOOST_PROTO_ASSERT_MATCHES_NOT() to assert at compile-time that
        an expression does not match a grammar. 
      

        Example:
typedef proto::plus&lt; proto::terminal&lt; int &gt;, proto::terminal&lt; int &gt; &gt; PlusInts;

BOOST_PROTO_ASSERT_MATCHES_NOT( proto::lit("a string") + 42, PlusInts );

      

        See also:
        

proto::assert_matches()
proto::assert_matches_not()
BOOST_PROTO_ASSERT_MATCHES()


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_A_1_3_32_5_5_4.html
Macro BOOST_UNITS_STATIC_CONSTANT\3



Macro BOOST_UNITS_STATIC_CONSTANT











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_STATIC_CONSTANT
BOOST_UNITS_STATIC_CONSTANT

Synopsis
// In header: &lt;boost/units/static_constant.hpp&gt;

BOOST_UNITS_STATIC_CONSTANT(name, type)

Description
A convenience macro that allows definition of static constants in headers in an ODR-safe way. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNI_1_3_43_10_2_40_1.html
Macro BOOST_PROTO_AUTO\3



Macro BOOST_PROTO_AUTO











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_AUTO
BOOST_PROTO_AUTO — For defining a local variable that stores a Proto expression template,
      deep-copying the expression so there are no dangling references.

Synopsis
// In header: &lt;boost/proto/proto_typeof.hpp&gt;

BOOST_PROTO_AUTO(Var, Expr)

Description

        To define a local variable ex that stores the expression
        proto::lit(1) + 2,
        do the following:
BOOST_PROTO_AUTO( ex, proto::lit(1) + 2 );
.
        The above is equivalent to the following:
        
BOOST_AUTO( ex, proto::deep_copy( proto::lit(1) + 2 ) );

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_AUTO.html
Concept LessThanComparable\3



Concept LessThanComparable











Home
Libraries
People
FAQ
More








Concept LessThanComparable
LessThanComparable


Description
LessThanComparable types must have &lt;,
  &gt;, &lt;=, and &gt;=
  operators.


Notation

X
A type playing the role of comparable-type in the LessThanComparable concept.

x, y

Objects of type X



Valid expressions








Name
Expression
Type
Semantics



Less than
x &lt; y
Convertible to bool
Determine if one value is less than another.


Less than or equal
x &lt;= y
Convertible to bool
Determine if one value is less than or equal to another.


Greater than
x &gt; y
Convertible to bool
Determine if one value is greater than another.


Greater than or equal to
x &gt;= y
Convertible to bool
Determine if one value is greater than or equal to another.





Models
int


Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/LessThanComparable.html
Macro BOOST_MPI_BCAST_BOTTOM_WORKS_FINE\3



Macro BOOST_MPI_BCAST_BOTTOM_WORKS_FINE











Home
Libraries
People
FAQ
More








Macro BOOST_MPI_BCAST_BOTTOM_WORKS_FINE
BOOST_MPI_BCAST_BOTTOM_WORKS_FINE — Indicates that MPI_Bcast supports MPI_BOTTOM. 

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

BOOST_MPI_BCAST_BOTTOM_WORKS_FINE

Description
Some implementations have a broken MPI_Bcast wrt to MPI_BOTTOM. BullX MPI and LAM seems to be among them, at least for some versions. The broacast_test.cpp test test_skeleton_and_content can be used to detect that. 


Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MPI_BCA_1_3_25_7_7_8.html
Macro OMPI_SKIP_MPICXX\3



Macro OMPI_SKIP_MPICXX











Home
Libraries
People
FAQ
More








Macro OMPI_SKIP_MPICXX
OMPI_SKIP_MPICXX

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

OMPI_SKIP_MPICXX

Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/OMPI_SKIP_MPICXX.html
Redirect to generated documentation\3

  
  

      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt) --
    Redirect to generated documentation
    
  
  
    Automatic redirection failed, please go to
    ../../libs/core/doc/html/core/ref.html
  

\3https://www.boost.org/doc/libs/1_84_0/doc/html/ref.html
Macro BOOST_PROTO_ASSERT_MATCHES\3



Macro BOOST_PROTO_ASSERT_MATCHES











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_ASSERT_MATCHES
BOOST_PROTO_ASSERT_MATCHES — 
      Assert at compile time that a particular expression
      matches the specified grammar.
    

Synopsis
// In header: &lt;boost/proto/debug.hpp&gt;

BOOST_PROTO_ASSERT_MATCHES(expr, Grammar)

Description

        Use BOOST_PROTO_ASSERT_MATCHES() to assert at compile-time that
        an expression matches a grammar.
      

        Example:
typedef proto::plus&lt; proto::terminal&lt; int &gt;, proto::terminal&lt; int &gt; &gt; PlusInts;

BOOST_PROTO_ASSERT_MATCHES( proto::lit(1) + 42, PlusInts );

      

        See also:
        

proto::assert_matches()
proto::assert_matches_not()
BOOST_PROTO_ASSERT_MATCHES_NOT()


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_ASSERT_MATCHES.html
Chapter 24. Boost.MPI\3



Chapter 24. Boost.MPI











Home
Libraries
People
FAQ
More








Chapter 24. Boost.MPI

Douglas Gregor


Matthias Troyer

Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      



Table of Contents

Introduction
Getting started

MPI Implementation
Configure and Build
Using Boost.MPI

Tutorial

Point-to-Point communication
Collective operations
User-defined data types
Communicators
Threads
Separating structure
      from content
Performance optimizations

Mapping from C MPI to Boost.MPI
Reference

Header &lt;boost/mpi.hpp&gt;
Header &lt;boost/mpi/allocator.hpp&gt;
Header &lt;boost/mpi/cartesian_communicator.hpp&gt;
Header &lt;boost/mpi/collectives.hpp&gt;
Header &lt;boost/mpi/collectives_fwd.hpp&gt;
Header &lt;boost/mpi/communicator.hpp&gt;
Header &lt;boost/mpi/config.hpp&gt;
Header &lt;boost/mpi/datatype.hpp&gt;
Header &lt;boost/mpi/datatype_fwd.hpp&gt;
Header &lt;boost/mpi/environment.hpp&gt;
Header &lt;boost/mpi/exception.hpp&gt;
Header &lt;boost/mpi/graph_communicator.hpp&gt;
Header &lt;boost/mpi/group.hpp&gt;
Header &lt;boost/mpi/inplace.hpp&gt;
Header &lt;boost/mpi/intercommunicator.hpp&gt;
Header &lt;boost/mpi/nonblocking.hpp&gt;
Header &lt;boost/mpi/operations.hpp&gt;
Header &lt;boost/mpi/packed_iarchive.hpp&gt;
Header &lt;boost/mpi/packed_oarchive.hpp&gt;
Header &lt;boost/mpi/python.hpp&gt;
Header &lt;boost/mpi/request.hpp&gt;
Header &lt;boost/mpi/skeleton_and_content.hpp&gt;
Header &lt;boost/mpi/skeleton_and_content_fwd.hpp&gt;
Header &lt;boost/mpi/status.hpp&gt;
Header &lt;boost/mpi/timer.hpp&gt;

Python Bindings

Quickstart
Transmitting User-Defined Data
Collectives
Skeleton/Content Mechanism
C++/Python MPI Compatibility
Reference

Design Philosophy
Performance Evaluation
Revision History
Acknowledgments




Introduction


      Boost.MPI is a library for message passing in high-performance parallel applications.
      A Boost.MPI program is one or more processes that can communicate either via
      sending and receiving individual messages (point-to-point communication) or
      by coordinating as a group (collective communication). Unlike communication
      in threaded environments or using a shared-memory library, Boost.MPI processes
      can be spread across many different machines, possibly with different operating
      systems and underlying architectures.
    

      Boost.MPI is not a completely new parallel programming library. Rather, it
      is a C++-friendly interface to the standard Message Passing Interface (MPI), the most popular library
      interface for high-performance, distributed computing. MPI defines a library
      interface, available from C, Fortran, and C++, for which there are many MPI implementations.
      Although there exist C++ bindings for MPI, they offer little functionality
      over the C bindings. The Boost.MPI library provides an alternative C++ interface
      to MPI that better supports modern C++ development styles, including complete
      support for user-defined data types and C++ Standard Library types, arbitrary
      function objects for collective algorithms, and the use of modern C++ library
      techniques to maintain maximal efficiency.
    

      At present, Boost.MPI supports the majority of functionality in MPI 1.1. The
      thin abstractions in Boost.MPI allow one to easily combine it with calls to
      the underlying C MPI library. Boost.MPI currently supports:
    


          Communicators: Boost.MPI supports the creation, destruction, cloning, and
          splitting of MPI communicators, along with manipulation of process groups.
        

          Point-to-point communication: Boost.MPI supports point-to-point communication
          of primitive and user-defined data types with send and receive operations,
          with blocking and non-blocking interfaces.
        

          Collective communication: Boost.MPI supports collective operations such
          as reduce
          and gather
          with both built-in and user-defined data types and function objects.
        

          MPI Datatypes: Boost.MPI can build MPI data types for user-defined types
          using the Boost.Serialization
          library.
        

          Separating structure from content: Boost.MPI can transfer the shape (or
          "skeleton") of complex data structures (lists, maps, etc.) and
          then separately transfer their content. This facility optimizes for cases
          where the data within a large, static data structure needs to be transmitted
          many times.
        


      Boost.MPI can be accessed either through its native C++ bindings, or through
      its alternative, Python interface.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/mpi.html
Concept OutputIterator\3



Concept OutputIterator











Home
Libraries
People
FAQ
More








Concept OutputIterator
OutputIterator


Description
An output iterator is an iterator that can write a sequence of
  values.  It is single-pass (old values of the iterator cannot be
  re-used), and write-only.
An output iterator represents a position in a (possibly infinite)
  sequence.  Therefore, the iterator can point into the sequence (returning
  a value when dereferenced and being incrementable), or be off-the-end
  (and not dereferenceable or incrementable).


Associated types


value_type
std::iterator_traits&lt;Iter&gt;::value_type
The stated value type of the iterator (should be
    void for an output iterator that does not model some other
    iterator concept).


difference_type
std::iterator_traits&lt;Iter&gt;::difference_type
The difference type of the iterator


category
std::iterator_traits&lt;Iter&gt;::iterator_category
The category of the iterator




Notation

Iter
A type playing the role of iterator-type in the OutputIterator concept.
ValueType
A type playing the role of value-type in the OutputIterator concept.

i, j

Objects of type Iter
x
Object of type ValueType



Type expressions


The type Iter must be a model of Assignable.

The type ValueType must be a model of Assignable.

The type Iter must be a model of DefaultConstructible.

The type Iter must be a model of
  EqualityComparable.
Category tag
category must be
                  derived from std::output_iterator_tag,  a model  of DefaultConstructible,  and  a model  of CopyConstructible.
                
Difference type properties
difference_type must be
                   a model  of SignedInteger.
                



Valid expressions










Name
Expression
Type
Precondition
Semantics
Postcondition



Dereference
*i

i is incrementable (not
    off-the-end)
 
 


Dereference and assign
*i = x

i is incrementable (not
    off-the-end)
 
*i may not be written to again until it has
    been incremented.


Preincrement
++i
Iter &amp;
i is incrementable (not
    off-the-end)
 
 


Postincrement
i++

i is incrementable (not
    off-the-end)
Equivalent to (void)(++i)
i is dereferenceable or
    off-the-end


Postincrement, dereference, and assign
*i++ = x

i is incrementable (not
    off-the-end)
Equivalent to {*i = t; ++i;}
i is dereferenceable or
    off-the-end





Complexity

  All iterator operations must take amortized constant time.
  


Models

std::ostream_iterator, ...
std::insert_iterator, ...
std::front_insert_iterator, ...
std::back_insert_iterator, ...



Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/OutputIterator.html
Macro BOOST_TRIBOOL_THIRD_STATE\3



Macro BOOST_TRIBOOL_THIRD_STATE











Home
Libraries
People
FAQ
More








Macro BOOST_TRIBOOL_THIRD_STATE
BOOST_TRIBOOL_THIRD_STATE — Declare a new name for the third state of a tribool. 

Synopsis
// In header: &lt;boost/logic/tribool.hpp&gt;

BOOST_TRIBOOL_THIRD_STATE(Name)

Description
Use this macro to declare a new name for the third state of a tribool. This state can have any number of new names (in addition to indeterminate), all of which will be equivalent. The new name will be placed in the namespace in which the macro is expanded.
Example: BOOST_TRIBOOL_THIRD_STATE(true_or_false)
tribool x(true_or_false); // potentially set x if (true_or_false(x)) { // don't know what x is } 


Copyright © 2002-2004 Douglas GregorUse, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TRIBOOL_THIRD_STATE.html
Macro BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY\3



Macro BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY
BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY

Synopsis
// In header: &lt;boost/units/config.hpp&gt;

BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY

Description
If defined will trigger a static assertion if quantity&lt;Unit, T&gt; is not layout compatible with T 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_6_1.html
Macro BOOST_PFR_ENABLED\3



Macro BOOST_PFR_ENABLED











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_ENABLED
BOOST_PFR_ENABLED

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_ENABLED

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_ENABLED.html
Macro BOOST_XPRESSIVE_HAS_MS_STACK_GUARD\3



Macro BOOST_XPRESSIVE_HAS_MS_STACK_GUARD











Home
Libraries
People
FAQ
More








Macro BOOST_XPRESSIVE_HAS_MS_STACK_GUARD
BOOST_XPRESSIVE_HAS_MS_STACK_GUARD

Synopsis
// In header: &lt;boost/xpressive/xpressive_fwd.hpp&gt;

BOOST_XPRESSIVE_HAS_MS_STACK_GUARD

Copyright © 2007 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_XPRESS_1_3_45_5_18_3.html
Chapter 1. Boost.Accumulators\3



Chapter 1. Boost.Accumulators











Home
Libraries
People
FAQ
More








Chapter 1. Boost.Accumulators

Eric Niebler

Copyright © 2005, 2006 Eric Niebler


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Preface
User's Guide

The
      Accumulators Framework
The
      Statistical Accumulators Library

Acknowledgements
Reference

Accumulators Framework Reference
Statistics Library Reference
Numeric Operators Library Reference





Preface


        “It is better to be approximately right than exactly wrong.”
        -- Old adage
      


      Description
    

      Boost.Accumulators is both a library for incremental statistical computation
      as well as an extensible framework for incremental calculation in general.
      The library deals primarily with the concept of an accumulator,
      which is a primitive computational entity that accepts data one sample at a
      time and maintains some internal state. These accumulators may offload some
      of their computations on other accumulators, on which they depend. Accumulators
      are grouped within an accumulator set. Boost.Accumulators
      resolves the inter-dependencies between accumulators in a set and ensures that
      accumulators are processed in the proper order.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/accumulators.html
Macro BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST\3



Macro BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST











Home
Libraries
People
FAQ
More








Macro BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST
BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST

Synopsis
// In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;

BOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST(T)

Copyright © 2005, 2006 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_ACCUMU_1_3_2_6_2_3_4.html
Chapter 22. Boost.Metaparse\3



Chapter 22. Boost.Metaparse











Home
Libraries
People
FAQ
More








Chapter 22. Boost.Metaparse

Abel Sinkovics

Copyright © 2015 Abel Sinkovics


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Description
Related publications
    and blogs
Preface

Description
Scope
Advantages
      of using this library
Cost of using
      Metaparse
Supported platforms

Getting
    started with Boost.Metaparse

1.
      Introduction
2.
      The text to parse
3.
      Creating a simple parser
4.
      Parsing simple expressions
5.
      Parsing longer expressions
6.
      Adding support for other operators
7.
      Dealing with precedence
8.
      Dealing with associativity
9.
      Dealing with unary operators
10.
      Dealing with parens
11.
      Dealing with invalid input
12.
      Summary
Copy-paste
      friendly code examples
Definitions
      before each section

User manual

What is a parser
Parsing
      based on constexpr
What
      types of grammars can be used?

Versioning

Template classes
Macros

Performance

Benchmarks
      of BOOST_METAPARSE_STRING
Measuring printf
Further measurements

The design of the
    library
Design
      rationale
Reference

Parsers
      and combinators provided by the library
Compile-time
      data structures and values
String
Errors
Tags
Utilities
Terms
      used by the library
Alphabetical





Description


      Metaparse is a parser generator library for template metaprograms. The purpose
      of this library is to support the creation of parsers that parse at compile
      time. This library is intended to be used for embedded domain specific language
      creation for C++. The input of the generated parser is a compile time string,
      see string.
      The result of the parsing process is either an error or any other result the
      writer of the parser specifies.
    

      The library is similar to Boost.Spirit, however while parsers built with Spirit
      parse at run-time, parsers built with Metaparse parse at compile-time. Parsers
      built with Metaparse can output:
    


          types
        

          constant values
        

          objects (types with public static members)
        

          callable C++ functions (types with public static method)
        

          template metafunction classes
        


      See section What can be built from a compile-time
      string? for further details.
    

      Based on C++11 features the library can provide advanced utilities for defining
      the input string, the rest of the library works on C++98-based compilers as
      well. Note that if you build the tests and examples with Boost.Build using
      GCC or Clang, the compiler will not have C++11 (or newer) enabled. To build
      the tests and examples in C++11-mode, you need to run b2
      cxxflags="-std=c++11".
    

      An external tutorial can be found at https://github.com/sabel83/metaparse_tutorial#metaparse-tutorial
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/metaparse.html
Macro BOOST_MOVE_TO_LV\3



Macro BOOST_MOVE_TO_LV











Home
Libraries
People
FAQ
More








Macro BOOST_MOVE_TO_LV
BOOST_MOVE_TO_LV

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_MOVE_TO_LV(ARG)

Description
This macro is used to achieve portable optimal move constructors.
In C++03 mode, when accessing a member of type through a rvalue (implemented as a rv&lt;T&gt; &amp; type, where rv&lt;T&gt; derives from T) triggers a potential UB as the program never creates objects of type rv&lt;T&gt;. This macro casts back rv&lt;T&gt; to T&amp; so that access to member types are done through the original type.
In C++11 compilers the cast from a rvalue reference of a derived type to a rvalue reference of a base type is implicit, so it's a no-op. 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MOVE_TO_LV.html
Macro BOOST_STL_INTERFACES_NAMESPACE_V1\3



Macro BOOST_STL_INTERFACES_NAMESPACE_V1











Home
Libraries
People
FAQ
More








Macro BOOST_STL_INTERFACES_NAMESPACE_V1
BOOST_STL_INTERFACES_NAMESPACE_V1

Synopsis
// In header: &lt;boost/stl_interfaces/config.hpp&gt;

BOOST_STL_INTERFACES_NAMESPACE_V1

Copyright © 2019 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_STL__1_3_38_15_2_2_3.html
Macro BOOST_STL_INTERFACES_STATIC_ASSERT_ITERATOR_TRAITS\3



Macro BOOST_STL_INTERFACES_STATIC_ASSERT_ITERATOR_TRAITS











Home
Libraries
People
FAQ
More








Macro BOOST_STL_INTERFACES_STATIC_ASSERT_ITERATOR_TRAITS
BOOST_STL_INTERFACES_STATIC_ASSERT_ITERATOR_TRAITS

Synopsis
// In header: &lt;boost/stl_interfaces/iterator_interface.hpp&gt;

BOOST_STL_INTERFACES_STATIC_ASSERT_ITERATOR_TRAITS(iter, category, concept, value_type, reference, pointer, difference_type)

Description
static_asserts that the types of all typedefs in std::iterator_traits&lt;iter&gt; match the remaining macro parameters. This is useful for checking that an iterator you write using iterator_interface has the correct iterator traits.
For example: BOOST_STL_INTERFACES_STATIC_ASSERT_ITERATOR_TRAITS(my_iter, std::input_iterator_tag, std::input_iterator, int, int &amp;, int *, std::ptrdiff_t).



Note

This macro ignores the concept parameter when __cpp_lib_concepts is not defined. 





Copyright © 2019 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_STL__1_3_38_15_2_4_3.html
Chapter 16. Boost.Interprocess\3



Chapter 16. Boost.Interprocess











Home
Libraries
People
FAQ
More








Chapter 16. Boost.Interprocess

Ion Gaztanaga

Copyright © 2005-2015 Ion Gaztanaga


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction

Building
      Boost.Interprocess
Tested compilers

Quick Guide for the Impatient

Using shared
      memory as a pool of unnamed memory blocks
Creating
      named shared memory objects
Using an offset
      smart pointer for shared memory
Creating
      vectors in shared memory
Creating
      maps in shared memory

Some basic explanations

Processes
      And Threads
Sharing
      information between processes
Persistence
      Of Interprocess Mechanisms
Names Of
      Interprocess Mechanisms
Constructors,
      destructors and lifetime of Interprocess named resources
Permissions

Sharing memory
    between processes

Shared
      memory
Memory
      Mapped Files
More
      About Mapped Regions
Limitations
      When Constructing Objects In Mapped Regions

Mapping Address Independent Pointer:
    offset_ptr
Synchronization
    mechanisms

Synchronization
      mechanisms overview
Mutexes
Conditions
Semaphores
Sharable
      and Upgradable Mutexes
Lock
      Transfers Through Move Semantics
File
      Locks
Message
      Queue

Managed Memory Segments

Making
      Interprocess Data Communication Easy
Managed
      Shared Memory
Managed
      Mapped File
Managed
      Memory Segment Features
Managed
      Memory Segment Advanced Features
Managed
      Heap Memory And Managed External Buffer

Allocators, containers
    and memory allocation algorithms

Introduction
      to Interprocess allocators
Segregated
      storage node allocators
Adaptive
      pool node allocators
Interprocess
      and containers in managed memory segments
Boost
      containers compatible with Boost.Interprocess

Memory allocation algorithms

simple_seq_fit:
      A simple shared memory management algorithm
rbtree_best_fit:
      Best-fit logarithmic-time complexity allocation

Direct iostream formatting: vectorstream
    and bufferstream

Formatting directly
      in your character vector: vectorstream
Formatting directly
      in your character buffer: bufferstream

Ownership smart pointers

Intrusive
      pointer
Scoped
      pointer
Shared
      pointer and weak pointer
Unique
      pointer

Architecture and internals

Basic guidelines
From
      the memory algorithm to the managed segment
Allocators
      and containers
Performance of
      Boost.Interprocess

Customizing Boost.Interprocess

Writing
      a new shared memory allocation algorithm
Building
      custom STL compatible allocators for Boost.Interprocess
Building
      custom indexes

Acknowledgements,
    notes and links

Notes
      for Windows users
Notes
      for Linux users
Notes
      for FreeBSD users
Notes
      for MacOs users
Thanks
      to...
Release
      Notes
Books
      and interesting links
Future
      improvements...

Indexes and Reference

Indexes
Boost.Interprocess Header Reference





Introduction


Building
      Boost.Interprocess
Tested compilers


      Boost.Interprocess simplifies the use of common
      interprocess communication and synchronization mechanisms and offers a wide
      range of them:
    


          Shared memory.
        

          Memory-mapped files.
        

          Semaphores, mutexes, condition variables and upgradable mutex types to
          place them in shared memory and memory mapped files.
        

          Named versions of those synchronization objects, similar to UNIX/Windows
          sem_open/CreateSemaphore API.
        

          File locking.
        

          Relative pointers.
        

          Message queues.
        


      Boost.Interprocess also offers higher-level
      interprocess mechanisms to allocate dynamically portions of a shared memory
      or a memory mapped file (in general, to allocate portions of a fixed size memory
      segment). Using these mechanisms, Boost.Interprocess
      offers useful tools to construct C++ objects, including STL-like containers,
      in shared memory and memory mapped files:
    


          Dynamic creation of anonymous and named objects in a shared memory or memory
          mapped file.
        

          STL-like containers compatible with shared memory/memory-mapped files.
        

          STL-like allocators ready for shared memory/memory-mapped files implementing
          several memory allocation patterns (like pooling).
        



Building
      Boost.Interprocess


        There is no need to compile Boost.Interprocess,
        since it's a header only library. Just include your Boost header directory
        in your compiler include path.
      

        Boost.Interprocess depends on Boost.DateTime, which needs separate compilation.
        However, the subset used by Boost.Interprocess
        does not need any separate compilation so the user can define BOOST_DATE_TIME_NO_LIB to avoid Boost from
        trying to automatically link the Boost.DateTime.
      

        In POSIX systems, Boost.Interprocess uses
        pthread system calls to implement classes like mutexes, condition variables,
        etc... In some operating systems, these POSIX calls are implemented in separate
        libraries that are not automatically linked by the compiler. For example,
        in some Linux systems POSIX pthread functions are implemented in librt.a library, so you might need to add that
        library when linking an executable or shared library that uses Boost.Interprocess. If you obtain linking errors related
        to those pthread functions, please revise your system's documentation to
        know which library implements them.
      



Tested compilers


        Boost.Interprocess has been tested in the
        following compilers/platforms:
      


            Visual C++ &gt;= 7.1.
          

            GCC &gt;= 4.1.
          




Warning


          GCC &lt; 4.3 and MSVC &lt; 9.0 are deprecated and will be removed in the
          next version.
        











\3https://www.boost.org/doc/libs/1_84_0/doc/html/interprocess.html
Macro BOOST_PROTO_REPEAT_FROM_TO_EX\3



Macro BOOST_PROTO_REPEAT_FROM_TO_EX











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_REPEAT_FROM_TO_EX
BOOST_PROTO_REPEAT_FROM_TO_EX — Repeatedly invoke the specified macro.

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_REPEAT_FROM_TO_EX(FROM, TO, MACRO, typename_A, A, A_a, a)

Description

        BOOST_PROTO_REPEAT_FROM_TO_EX() is used to generate the kind of repetitive
        code that is typical of EDSLs built with Proto.
        BOOST_PROTO_REPEAT_FROM_TO_EX(FROM, TO, MACRO, typename_A, A, A_a, a)
        is equivalent to:
      

        
MACRO(FROM, typename_A, A, A_a, a)
MACRO(FROM+1, typename_A, A, A_a, a)
...
MACRO(TO-1, typename_A, A, A_a, a)

      

        Example:
      

        See BOOST_PROTO_REPEAT_FROM_TO().
      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_37_5.html
Macro BOOST_PFR_ENABLE_IMPLICIT_REFLECTION\3



Macro BOOST_PFR_ENABLE_IMPLICIT_REFLECTION











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_ENABLE_IMPLICIT_REFLECTION
BOOST_PFR_ENABLE_IMPLICIT_REFLECTION

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_ENABLE_IMPLICIT_REFLECTION

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_ENABLE_I_idm2552.html
Macro BOOST_IS_MPI_DATATYPE\3



Macro BOOST_IS_MPI_DATATYPE











Home
Libraries
People
FAQ
More








Macro BOOST_IS_MPI_DATATYPE
BOOST_IS_MPI_DATATYPE

Synopsis
// In header: &lt;boost/mpi/datatype.hpp&gt;

BOOST_IS_MPI_DATATYPE(T)

Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_IS_MPI_DATATYPE.html
Chapter 20. Boost.Lockfree\3



Chapter 20. Boost.Lockfree











Home
Libraries
People
FAQ
More








Chapter 20. Boost.Lockfree

Tim Blechmann

Copyright © 2008-2011 Tim
      Blechmann


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction &amp;
    Motivation
Examples
Rationale

Data Structures
Memory Management
ABA Prevention
Interprocess
      Support

Reference

Header &lt;boost/lockfree/policies.hpp&gt;
Header &lt;boost/lockfree/queue.hpp&gt;
Header &lt;boost/lockfree/spsc_queue.hpp&gt;
Header &lt;boost/lockfree/stack.hpp&gt;

Appendices

Supported
      Platforms &amp; Compilers
Future Developments
References





Introduction &amp;
    Motivation



      Introduction
      &amp; Terminology
    

      The term non-blocking denotes concurrent data
      structures, which do not use traditional synchronization primitives like guards
      to ensure thread-safety. Maurice Herlihy and Nir Shavit (compare "The
      Art of Multiprocessor Programming") distinguish between 3 types
      of non-blocking data structures, each having different properties:
    


          data structures are wait-free, if every
          concurrent operation is guaranteed to be finished in a finite number of
          steps. It is therefore possible to give worst-case guarantees for the number
          of operations.
        

          data structures are lock-free, if some
          concurrent operations are guaranteed to be finished in a finite number
          of steps. While it is in theory possible that some operations never make
          any progress, it is very unlikely to happen in practical applications.
        

          data structures are obstruction-free,
          if a concurrent operation is guaranteed to be finished in a finite number
          of steps, unless another concurrent operation interferes.
        


      Some data structures can only be implemented in a lock-free manner, if they
      are used under certain restrictions. The relevant aspects for the implementation
      of boost.lockfree are the number of producer and consumer
      threads. Single-producer (sp)
      or multiple producer (mp)
      means that only a single thread or multiple concurrent threads are allowed
      to add data to a data structure. Single-consumer
      (sc) or Multiple-consumer
      (mc) denote the equivalent for the removal
      of data from the data structure.
    


      Properties
      of Non-Blocking Data Structures
    

      Non-blocking data structures do not rely on locks and mutexes to ensure thread-safety.
      The synchronization is done completely in user-space without any direct interaction
      with the operating system [7]. This implies that they are not prone to issues like priority inversion
      (a low-priority thread needs to wait for a high-priority thread).
    

      Instead of relying on guards, non-blocking data structures require atomic operations (specific CPU instructions executed
      without interruption). This means that any thread either sees the state before
      or after the operation, but no intermediate state can be observed. Not all
      hardware supports the same set of atomic instructions. If it is not available
      in hardware, it can be emulated in software using guards. However this has
      the obvious drawback of losing the lock-free property.
    


      Performance
      of Non-Blocking Data Structures
    

      When discussing the performance of non-blocking data structures, one has to
      distinguish between amortized and worst-case costs. The definition of 'lock-free' and
      'wait-free' only mention the upper bound of an operation. Therefore lock-free
      data structures are not necessarily the best choice for every use case. In
      order to maximise the throughput of an application one should consider high-performance
      concurrent data structures [8].
    

      Lock-free data structures will be a better choice in order to optimize the
      latency of a system or to avoid priority inversion, which may be necessary
      in real-time applications. In general we advise to consider if lock-free data
      structures are necessary or if concurrent data structures are sufficient. In
      any case we advice to perform benchmarks with different data structures for
      a specific workload.
    


      Sources
      of Blocking Behavior
    

      Apart from locks and mutexes (which we are not using in boost.lockfree
      anyway), there are three other aspects, that could violate lock-freedom:
    



Atomic Operations

            Some architectures do not provide the necessary atomic operations in
            natively in hardware. If this is not the case, they are emulated in software
            using spinlocks, which by itself is blocking.
          
Memory Allocations

            Allocating memory from the operating system is not lock-free. This makes
            it impossible to implement true dynamically-sized non-blocking data structures.
            The node-based data structures of boost.lockfree use
            a memory pool to allocate the internal nodes. If this memory pool is
            exhausted, memory for new nodes has to be allocated from the operating
            system. However all data structures of boost.lockfree
            can be configured to avoid memory allocations (instead the specific calls
            will fail). This is especially useful for real-time systems that require
            lock-free memory allocations.
          
Exception Handling

            The C++ exception handling does not give any guarantees about its real-time
            behavior. We therefore do not encourage the use of exceptions and exception
            handling in lock-free code.
          




      Data
      Structures
    

      boost.lockfree implements three lock-free data structures:
    



boost::lockfree::queue

            a lock-free multi-producer/multi-consumer queue
          
boost::lockfree::stack

            a lock-free multi-producer/multi-consumer stack
          
boost::lockfree::spsc_queue

            a wait-free single-producer/single-consumer queue (commonly known as
            ringbuffer)
          




      Data
      Structure Configuration
    

      The data structures can be configured with Boost.Parameter-style
      templates:
    



boost::lockfree::fixed_sized

            Configures the data structure as fixed sized.
            The internal nodes are stored inside an array and they are addressed
            by array indexing. This limits the possible size of the queue to the
            number of elements that can be addressed by the index type (usually 2**16-2),
            but on platforms that lack double-width compare-and-exchange instructions,
            this is the best way to achieve lock-freedom.
          
boost::lockfree::capacity

            Sets the capacity of a data structure
            at compile-time. This implies that a data structure is fixed-sized.
          
boost::lockfree::allocator

            Defines the allocator. boost.lockfree supports stateful
            allocator and is compatible with Boost.Interprocess
            allocators.
          





[7] 
        Spinlocks do not directly interact with the operating system either. However
        it is possible that the owning thread is preempted by the operating system,
        which violates the lock-free property.
      
[8] 
        Intel's Thread Building
        Blocks library provides many efficient concurrent data structures,
        which are not necessarily lock-free.
      









\3https://www.boost.org/doc/libs/1_84_0/doc/html/lockfree.html
Chapter 11. Boost.Date_Time\3



Chapter 11. Boost.Date_Time











Home
Libraries
People
FAQ
More








Chapter 11. Boost.Date_Time

Jeff Garland

Copyright © 2001-2005 CrystalClear Software, Inc

Subject to the Boost Software License, Version 1.0. (See accompanying file
    LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)



Table of Contents

Conceptual

Motivation
Domain Concepts
Design Concepts

General Usage Examples
Gregorian

Date
Date Duration (aka Days)
Date Period
Date Iterators
Date Generators/Algorithms
Gregorian Calendar

Posix Time

Ptime
Time Duration
Time Period
Time Iterators

Local Time

Time Zone (abstract)
Posix Time Zone
Time Zone Database
Custom Time Zone
Local Date Time
Local Time Period

Date Time Input/Output

Format Flags
Date Facet
Date Input Facet
Time Facet
Time Input Facet
Date Time Formatter/Parser Objects
Date Time IO Tutorial

Serialization
Details

Calculations
Design Goals
Tradeoffs: Stability, Predictability, and Approximations
Terminology
References
Build-Compiler Information
Tests
Change History
Acknowledgements

Examples

Dates as Strings
Days Alive
Days Between New Years
Last Day of the Months
Localization Demonstration
Date Period Calculations
Print Holidays
Print Month
Month Adding
Time Math
Print Hours
Local to UTC Conversion
Time Periods
Simple Time Zones
Daylight Savings Calc Rules
Flight Time Example
Seconds Since Epoch

Library Reference

Date Time Reference
Gregorian Reference
Posix Time Reference
Local Time Reference




Introduction

    A set of date-time libraries based on generic programming concepts.
  
This documentation is also available in PDF format. It can be found at:
    
http://www.crystalclearsoftware.com/libraries/date_time/date_time.pdf

    In addition, a full doxygen reference can be found at:
    
http://www.crystalclearsoftware.com/libraries/date_time/ref_guide/index.html

    The most current version of the documentation can be found at:
    
http://www.crystalclearsoftware.com/libraries/date_time/index.html

  


Conceptual

Motivation
Domain Concepts
Design Concepts



Motivation

    The motivation for this library comes from working with and helping build several date-time libraries on several projects. Date-time libraries provide fundamental infrastructure for most development projects. However, most of them have limitations in their ability to calculate, format, convert, or perform some other functionality. For example, most libraries do not correctly handle leap seconds, provide concepts such as infinity, or provide the ability to use high resolution or network time sources.  These libraries also tend to be rigid in their representation of dates and times. Thus customized policies for a project or subproject are not possible.
  

    Programming with dates and times should be almost as simple and natural as programming with strings and integers.  Applications with lots of temporal logic can be radically simplified by having a robust set of operators and calculation capabilities. Classes should provide the ability to compare dates and times, add lengths or time durations, retrieve dates and times from  clocks, and work naturally with date and time intervals.
  

    Another motivation for development of the library was to apply modern C++ library design techniques to the date-time domain.  Really to build a framework for the construction of building temporal types. For example, by providing iterators and traits classes to control fundamental properties of the library. To the authors knowledge this library is the only substantial attempt to apply modern C++ to a date-time library.
  



Domain Concepts

    The date time domain is rich in terminology and problems. 
    The following is a brief introduction to the concepts you 
    will find reflected in the library. 
  

    The library supports 3 basic temporal types:
    


Time Point -- Specifier 
	for a location in the time continuum.
      

Time Duration -- A 
	length of time unattached to any point on the time continuum.
      

Time Interval -- A duration 
	of time attached to a specific point in the time continuum. 
	Also known as a time period. 
      


  

    Each of these temporal types has a Resolution which is defined by the smallest representable duration. A Time system provides all these categories of temporal types as well as the rules for labeling and calculating with time points. Calendar Systems are simply time systems with a maximum resolution of one day. The Gregorian system is the most widely used calendar system today (the ISO system is basically a derivative of this). However, there are many other calendar systems as well. UTC (Coordinated Universal Time) is a widely used civil time system. UTC is adjusted for earth rotation at longitude 0 by the use of leap seconds (This is not predictable, only as necessary). Most local time systems are based on UTC but are also adjusted for earth rotation so that daylight hours are similar everywhere. In addition, some local times include daylight savings time (DST) adjustments to shift the daylight hours during the summer.
  

    A Clock Device is software component (tied to some hardware) that provides the current date or time with respect to a time system. A clock can measure the current time to a known resolution which may be higher or lower than a particular time representation. 
  

    The library provides support for calculating with dates and times. However, time calculations are not quite the same as calculating with integers. If you are serious about the accuracy of your time calculations need to read about Stability, Predictability, and Approximations. 
  

    

Basic Terminology
Calculations
Stability, Predictability, and Approximations
References


  



Design Concepts

    A large part of the genesis of this library has been the observation that few date-time libraries are built in a fashion that allows customization and extension. A typical example, the calendar logic is built directly into the date class. Or the clock retrieval functions are built directly into the time class. These design decisions usually make it impossible to extend or change the library behavior. At a more fundamental level, there are usually assumptions about the resolution of time representation or the gregorian calendar. 
  

    Often times, the result is that a project must settle for a less than complete library because of a requirement for high resolution time representation or other assumptions that do not match the implementation of the library. This is extremely unfortunate because development of a library of this sort is far from a trivial task. 
  

    While the design is far from perfect the current design is far more flexible than any date-time library the author is aware of. It is expected that the various aspects of extensibility will be better documented in future versions. Information about the design goals of the library is summarized here. 
  










\3https://www.boost.org/doc/libs/1_84_0/doc/html/date_time.html
Macro BOOST_YAP_USER_UDT_UNARY_OPERATOR\3



Macro BOOST_YAP_USER_UDT_UNARY_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_UDT_UNARY_OPERATOR
BOOST_YAP_USER_UDT_UNARY_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_UDT_UNARY_OPERATOR(op_name, expr_template, udt_trait)

Description
Defines a free/non-member operator overload for unary operator op_name that produces an expression instantiated from the expr_template expression template.
The parameter to the defined operator overload may be any type that is not an expression and for which 
udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value 

 is true. The parameter is wrapped in a terminal expression.
Example: 









Parameters:







expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate.


op_name
The operator to be overloaded; this must be one of the unary enumerators in expr_kind, without the expr_kind:: qualification.


udt_trait
A trait template to use to constrain which types are accepted as template parameters to the defined operator overload. 







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_9.html
Macro BOOST_PROTO_A_ref\3



Macro BOOST_PROTO_A_ref











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_A_ref
BOOST_PROTO_A_ref — 
      Generates sequences like
      
        A0 &amp;,
        A1 &amp;, …
        AN-1 &amp;
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_A_ref(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_A_ref(N) generates sequences like:
      

        
A0 &amp;, A1 &amp;, … AN-1 &amp;

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_A_ref.html
Redirect to generated documentation\3

  
  

      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt) --
    Redirect to generated documentation
    
  
  
    Automatic redirection failed, please go to
    http://www.boost.org/doc/libs/master/doc/html/hash.html
  

\3https://www.boost.org/doc/libs/1_84_0/doc/html/hash.html
Chapter 17. Boost.Intrusive\3



Chapter 17. Boost.Intrusive











Home
Libraries
People
FAQ
More








Chapter 17. Boost.Intrusive

Olaf Krzikalla


Ion Gaztanaga

Copyright © 2005 Olaf Krzikalla
Copyright © 2006-2015 Ion Gaztanaga


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction

Presenting
      Boost.Intrusive
Building
      Boost.Intrusive
Tested compilers

Intrusive and non-intrusive
    containers

Differences
      between intrusive and non-intrusive containers
Properties
      of Boost.Intrusive containers

How to use Boost.Intrusive

Using base hooks
Using member hooks
Using both hooks
Object lifetime

When to use?
Concept summary
Presenting Boost.Intrusive
    containers
Safe hooks

Features of the safe mode
Configuring safe-mode
      assertions

Auto-unlink hooks

What's
      an auto-unlink hook?
Auto-unlink
      hook example
Auto-unlink
      hooks and containers with constant-time size()

Intrusive singly linked list: slist

slist hooks
slist container
Example

Intrusive doubly linked list: list

list hooks
list container
Example

Intrusive associative containers:
    set, multiset, rbtree

set, multiset
      and rbtree hooks
set,
      multiset and rbtree containers
Example

Semi-Intrusive
    unordered associative containers: unordered_set, unordered_multiset

unordered_set
      and unordered_multiset performance notes
unordered_set
      and unordered_multiset hooks
unordered_set
      and unordered_multiset containers
Example
Custom
      bucket traits

Map and multimap-like interface
    for associative containers
Intrusive avl tree based associative
    containers: avl_set, avl_multiset and avltree

avl_set,
      avl_multiset and avltree hooks
avl_set,
      avl_multiset and avltree containers
Example

Intrusive splay tree based
    associative containers: splay_set, splay_multiset and , splay_tree

Advantages
      and disadvantages of splay tree based containers
splay_set,
      splay_multiset and splaytree containers
Example

Intrusive scapegoat tree based
    associative containers: sg_set, sg_multiset and sgtree

sg_set,
      sg_multiset and sgtree containers
Example

Intrusive treap based associative
    containers: treap_set, treap_multiset and treap

treap_set,
      treap_multiset and treap containers
Exception
      safety of treap-based intrusive containers
Example

Binary search tree hooks: bs_set_base_hook
    and bs_set_member_hook
Advanced lookup
    and insertion functions for associative containers

Advanced
      lookups
Advanced
      insertions
Positional
      insertions

Erasing and disposing
    values from Boost.Intrusive containers
Cloning Boost.Intrusive containers
Using function hooks
Recursive Boost.Intrusive containers
Using smart pointers with
    Boost.Intrusive containers
Requirements
      for smart pointers compatible with Boost.Intrusive
Obtaining iterators
    from values
Any Hooks: A single hook for any Intrusive
    container
Concepts explained
Node algorithms with custom
    NodeTraits

Intrusive
      singly linked list algorithms
Intrusive
      doubly linked list algorithms
Intrusive
      red-black tree algorithms
Intrusive
      splay tree algorithms
Intrusive
      avl tree algorithms
Intrusive
      treap algorithms

Containers with custom ValueTraits

ValueTraits
      interface
Custom ValueTraits
      example
Reusing
      node algorithms for different values
Simplifying
      value traits definition
Stateful
      value traits

Thread safety guarantees
Boost.Intrusive Iterator
    features

Null
      forward iterators
Scary
      Iterators

Stability and insertion
    with hint in ordered associative containers with equivalent keys
Obtaining
    the same types and reducing symbol length
Design Notes

Boost.Intrusive
      in performance sensitive environments
Boost.Intrusive
      in space constrained environments
Boost.Intrusive
      as a basic building block
Extending
      Boost.Intrusive

Performance

Back
      insertion and destruction
Reversing
Sorting
Write
      access
Conclusions

Release Notes

Boost
      1.82 Release
Boost
      1.81 Release
Boost
      1.80 Release
Boost
      1.79 Release
Boost
      1.77 Release
Boost
      1.76 Release
Boost
      1.75 Release
Boost
      1.73 Release
Boost
      1.71 Release
Boost
      1.70 Release
Boost
      1.67 Release
Boost
      1.65 Release
Boost
      1.64 Release
Boost
      1.63 Release
Boost
      1.62 Release
Boost
      1.61 Release
Boost
      1.60 Release
Boost
      1.59 Release
Boost
      1.58 Release
Boost
      1.57 Release
Boost
      1.56 Release
Boost
      1.55 Release
Boost
      1.54 Release
Boost
      1.53 Release
Boost
      1.51 Release
Boost
      1.49 Release
Boost
      1.48 Release
Boost
      1.46 Release
Boost
      1.45 Release
Boost
      1.40 Release
Boost
      1.39 Release
Boost
      1.38 Release
Boost
      1.37 Release
Boost
      1.36 Release

References
Acknowledgements
Indexes
Reference

Header &lt;boost/intrusive/any_hook.hpp&gt;
Header &lt;boost/intrusive/avl_set.hpp&gt;
Header &lt;boost/intrusive/avl_set_hook.hpp&gt;
Header &lt;boost/intrusive/avltree.hpp&gt;
Header &lt;boost/intrusive/avltree_algorithms.hpp&gt;
Header &lt;boost/intrusive/bs_set.hpp&gt;
Header &lt;boost/intrusive/bs_set_hook.hpp&gt;
Header &lt;boost/intrusive/bstree.hpp&gt;
Header &lt;boost/intrusive/bstree_algorithms.hpp&gt;
Header &lt;boost/intrusive/circular_list_algorithms.hpp&gt;
Header &lt;boost/intrusive/circular_slist_algorithms.hpp&gt;
Header &lt;boost/intrusive/derivation_value_traits.hpp&gt;
Header &lt;boost/intrusive/hashtable.hpp&gt;
Header &lt;boost/intrusive/intrusive_fwd.hpp&gt;
Header &lt;boost/intrusive/linear_slist_algorithms.hpp&gt;
Header &lt;boost/intrusive/link_mode.hpp&gt;
Header &lt;boost/intrusive/list.hpp&gt;
Header &lt;boost/intrusive/list_hook.hpp&gt;
Header &lt;boost/intrusive/member_value_traits.hpp&gt;
Header &lt;boost/intrusive/options.hpp&gt;
Header &lt;boost/intrusive/pack_options.hpp&gt;
Header &lt;boost/intrusive/parent_from_member.hpp&gt;
Header &lt;boost/intrusive/pointer_plus_bits.hpp&gt;
Header &lt;boost/intrusive/pointer_rebind.hpp&gt;
Header &lt;boost/intrusive/pointer_traits.hpp&gt;
Header &lt;boost/intrusive/priority_compare.hpp&gt;
Header &lt;boost/intrusive/rbtree.hpp&gt;
Header &lt;boost/intrusive/rbtree_algorithms.hpp&gt;
Header &lt;boost/intrusive/set.hpp&gt;
Header &lt;boost/intrusive/set_hook.hpp&gt;
Header &lt;boost/intrusive/sg_set.hpp&gt;
Header &lt;boost/intrusive/sgtree.hpp&gt;
Header &lt;boost/intrusive/sgtree_algorithms.hpp&gt;
Header &lt;boost/intrusive/slist.hpp&gt;
Header &lt;boost/intrusive/slist_hook.hpp&gt;
Header &lt;boost/intrusive/splay_set.hpp&gt;
Header &lt;boost/intrusive/splaytree.hpp&gt;
Header &lt;boost/intrusive/splaytree_algorithms.hpp&gt;
Header &lt;boost/intrusive/treap.hpp&gt;
Header &lt;boost/intrusive/treap_algorithms.hpp&gt;
Header &lt;boost/intrusive/treap_set.hpp&gt;
Header &lt;boost/intrusive/trivial_value_traits.hpp&gt;
Header &lt;boost/intrusive/unordered_set.hpp&gt;
Header &lt;boost/intrusive/unordered_set_hook.hpp&gt;





Introduction


Presenting
      Boost.Intrusive
Building
      Boost.Intrusive
Tested compilers



Presenting
      Boost.Intrusive


        Boost.Intrusive is a library presenting
        some intrusive containers to the world of C++. Intrusive containers are special
        containers that offer better performance
        and exception safety guarantees than non-intrusive containers (like STL containers).
      

        The performance benefits of intrusive containers makes them ideal as a building
        block to efficiently construct complex containers like multi-index containers
        or to design high performance code like memory allocation algorithms.
      

        While intrusive containers were and are widely used in C, they became more
        and more forgotten in C++ due to the presence of the standard containers
        which don't support intrusive techniques.Boost.Intrusive
        wants to push intrusive containers usage encapsulating the implementation
        in STL-like interfaces. Hence anyone familiar with standard containers can
        easily use Boost.Intrusive.
      



Building
      Boost.Intrusive


        There is no need to compile anything to use Boost.Intrusive,
        since it's a header only library. Just include your Boost header directory
        in your compiler include path.
      



Tested compilers


        Boost.Intrusive has been tested on the following
        compilers/platforms:
      


            Visual C++ &gt;= 7.1.
          

            GCC &gt;= 4.1.
          




Warning


          GCC &lt; 4.3 and MSVC &lt; 9.0 are deprecated and will be removed in the
          next version.
        











\3https://www.boost.org/doc/libs/1_84_0/doc/html/intrusive.html
Macro BOOST_TYPE_ERASURE_MEMBER\3



Macro BOOST_TYPE_ERASURE_MEMBER











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_ERASURE_MEMBER
BOOST_TYPE_ERASURE_MEMBER — Defines a primitive concept for a member function. 

Synopsis
// In header: &lt;boost/type_erasure/member.hpp&gt;

BOOST_TYPE_ERASURE_MEMBER(concept_name, member)

Description

The declaration of the concept is 
template&lt;class Sig, class T = _self&gt;
struct concept_name;

 where Sig is a function type giving the signature of the member function, and T is the object type. T may be const-qualified for const member functions. concept_name&lt;R(A...) const, T&gt; is an alias for concept_name&lt;R(A...), const T&gt;.
This macro can only be used at namespace scope.
Example:
namespace boost {
BOOST_TYPE_ERASURE_MEMBER(push_back)
}
typedef boost::has_push_back&lt;void(int)&gt; push_back_concept;

The concept defined by this function may be specialized to provide a concept_map. The class object will be passed by reference as the first parameter.
template&lt;&gt;
struct has_push_back&lt;void(int), std::list&lt;int&gt; &gt; {
  static void apply(std::list&lt;int&gt;&amp; l, int i) { l.push_back(i); }
};

In C++03, the macro can only be used in the global namespace and is defined as:
#define BOOST_TYPE_ERASURE_MEMBER(qualified_name, member, N)

Example:
BOOST_TYPE_ERASURE_MEMBER((boost)(has_push_back), push_back, 1)
typedef boost::has_push_back&lt;void(int), _self&gt; push_back_concept;

For backwards compatibility, this form is always accepted. 






Parameters:







concept_name
is the name of the concept to declare. If it is omitted it defaults to has_ ## member 


member
is the name of the member function.







Copyright © 2011-2013 Steven Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_ERASURE_MEMBER.html
Macro BOOST_PROTO_DEFINE_OPERATORS\3



Macro BOOST_PROTO_DEFINE_OPERATORS











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_DEFINE_OPERATORS
BOOST_PROTO_DEFINE_OPERATORS — Defines a complete set of expression template-building operator overloads for use
      with non-Proto terminal types.

Synopsis
// In header: &lt;boost/proto/operators.hpp&gt;

BOOST_PROTO_DEFINE_OPERATORS(Trait, Domain)

Description

        With BOOST_PROTO_DEFINE_OPERATORS(), it is possible to
        non-intrusively adapt an existing (non-Proto) type to be a Proto terminal. 
      

        Trait is the name of a unary Boolean metafunction that returns
        true for any types you would like to treat as Proto terminals.
      

        Domain is the name of the Proto domain associated with
        these new Proto terminals. You may use
        proto::default_domain
        for the Domain if you do not wish to associate these terminals
        with any domain.
      

        Example:
        
namespace My {
  // A non-Proto terminal type
  struct S {};

  // A unary Boolean metafunction that returns true for type S
  template&lt;typename T&gt; struct IsS : mpl::false_ {};
  template&lt;&gt; struct IsS&lt;S&gt; : mpl::true_ {};
  
  // Make S a Proto terminal non-intrusively by defining the
  // appropriate operator overloads. This should be in the same
  // namespace as S so that these overloads can be found by
  // argument-dependent lookup
  BOOST_PROTO_DEFINE_OPERATORS(IsS, proto::default_domain)
}

int main() {
  My::S s1, s2;
  
  // OK, this builds a Proto expression template:
  s1 + s2; 
}

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_33_3.html
Macro BOOST_TYPE_INDEX_FUNCTION_SIGNATURE\3



Macro BOOST_TYPE_INDEX_FUNCTION_SIGNATURE











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_FUNCTION_SIGNATURE
BOOST_TYPE_INDEX_FUNCTION_SIGNATURE

Synopsis
// In header: &lt;boost/type_index.hpp&gt;

BOOST_TYPE_INDEX_FUNCTION_SIGNATURE

Description
BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by boost::typeindex::ctti_type_index class to deduce the name of a type. If your compiler is not recognized by the TypeIndex library and you wish to work with boost::typeindex::ctti_type_index, you may define this macro by yourself.
BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro that outputs the whole function signature including template parameters.
If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined, then a compile-time error will arise at any attempt to use boost::typeindex::ctti_type_index classes.
See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING for an information of how to tune the implementation to make a nice pretty_name() output. 


Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_2_5.html
Chapter 15. Boost.Heap\3



Chapter 15. Boost.Heap











Home
Libraries
People
FAQ
More








Chapter 15. Boost.Heap

Tim Blechmann

Copyright © 2010, 2011 Tim Blechmann


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction &amp; Motivation
Concepts &amp; Interface

Basic Priority Queue Interface
Priority Queue Iterators
Comparing Priority Queues &amp;
      Equivalence
Merging Priority Queues
Mutability
Stability

Data Structures
Data
      Structure Configuration
Reference

Header &lt;boost/heap/binomial_heap.hpp&gt;
Header &lt;boost/heap/d_ary_heap.hpp&gt;
Header &lt;boost/heap/fibonacci_heap.hpp&gt;
Header &lt;boost/heap/heap_concepts.hpp&gt;
Header &lt;boost/heap/heap_merge.hpp&gt;
Header &lt;boost/heap/pairing_heap.hpp&gt;
Header &lt;boost/heap/policies.hpp&gt;
Header &lt;boost/heap/priority_queue.hpp&gt;
Header &lt;boost/heap/skew_heap.hpp&gt;

Acknowledgements




Introduction &amp; Motivation


      boost.heap is an implementation of priority queues. Priority
      queues are queue data structures, that order their elements by a priority.
      The STL provides a single template class std::priority_queue,
      which only provides a limited functionality. To overcome these limitations,
      boost.heap implements data
      structures with more functionality and different performance characteristics.
      Especially, it deals with additional aspects:
    


          Mutability: The priority of heap elements
          can be modified.
        

          Iterators: Heaps provide iterators to
          iterate all elements.
        

          Mergable: While all heaps can be merged,
          some can be merged efficiently.
        

          Stability: Heaps can be configured to
          be stable sorted.
        

          Comparison: Heaps can be compared for
          equivalence.
        










\3https://www.boost.org/doc/libs/1_84_0/doc/html/heap.html
Macro BOOST_UNITS_METRIC_PREFIX\3



Macro BOOST_UNITS_METRIC_PREFIX











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_METRIC_PREFIX
BOOST_UNITS_METRIC_PREFIX

Synopsis
// In header: &lt;boost/units/systems/si/prefixes.hpp&gt;

BOOST_UNITS_METRIC_PREFIX(exponent, name)

Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNI_1_3_43_10_4_60_2.html
Macro BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY\3



Macro BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY
BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY

Synopsis
// In header: &lt;boost/type_index.hpp&gt;

BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY

Description
BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing RTTI on/off modules. See Mixing sources with RTTI on and RTTI off section of documentation for more info. 


Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_2_8.html
Macro BOOST_MPI_HOMOGENEOUS\3



Macro BOOST_MPI_HOMOGENEOUS











Home
Libraries
People
FAQ
More








Macro BOOST_MPI_HOMOGENEOUS
BOOST_MPI_HOMOGENEOUS — Comment this macro is you are running in an heterogeneous environment. 

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

BOOST_MPI_HOMOGENEOUS

Description
When this flag is enabled, we assume some simple, POD-like, type can be transmitted without paying the cost of portable serialization.
Comment this if your platform is not homogeneous and that portable serialization/deserialization must be performed.
It you do so, check that your MPI implementation supports thats kind of environment. 


Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MPI_HOMOGENEOUS.html
Chapter 30. Boost.PropertyTree\3



Chapter 30. Boost.PropertyTree











Home
Libraries
People
FAQ
More








Chapter 30. Boost.PropertyTree

Marcin Kalicinski


Sebastian Redl

Copyright © 2008-2010 Marcin Kalicinski
Copyright © 2010-2013 Sebastian
      Redl


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

What is Property Tree?
Five Minute Tutorial
Property Tree as a Container
Property Tree Synopsis
How to Populate a Property Tree

XML Parser
JSON Parser
INI Parser
INFO Parser

How to Access Data in a Property
    Tree
Appendices
Reference

Header &lt;boost/property_tree/exceptions.hpp&gt;
Header &lt;boost/property_tree/id_translator.hpp&gt;
Header &lt;boost/property_tree/info_parser.hpp&gt;
Header &lt;boost/property_tree/ini_parser.hpp&gt;
Header &lt;boost/property_tree/json_parser.hpp&gt;
Header &lt;boost/property_tree/ptree.hpp&gt;
Header &lt;boost/property_tree/ptree_fwd.hpp&gt;
Header &lt;boost/property_tree/ptree_serialization.hpp&gt;
Header &lt;boost/property_tree/stream_translator.hpp&gt;
Header &lt;boost/property_tree/string_path.hpp&gt;
Header &lt;boost/property_tree/xml_parser.hpp&gt;





What is Property Tree?


      The Property Tree library provides a data structure that stores an arbitrarily
      deeply nested tree of values, indexed at each level by some key. Each node
      of the tree stores its own value, plus an ordered list of its subnodes and
      their keys. The tree allows easy access to any of its nodes by means of a path,
      which is a concatenation of multiple keys.
    

      In addition, the library provides parsers and generators for a number of data
      formats that can be represented by such a tree, including XML, INI, and JSON.
    

      Property trees are versatile data structures, but are particularly suited for
      holding configuration data. The tree provides its own, tree-specific interface,
      and each node is also an STL-compatible Sequence for its child nodes.
    

      Conceptually, then, a node can be thought of as the following structure:
    
struct ptree
{
   data_type data;                         // data associated with the node
   list&lt; pair&lt;key_type, ptree&gt; &gt; children; // ordered list of named children
};


      Both key_type and data_type are configurable to some extent, but will usually
      be std::string or std::wstring, and the parsers only work with this kind of
      tree.
    

      Many software projects develop a similar tool at some point of their lifetime,
      and property tree originated the same way. We hope the library can save many
      from reinventing the wheel.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/property_tree.html
Chapter 35. Boost.Stacktrace 1.0\3



Chapter 35. Boost.Stacktrace 1.0











Home
Libraries
People
FAQ
More








Chapter 35. Boost.Stacktrace 1.0
Copyright © 2016-2023 Antony Polukhin


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Motivation
Getting Started

How
      to print current call stack
Better asserts
Handle
      terminates
Exceptions
      with stacktrace
Enabling
      and disabling stacktraces
Saving
      stacktraces by specified format
Getting
      function information from pointer
Global
      control over stacktrace output format

Configuration and Build

MinGW
      and MinGW-w64 specific notes
Windows
      deployment and symbol files

Acknowledgements
Reference

Header &lt;boost/stacktrace/stacktrace.hpp&gt;
Header &lt;boost/stacktrace/detail/frame_decl.hpp&gt;
Header &lt;boost/stacktrace/frame.hpp&gt;
Header &lt;boost/stacktrace/safe_dump_to.hpp&gt;
Header &lt;boost/stacktrace/stacktrace_fwd.hpp&gt;





Motivation


      How can one display the call sequence in C++? What function called the current
      function? What call sequence led to an exception?
    

      Boost.Stacktrace library is a simple C++03 library that provides information
      about call sequence in a human-readable form.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/stacktrace.html
Macro BOOST_YAP_USER_UNARY_OPERATOR\3



Macro BOOST_YAP_USER_UNARY_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_UNARY_OPERATOR
BOOST_YAP_USER_UNARY_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_UNARY_OPERATOR(op_name, expr_template, result_expr_template)

Description
Defines operator overloads for unary operator op_name that each take an expression instantiated from expr_template and return an expression instantiated from the result_expr_template expression template. One overload is defined for each of the qualifiers const &amp;, &amp;, and &amp;&amp;. For the lvalue reference overloads, the argument is captured by reference into the resulting expression. For the rvalue reference overload, the argument is moved into the resulting expression.
Example: 









Parameters:







expr_template
The expression template to which the overloads apply. expr_template must be an ExpressionTemplate.


op_name
The operator to be overloaded; this must be one of the unary enumerators in expr_kind, without the expr_kind:: qualification.


result_expr_template
The expression template to use to instantiate the result expression. result_expr_template must be an ExpressionTemplate. 







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_1.html
Redirect to generated documentation\3

  
  

      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt) --
    Redirect to generated documentation
    
  
  
    Automatic redirection failed, please go to
    http://www.boost.org/doc/libs/master/doc/html/signals.html
  

\3https://www.boost.org/doc/libs/1_84_0/doc/html/signals.html
Macro BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE\3



Macro BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE
BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE

Synopsis
// In header: &lt;boost/units/conversion.hpp&gt;

BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE(Params, Source, Dest)

Description
Specifies the default conversion to be applied when no direct conversion is available. Params is a PP Sequence of template arguments. Source is a base unit. Dest is any unit with the same dimensions. The source must not be a scaled base unit. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_7_6.html
Macro BOOST_MPI_CHECK_RESULT\3



Macro BOOST_MPI_CHECK_RESULT











Home
Libraries
People
FAQ
More








Macro BOOST_MPI_CHECK_RESULT
BOOST_MPI_CHECK_RESULT

Synopsis
// In header: &lt;boost/mpi/exception.hpp&gt;

BOOST_MPI_CHECK_RESULT(MPIFunc, Args)

Description
Call the MPI routine MPIFunc with arguments Args (surrounded by parentheses). If the result is not MPI_SUCCESS, use boost::throw_exception to throw an exception or abort, depending on BOOST_NO_EXCEPTIONS. 


Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MPI_CHECK_RESULT.html
Macro BOOST_MPI_VERSION\3



Macro BOOST_MPI_VERSION











Home
Libraries
People
FAQ
More








Macro BOOST_MPI_VERSION
BOOST_MPI_VERSION — Major version of the underlying MPI implementation supproted standard. 

Synopsis
// In header: &lt;boost/mpi/config.hpp&gt;

BOOST_MPI_VERSION

Description
If, for some reason, MPI_VERSION is not supported, you should probably set that according to your MPI documentation 


Copyright © 2005-2007 Douglas Gregor,
      Matthias Troyer, Trustees of Indiana University
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at &lt;ulink url="http://www.boost.org/LICENSE_1_0.txt"&gt;
        http://www.boost.org/LICENSE_1_0.txt &lt;/ulink&gt;)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MPI_VERSION.html
Macro BOOST_STL_INTERFACES_NAMESPACE_V2\3



Macro BOOST_STL_INTERFACES_NAMESPACE_V2











Home
Libraries
People
FAQ
More








Macro BOOST_STL_INTERFACES_NAMESPACE_V2
BOOST_STL_INTERFACES_NAMESPACE_V2

Synopsis
// In header: &lt;boost/stl_interfaces/config.hpp&gt;

BOOST_STL_INTERFACES_NAMESPACE_V2

Copyright © 2019 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_STL__1_3_38_15_2_2_4.html
Chapter 13. Boost.Foreach\3



Chapter 13. Boost.Foreach











Home
Libraries
People
FAQ
More








Chapter 13. Boost.Foreach

Eric Niebler

Copyright © 2004 Eric Niebler


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Extensibility
Portability
Pitfalls
History and Acknowledgements




Introduction


        “Make simple things easy.” --
        Larry Wall
      


      What
      is BOOST_FOREACH?
    

      In C++, writing a loop that iterates over a sequence is tedious. We can either
      use iterators, which requires a considerable amount of boiler-plate, or we
      can use the std::for_each()
      algorithm and move our loop body into a predicate, which requires no less boiler-plate
      and forces us to move our logic far from where it will be used. In contrast,
      some other languages, like Perl, provide a dedicated "foreach" construct
      that automates this process. BOOST_FOREACH is just such
      a construct for C++. It iterates over sequences for us, freeing us from having
      to deal directly with iterators or write predicates.
    

      BOOST_FOREACH is designed for ease-of-use and efficiency.
      It does no dynamic allocations, makes no virtual function calls or calls through
      function pointers, and makes no calls that are not transparent to the compiler's
      optimizer. This results in near-optimal code generation; the performance of
      BOOST_FOREACH is usually within a few percent of the equivalent
      hand-coded loop. And although BOOST_FOREACH is a macro,
      it is a remarkably well-behaved one. It evaluates its arguments exactly once,
      leading to no nasty surprises.
    


      Hello,
      world!
    

      Below is a sample program that uses BOOST_FOREACH to loop
      over the contents of a std::string.
    
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;boost/foreach.hpp&gt;

int main()
{
    std::string hello( "Hello, world!" );

    BOOST_FOREACH( char ch, hello )
    {
        std::cout &lt;&lt; ch;
    }

    return 0;
}


      This program outputs the following:
    
Hello, world!



      Supported
      Sequence Types
    

      BOOST_FOREACH iterates over sequences. But what qualifies
      as a sequence, exactly? Since BOOST_FOREACH is built on
      top of Boost.Range, it automatically
      supports those types which Boost.Range
      recognizes as sequences. Specifically, BOOST_FOREACH works
      with types that satisfy the Single
      Pass Range Concept. For example, we can use BOOST_FOREACH
      with:
    


          STL containers
        

          arrays
        

          Null-terminated strings (char
          and wchar_t)
        

          std::pair of iterators
        




Note


        The support for STL containers is very general; anything that looks like
        an STL container counts. If it has nested iterator
        and const_iterator types
        and begin()
        and end()
        member functions, BOOST_FOREACH will automatically know
        how to iterate over it. It is in this way that boost::iterator_range&lt;&gt;
        and boost::sub_range&lt;&gt;
        work with BOOST_FOREACH.
      


      See the section on Extensibility
      to find out how to make BOOST_FOREACH work with other types.
    


      Examples
    

      Below are some examples that demonstrate all the different ways we can use
      BOOST_FOREACH.
    

      Iterate over an STL container:
    
std::list&lt;int&gt; list_int( /*...*/ );
BOOST_FOREACH( int i, list_int )
{
    // do something with i
}


      Iterate over an array, with covariance (i.e., the type of the iteration variable
      is not exactly the same as the element type of the container):
    
short array_short[] = {1,2,3};
BOOST_FOREACH( int i, array_short )
{
    // The short was implicitly converted to an int
}


      Predeclare the loop variable, and use break,
      continue, and return
      in the loop body:
    
std::deque&lt;int&gt; deque_int( /*...*/ );
int i = 0;
BOOST_FOREACH( i, deque_int )
{
    if( i == 0 ) return;
    if( i == 1 ) continue;
    if( i == 2 ) break;
}


      Iterate over a sequence by reference, and modify the underlying sequence:
    
short array_short[] = { 1, 2, 3 };
BOOST_FOREACH( short &amp; i, array_short )
{
    ++i;
}
// array_short contains {2,3,4} here


      Iterate over a vector of vectors with nested BOOST_FOREACH
      loops. In this example, notice that braces around the loop body are not necessary:
    
std::vector&lt;std::vector&lt;int&gt; &gt; matrix_int;
BOOST_FOREACH( std::vector&lt;int&gt; &amp; row, matrix_int )
    BOOST_FOREACH( int &amp; i, row )
        ++i;


      Iterate over an expression that returns a sequence by value (i.e. an rvalue):
    
extern std::vector&lt;float&gt; get_vector_float();
BOOST_FOREACH( float f, get_vector_float() )
{
    // Note: get_vector_float() will be called exactly once
}


      Iterate in reverse:
    
std::list&lt;int&gt; list_int( /*...*/ );
BOOST_REVERSE_FOREACH( int i, list_int )
{
    // do something with i
}


      Iterating over rvalues doesn't work on some older compilers. Check the Portability section to see whether your
      compiler supports this.
    


      Making
      BOOST_FOREACH Prettier
    

      People have complained about the name BOOST_FOREACH. It's
      too long. ALL CAPS
      can get tiresome to look at. That may be true, but BOOST_FOREACH
      is merely following the Boost
      Naming Convention. That doesn't mean you're stuck with it, though.
      If you would like to use a different identifier (foreach_,
      perhaps), you can simply do:
    
#define foreach_         BOOST_FOREACH
#define foreach_r_       BOOST_REVERSE_FOREACH


      Only do this if you are sure that the identifier you choose will not cause
      name conflicts in your code.
    



Note


        Do not use #define foreach_(x,y) BOOST_FOREACH(x,y). This
        can be problematic if the arguments are macros themselves. This would result
        in an additional expansion of these macros. Instead, use the form shown above.
      


      Lastly, a word of warning. Lots of folks use a foreach
      macro as a short form for BOOST_FOREACH.
      I discourage this. It leads to name conflicts within the BOOST_FOREACH
      macro itself, where foreach
      is the name of a namespace. Besides, foreach
      is a common-enough identifier; even Qt
      defines it as a macro. If you insist on using foreach,
      you might try something like this:
    
#include &lt;boost/foreach.hpp&gt;

namespace boost
{
    // Suggested work-around for https://svn.boost.org/trac/boost/ticket/6131
    namespace BOOST_FOREACH = foreach;
}

#define foreach   BOOST_FOREACH


      This will work around some of the problems you're likely
      to encounter, but not all. Prefer using a different identifier.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/foreach.html
Macro BOOST_DLL_AUTO_ALIAS\3



Macro BOOST_DLL_AUTO_ALIAS











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_AUTO_ALIAS
BOOST_DLL_AUTO_ALIAS — Exports variable or function with unmangled alias name. 

Synopsis
// In header: &lt;boost/dll/alias.hpp&gt;

BOOST_DLL_AUTO_ALIAS(FunctionOrVar)

Description
This macro is useful in cases of long mangled C++ names. For example some void boost::foo(std::string) function name will change to something like N5boostN3foosE after mangling. Importing function by N5boostN3foosE name does not looks user friendly, especially assuming the fact that different compilers have different mangling schemes.*
Must be used in scope where FunctionOrVar declared. FunctionOrVar must be a valid C name, which means that it must not contain ::.
Functions or variables in global namespace must not have names same as FunctionOrVar.
Puts all the aliases into the "boostdll" read only section of the binary. Almost same as  BOOST_DLL_ALIAS(FunctionOrVar, FunctionOrVar).

Example: 
namespace foo {
  void bar(std::string&amp;);
  BOOST_DLL_AUTO_ALIAS(bar)
}

See:  BOOST_DLL_ALIAS for making an alias with different names. 






Parameters:






FunctionOrVar
Function or variable for which an unmangled alias must be made.






Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_AUTO_ALIAS.html
Concept Expr\3



Concept Expr











Home
Libraries
People
FAQ
More








Concept Expr
Expr


Description

      An Expr represents a tagged node in an expression tree.
      The children of the Expr must themselves satisfy the
      Expr concept. The Expr has an arity representing the
      number of children. If the number of children is zero,
      the Expr also has a value. An Expr also has an associated
      Domain.
    


Associated types


proto_tag
Expr::proto_tag

      
The tag type of the Expr.

    


proto_args
Expr::proto_args

      
A typelist representing either the types of the child nodes, or,
        if the arity of the Expr is 0, of the value of the terminal.

    


proto_arity
Expr::proto_arity

      

        The arity (number of child nodes) of the Expr.
        proto_arity is an MPL Integral Constant.
      

    


proto_grammar
Expr::proto_grammar

      

        A typedef for an instantiation of
        
          proto::basic_expr&lt;&gt;
        
        that is equivalent to Expr. Expression types are equivalent if they have the
        same proto_tag, proto_args, and proto_arity.
      

    


proto_base_expr
Expr::proto_base_expr

      

        A typedef for an instantiation of
        proto::expr&lt;&gt; or
        proto::basic_expr&lt;&gt;
        that is equivalent to Expr. Expression types are equivalent if they have the
        same proto_tag, proto_args, and proto_arity.
      

    


proto_derived_expr
Expr::proto_derived_expr

      

        A typedef for Expr.
      

    


proto_domain
Expr::proto_domain

      

        The Domain of the Expr. proto_domain
        models Domain.
      

    


proto_childN
Expr::proto_childN

      
The type of the Nth child of Expr. Requires 
        0 == N::value || N::value &lt; proto_arity::value

    




Notation

Expr
A type playing the role of expession-type in the Expr concept.
Tag
A type playing the role of tag-type in the Expr concept.
Domain
A type playing the role of domain-type in the Expr concept.
N
A type playing the role of mpl-integral-constant-type in the Expr concept.
e
Object of type Expr



Valid expressions








Name
Expression
Type
Semantics



Get N-th Child
boost::proto::child&lt; N &gt;(e)
proto_childN
Extracts the Nth child from this Expr.
      Requires N::value &lt; proto_arity::value.


Get Terminal Value
boost::proto::value(e)
proto_child0

      Extracts the value from a terminal Expr.
      Requires 0 == proto_arity::value.
    


Get Base
e.proto_base()
proto_base_expr

        Returns an object of type
        proto::expr&lt;&gt; or
        proto::basic_expr&lt;&gt;
        that is equivalent to e.
    





Models
boost::proto::literal&lt; int &gt;


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/Expr.html
Concept CopyConstructible\3



Concept CopyConstructible











Home
Libraries
People
FAQ
More








Concept CopyConstructible
CopyConstructible


Description
Copy constructible types must be able to be constructed from another
  member of the type.


Notation

X
A type playing the role of copy-constructible-type in the CopyConstructible concept.

x, y

Objects of type X



Valid expressions








Name
Expression
Type
Semantics


Copy construction
X(x)
X
Require copy constructor.




Models
int


Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/CopyConstructible.html
Chapter 14. Boost.Function\3



Chapter 14. Boost.Function











Home
Libraries
People
FAQ
More








Chapter 14. Boost.Function


Douglas Gregor

&lt;dgregor -at- cs.indiana.edu&gt;

Copyright © 2001-2004 Douglas Gregor

Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)



Table of Contents

Introduction
History &amp; Compatibility Notes
Tutorial

Basic Usage
Free functions
Member functions
References to Function Objects
Comparing Boost.Function function objects

Reference

Definitions
Header &lt;boost/function.hpp&gt;
Header &lt;boost/function_equal.hpp&gt;

Frequently Asked Questions
Miscellaneous Notes

Boost.Function vs. Function Pointers
Performance
Combatting virtual function "bloat"
Acknowledgements

Testsuite

Acceptance tests
Negative tests





Introduction
The Boost.Function library contains a family of class templates
that are function object wrappers. The notion is similar to a
generalized callback. It shares features with function pointers in
that both define a call interface (e.g., a function taking two integer
arguments and returning a floating-point value) through which some
implementation can be called, and the implementation that is invoked
may change throughout the course of the program.
 Generally, any place in which a function pointer would be used
to defer a call or make a callback, Boost.Function can be used instead
to allow the user greater flexibility in the implementation of the
target. Targets can be any 'compatible' function object (or function
pointer), meaning that the arguments to the interface designated by
Boost.Function can be converted to the arguments of the target
function object.









\3https://www.boost.org/doc/libs/1_84_0/doc/html/function.html
Macro BOOST_PROTO_A\3



Macro BOOST_PROTO_A











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_A
BOOST_PROTO_A — 
      Generates sequences like 
      
        A0,
        A1, …
        AN-1
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_A(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_A(N) generates sequences like:
      

        
A0, A1, … AN-1

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_1_3_32_5_37_10.html
Macro BOOST_ACCUMULATORS_MAX_FEATURES\3



Macro BOOST_ACCUMULATORS_MAX_FEATURES











Home
Libraries
People
FAQ
More








Macro BOOST_ACCUMULATORS_MAX_FEATURES
BOOST_ACCUMULATORS_MAX_FEATURES

Synopsis
// In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;

BOOST_ACCUMULATORS_MAX_FEATURES

Description
The maximum number of accumulators that may be put in an accumulator_set. Defaults to BOOST_MPL_LIMIT_VECTOR_SIZE (which defaults to 20). 


Copyright © 2005, 2006 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_ACCUMU_1_3_2_6_2_3_2.html
Chapter 6. Boost.Chrono 2.0.8\3



Chapter 6. Boost.Chrono 2.0.8











Home
Libraries
People
FAQ
More








Chapter 6. Boost.Chrono 2.0.8

Howard Hinnant


Beman Dawes


Vicente J. Botet Escriba

Copyright © 2008 Howard Hinnant
Copyright © 2006, 2008 Beman Dawes
Copyright © 2009-2013 Vicente J. Botet Escriba


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Overview

Motivation
Description

User's Guide

Getting Started
Tutorial
Examples
External Resources

Reference 

Header &lt;boost/chrono/include.hpp&gt;
Included on the C++11 Recommendation
Chrono I/O V1
Chrono I/O V2
Chrono Rounding Utilities
Other Clocks

Appendices

Appendix: History
Appendix: Rationale
Appendix: Implementation
      Notes
Appendix: FAQ
Appendix: Acknowledgements
Appendix: Future plans




    ]
  

    ]
  


Overview


Motivation
Description


        “What is time, then? If nobody asks me, I know; if I have to explain
        it to someone who has asked me, I do not know."”
      

        -- Augustine 
      


      How
      to Use This Documentation
    

      This documentation makes use of the following naming and formatting conventions.
    


          Code is in fixed width
          font and is syntax-highlighted.
        

          Replaceable text that you will need to supply is in italics.
        

          Free functions are rendered in the code font followed by (), as in free_function().
        

          If a name refers to a class template, it is specified like this: class_template&lt;&gt;;
          that is, it is in code font and its name is followed by &lt;&gt;
          to indicate that it is a class template.
        

          If a name refers to a function-like macro, it is specified like this:
          MACRO();
          that is, it is uppercase in code font and its name is followed by () to indicate that it is a function-like
          macro. Object-like macros appear without the trailing ().
        

          Names that refer to concepts in the generic programming
          sense are specified in CamelCase.
        




Note


        In addition, notes such as this one specify non-essential information that
        provides additional background or rationale.
      


      Finally, you can mentally add the following to any code fragments in this document:
    
// Include all of Chrono files
#include &lt;boost/chrono.hpp&gt;



Motivation



        Time
      

        We all deal with time every day of our lives. We've intuitively known it
        since birth. Thus we are all very familiar with it and believe it to be a
        simple matter. The modeling of time in computer programs should be similarly
        simple. The unfortunate truth is that this perceived simplicity is only skin
        deep. Fortunately, we do not need a terribly complicated solution to meet
        the bulk of our needs. However, overly simplistic solutions can be dangerous
        and inefficient, and won't adapt as the computer industry evolves.
      

        Boost.Chrono implements the new time facilities
        in C++11, as proposed in N2661 - A Foundation to Sleep On. That document
        provides background and motivation for key design decisions and is the source
        of a good deal of information in this documentation.
      

        In addition to the clocks provided by the standard proposal, Boost.Chrono
        provides specific process and thread clocks.
      


        Wall
        clock versus system and user time
      

        To make the timing facilities of Boost.Chrono more generally useful, the
        library provides a number of clocks that are thin wrappers around the operating
        system's process time API, thereby allowing the extraction of wall clock
        time, user CPU time, and system CPU time of the process. Wall clock time
        is the sum of CPU time and system CPU time. (On POSIX-like systems, this
        relies on times().
        On Windows, it relies on GetProcessTimes().)
      



Description


        The Boost.Chrono library provides:
      


        Standard
      


            A means to represent time durations: managed by the generic duration class . Examples of
            time durations include days, minutes, seconds and nanoseconds, which can be represented
            with a fixed number of clock ticks per unit. All of these units of time
            duration are united with a generic interface by the duration facility.
          

            A type for representing points in time: time_point. A time_point represents an epoch
            plus or minus a duration. The library leaves
            epochs unspecified. A time_point is associated with
            a clock.
          

            Several clocks, some of which may not be available on a particular platform:
            system_clock, steady_clock and high_resolution_clock. A clock
            is a pairing of a time_point and duration, and a function which
            returns a time_point representing now.
          



        Other
        clocks
      

        To make the timing facilities more generally useful, Boost.Chrono
        provides a number of clocks that are thin wrappers around the operating system's
        time APIs, thereby allowing the extraction of wall clock time, user CPU time,
        system CPU time spent by the process,
      


            process_real_cpu_clock, captures
            wall clock CPU time spent by the current process.
          

            process_user_cpu_clock, captures
            user-CPU time spent by the current process.
          

            process_system_cpu_clock, captures
            system-CPU time spent by the current process.
          

            A tuple-like class process_cpu_clock, that captures
            real, user-CPU, and system-CPU process times together.
          

            A thread_clock thread steady clock
            giving the time spent by the current thread (when supported by a platform).
          


        Lastly, Boost.Chrono includes typeof
        registration for duration and time_point to permit using emulated
        auto with C++03 compilers.
      


        I/O
      

        It provides I/O for duration and time_point. This I/O makes use of
        these types much more convenient. In following the "you only pay for
        what you use" philosophy, this extra functionality is located in a header
        separate from &lt;boost/chrono/chrono.hpp&gt;, namely &lt;boost/chrono/chrono_io.hpp&gt;.
      

        It builds on &lt;boost/ratio/ratio_io.hpp&gt;
        to provide readable and flexible formatting and parsing for types in &lt;boost/chrono.hpp&gt;.
        This textural representation uses SI
        prefixes whenever possible. This makes it easy for boost::milliseconds to be represented by the text
        "milliseconds", or a hypothetical meter class to print out "millimeter".
        The duration and the time_point i/o can be customized
        through the new facets: duration_units and time_point_units. The user can specialize
        these facets so that the chrono i/o could be localizable. However Boost.Chrono
        doesn't provides a complete locale solution.
      

        system_clock::time_point I/O is proposed in terms of
        UTC timepoints, strongly guided by ISO 9899:1999, Programming languages -
        C, ISO 9945:2003, Information Technology - Portable Operating System Interface
        (POSIX) and ISO 8601:2004, Data elements and interchange formats - Information
        interchange - Representation of dates and times.
      


        Rounding
        utilities
      

        A few simple rounding utility functions for working with durations.
      


        Caveat
        Emptor
      

        The underlying clocks provided by operating systems are subject to many seemingly
        arbitrary policies and implementation irregularities. That's a polite way
        of saying they tend to be flakey, and each operating system or even each
        clock has its own cruel and unusual forms of flakiness. Don't bet the farm
        on their accuracy, unless you have become deeply familiar with exactly what
        the specific operating system is guaranteeing, which is often very little.
      










\3https://www.boost.org/doc/libs/1_84_0/doc/html/chrono.html
Auxiliary Components\3



Auxiliary Components











Home
Libraries
People
FAQ
More







Auxiliary Components

multi_array_types
extent_range
extent_gen
Global Objects
View and SubArray Generators
Memory Layout Specifiers
Range Checking



multi_array_types


namespace multi_array_types {
  typedef *unspecified* index;
  typedef *unspecified* size_type;
  typedef *unspecified* difference_type;
  typedef *unspecified* index_range;
  typedef *unspecified* extent_range;
  typedef *unspecified* index_gen;
  typedef *unspecified* extent_gen;
}

Namespace multi_array_types defines types
associated with multi_array,
multi_array_ref, and
const_multi_array_ref that are not
dependent upon template parameters.  These types find common use with
all Boost.Multiarray components.  They are defined
in a namespace from which they can be accessed conveniently.
With the exception of extent_gen and 
extent_range, these types fulfill the roles of the
same name required by MultiArray and are described in its
concept definition.  extent_gen and
extent_range are described below.




extent_range

extent_range objects define half open
intervals.  They provide shape and index base information to
multi_array, multi_array_ref,
 and const_multi_array_ref constructors.
extent_ranges are passed in
aggregate to an array constructor (see
extent_gen for more details).

Synopsis. 

class extent_range {
public:
  typedef multi_array_types::index      index;
  typedef multi_array_types::size_type  size_type;

  // Structors
  extent_range(index start, index finish);
  extent_range(index finish);
  ~extent_range();

  // Queries
  index start();
  index finish();
  size_type size();
};
Model Of. DefaultConstructible,CopyConstructible
Methods and Types. 

extent_range(index start, index finish)
  This constructor defines the half open interval
[start,finish). The expression
finish must be greater than start.

extent_range(index finish)
This constructor defines the half open interval
[0,finish). The value of finish
must be positive.
index start()
This function returns the first index represented by the range
index finish()
This function returns the upper boundary value of the half-open
interval.  Note that the range does not include this value.
size_type size()
This function returns the size of the specified range. It is
equivalent to finish()-start().




extent_gen

The extent_gen class defines an
interface for aggregating array shape and indexing information to be
passed to a multi_array, 
multi_array_ref, or const_multi_array_ref
constructor. Its interface mimics 
 the syntax used to declare built-in array types
in C++. For example, while a 3-dimensional array of 
int values in C++ would be
declared as:

int A[3][4][5],

a similar multi_array would be declared:

multi_array&lt;int,3&gt; A(extents[3][4][5]).


Synopsis. 

template &lt;std::size_t NumRanges&gt;
class *implementation_defined* {
public:
  typedef multi_array_types::index index;
  typedef multi_array_types::size_type size_type;

  template &lt;std::size_t NumRanges&gt; class gen_type;

  gen_type&lt;NumRanges+1&gt;::type  operator[](const range&amp; a_range) const;
  gen_type&lt;NumRanges+1&gt;::type  operator[](index idx) const;
};

typedef *implementation_defined*&lt;0&gt; extent_gen;

Methods and Types. 

template gen_type&lt;Ranges&gt;::type
This type generator is used to specify the result of 
Ranges chained calls to
extent_gen::operator[]. The types
extent_gen and
gen_type&lt;0&gt;::type are the same.
gen_type&lt;NumRanges+1&gt;::type  
operator[](const extent_range&amp; a_range) const;
This function returns a new object containing all previous
extent_range objects in addition to
a_range. extent_range
objects are aggregated by chained calls to
operator[].
gen_type&lt;NumRanges+1&gt;::type
operator[](index idx) const;
This function returns a new object containing all previous
extent_range objects in addition to
extent_range(0,idx). This function gives the array
constructors a similar syntax to traditional C multidimensional array
declaration.




Global Objects

extents
indices

For syntactic convenience, Boost.MultiArray defines two 
global objects as part of its
interface.  These objects play the role of object generators;
expressions involving them create other objects of interest.

 Under some circumstances, the two global objects may be
considered excessive overhead.  Their construction can be prevented by
defining the preprocessor symbol
BOOST_MULTI_ARRAY_NO_GENERATORS before including
boost/multi_array.hpp.


extents


namespace boost {
  multi_array_base::extent_gen extents;
}

Boost.MultiArray's array classes use the
extents global object to specify 
array shape during their construction. 
For example,
a 3 by 3 by 3 multi_array is constructed as follows:

multi_array&lt;int,3&gt; A(extents[3][3][3]);

The same array could also be created by explicitly declaring an extent_gen 
object locally,, but the global object makes this declaration unnecessary.  




indices


namespace boost {
  multi_array_base::index_gen  indices;
}

The MultiArray concept specifies an
index_gen associated type that is used to
create views.
indices is a global object that serves the role of
index_gen for all array components provided by this
library and their associated subarrays and views. 

For example, using the indices object,
a view of an array A is constructed as follows:


A[indices[index_range(0,5)][2][index_range(2,4)]];







View and SubArray Generators

Boost.MultiArray provides traits classes, subarray_gen,
const_subarray_gen,
array_view_gen,
and const_array_view_gen, for naming of
array associated types within function templates.  
In general this is no more convenient to use than the nested 
type generators, but the library author found that some C++ compilers do not 
properly handle templates nested within function template parameter types. 
These generators constitute a workaround for this deficit.  
The following code snippet illustrates
the correspondence between the array_view_gen
traits class and the array_view type associated to
an array:



template &lt;typename Array&gt;
void my_function() {
  typedef typename Array::template array_view&lt;3&gt;::type view1_t;
  typedef typename boost::array_view_gen&lt;Array,3&gt;::type view2_t;
  // ...
}



In the above example, view1_t and
view2_t have the same type.




Memory Layout Specifiers

c_storage_order
fortran_storage_order
general_storage_order


While a multidimensional array represents a hierarchy of containers of
elements, at some point the elements must be laid out in
memory.  As a result, a single multidimensional array 
can be represented in memory more than one way.

For example, consider the two dimensional array shown below in
matrix notation:





Here is how the above array is expressed in C++:


int a[3][4] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };


This is an example of row-major storage, where elements of each row
are stored contiguously.  

While C++ transparently handles accessing elements of an array, you
can also manage the array and its indexing manually.  One way that 
this may be expressed in memory is as follows:


int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
int s[] = { 4, 1 };



With the latter declaration of a and 
strides s, element a(i,j)
of the array can be
accessed using the expression 

*a+i*s[0]+j*s[1]
.

The same two dimensional array could be laid out by column as follows:



int a[] = { 0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11 };
int s[] = { 3, 1 };


Notice that the strides here are different. As a result,
The expression given above to access values will work with this pair
of data and strides as well.

In addition to dimension order, it is also possible to
store any dimension in descending order. For example, returning to the 
first example, the first dimension of the example array, the 
rows,  could be stored in 
reverse, resulting in the following:



int data[] = { 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3 };
int *a = data + 8;
int s[] = { -4, 1 };



Note that in this example a must be explicitly set
to the origin. In the previous examples, the
first element stored in memory was the origin; here this is no longer
the case. 


Alternatively, the second dimension, or the columns, could be reversed
and the rows stored in ascending order:



int data[] = { 3, 2, 1, 0,  7, 6, 5, 4, 11, 10, 9, 8 };
int *a = data + 3;
int s[] = { 4, -1 };




Finally, both dimensions could be stored in descending order:



int data[] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
int *a = data + 11;
int s[] = { -4, -1 };






All of the above arrays are equivalent. The expression
given above for a(i,j) will yield the same value
regardless of the memory layout.

Boost.MultiArray arrays can be created with customized storage
parameters as described above. Thus, existing data can be adapted
(with multi_array_ref or
const_multi_array_ref) as suited to the array
abstraction.  A common usage of this feature would be to wrap arrays
that must interoperate with Fortran routines so they can be
manipulated naturally at both the C++ and Fortran levels. The
following sections describe the Boost.MultiArray components used to
specify memory layout.



c_storage_order


class c_storage_order {
  c_storage_order();
};

c_storage_order is used to specify that an
array should store its elements using the same layout as that used by
primitive C++ multidimensional arrays, that is, from last dimension
to first. This is the default storage order for the arrays provided by
this library.



fortran_storage_order


class fortran_storage_order {
  fortran_storage_order();
};

fortran_storage_order is used to specify that
an array should store its elements using the same memory layout as a
Fortran multidimensional array would, that is, from first dimension to
last.



general_storage_order


template &lt;std::size_t NumDims&gt; 
class general_storage_order {

  template &lt;typename OrderingIter, typename AscendingIter&gt;
  general_storage_order(OrderingIter ordering, AscendingIter ascending);
};

general_storage_order allows the user to
specify an arbitrary memory layout for the contents of an array.  The
constructed object is passed to the array constructor in order to
specify storage order.

OrderingIter and AscendingIter
must model the InputIterator concept.  Both
iterators must refer to a range of NumDims
elements.  AscendingIter points to objects
convertible to bool.  A value of
true means that a dimension is stored in ascending
order while false means that a dimension is stored
in descending order.  OrderingIter specifies the
order in which dimensions are stored.





Range Checking

By default, the array access methods operator() and
operator[] perform range
checking.  If a supplied index is out of the range defined for an
array, an assertion will abort the program.  To disable range
checking (for performance reasons in production releases), define
the BOOST_DISABLE_ASSERTS preprocessor macro prior to
including multi_array.hpp in an application.



Copyright © 2002 The Trustees of Indiana University






\3https://www.boost.org/doc/libs/1_84_0/doc/html/auxiliary.html
Macro BOOST_PROTO_MAX_LOGICAL_ARITY\3



Macro BOOST_PROTO_MAX_LOGICAL_ARITY











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_MAX_LOGICAL_ARITY
BOOST_PROTO_MAX_LOGICAL_ARITY — Controls the maximum number of sub-grammars that
    
      proto::or_&lt;&gt;
     and
      
        proto::and_&lt;&gt;
       accept.

Synopsis
// In header: &lt;boost/proto/proto_fwd.hpp&gt;

BOOST_PROTO_MAX_LOGICAL_ARITY

Description

        BOOST_PROTO_MAX_LOGICAL_ARITY defaults to 10. It may be set higher or lower. Setting
        it higher will have a negative effect on compile times.
      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_35_4.html
Macro BOOST_PROTO_A_const_ref_a\3



Macro BOOST_PROTO_A_const_ref_a











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_A_const_ref_a
BOOST_PROTO_A_const_ref_a — 
      Generates sequences like 
      
        A0 const &amp; a0,
        A1 const &amp; a1, …
        AN-1 const &amp; aN-1
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_A_const_ref_a(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_A_const_ref_a(N) generates sequences like:
      

        
A0 const &amp; a0, A1 const &amp; a1, … AN-1 const &amp; aN-1

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_A_const_ref_a.html
Macro BOOST_YAP_USER_EXPR_IF_ELSE\3



Macro BOOST_YAP_USER_EXPR_IF_ELSE











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_EXPR_IF_ELSE
BOOST_YAP_USER_EXPR_IF_ELSE

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_EXPR_IF_ELSE(expr_template)

Description
Defines a 3-parameter function if_else() that acts as an analogue to the ternary operator (?:), since the ternary operator is not user-overloadable. The return type of if_else() is an expression instantiated from the expr_template expression template.
At least one parameter to if_else() must be an expression.
For each parameter E passed to if_else(), if E is an rvalue, E is moved into the result, and otherwise E is captured by reference into the result.
Example: 









Parameters:






expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate. 






Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_7.html
Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE\3



Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE
BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE

Synopsis
// In header: &lt;boost/units/conversion.hpp&gt;

BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE(Params, Source, Destination, type_, value_)

Description
Defines the conversion factor from a base unit to any other base unit with the same dimensions. Params should be a Boost.Preprocessor Seq of template parameters, such as (class T1)(class T2) All uses of must appear at global scope. The reverse conversion will be defined automatically. This macro is a little dangerous, because, unlike the non-template form, it will silently fail if either base unit is scaled. This is probably not an issue if both the source and destination types depend on the template parameters, but be aware that a generic conversion to kilograms is not going to work. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_7_4.html
Concept EqualityComparable\3



Concept EqualityComparable











Home
Libraries
People
FAQ
More








Concept EqualityComparable
EqualityComparable


Description
Equality Comparable types must have == and
  != operators.


Notation

X
A type playing the role of comparable-type in the EqualityComparable concept.

x, y

Objects of type X



Valid expressions







Name
Expression
Type



Equality test
x == y
Convertible to bool


Inequality test
x != y
Convertible to bool





Models

int
std::vector&lt;int&gt;



Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/EqualityComparable.html
Macro BOOST_PROTO_EXTENDS_SUBSCRIPT\3



Macro BOOST_PROTO_EXTENDS_SUBSCRIPT











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_EXTENDS_SUBSCRIPT
BOOST_PROTO_EXTENDS_SUBSCRIPT — For adding to an expression extension class an overloaded subscript operator that
      builds an expression template.

Synopsis
// In header: &lt;boost/proto/extends.hpp&gt;

BOOST_PROTO_EXTENDS_SUBSCRIPT()

Description

        Use BOOST_PROTO_EXTENDS_SUBSCRIPT() after 
        BOOST_PROTO_BASIC_EXTENDS() to give an expression
        extension class an overloaded subscript operator that builds an expression template.
      

        See also:
        

BOOST_PROTO_BASIC_EXTENDS()
BOOST_PROTO_EXTENDS_ASSIGN()
BOOST_PROTO_EXTENDS_FUNCTION()
BOOST_PROTO_EXTENDS()


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_10_7.html
Macro BOOST_PROCESS_V2_SOURCE\3



Macro BOOST_PROCESS_V2_SOURCE











Home
Libraries
People
FAQ
More








Macro BOOST_PROCESS_V2_SOURCE
BOOST_PROCESS_V2_SOURCE

Synopsis
// In header: &lt;boost/process/v2/src.hpp&gt;

BOOST_PROCESS_V2_SOURCE

Copyright © 2006-2012 Julio M. Merino Vidal, Ilya Sokolov,
      Felipe Tanus, Jeff Flinn, Boris SchaelingCopyright © 2016 Klemens D. Morgenstern
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROCESS_V2_SOURCE.html
Macro BOOST_PROTO_DEFINE_ENV_VAR\3



Macro BOOST_PROTO_DEFINE_ENV_VAR











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_DEFINE_ENV_VAR
BOOST_PROTO_DEFINE_ENV_VAR — 
      Define a type and a global variable of that type that can be used
      to initialize a slot in a Proto transform environment.
    

Synopsis
// In header: &lt;boost/proto/transform/env.hpp&gt;

BOOST_PROTO_DEFINE_ENV_VAR(Type, Name)

Description

        Proto primitive transforms can optionally accept an environment in
        their third parameter which is a key/value store of environment
        variables. Use the BOOST_PROTO_DEFINE_ENV_VAR() macro
        to define the keys.
      

        See the description for proto::data_type
        for an example of the class interface created by this macro.
      

        Example:
      

        
BOOST_PROTO_DEFINE_ENV_VAR(mykey_type, mykey);

struct FetchMyKey
  : proto::when&lt; _, proto::_env_var&lt;mykey_type&gt; &gt;
{};

int main()
{
    proto::terminal&lt;int&gt;::type i = {42};
    char const * sz = FetchMyKey()(i, 0, (mykey = "hello!"));
    assert(0 == std::strcmp(sz, "hello!");
}

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_DEFINE_ENV_VAR.html
Macro BOOST_PROTO_A_const\3



Macro BOOST_PROTO_A_const











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_A_const
BOOST_PROTO_A_const — 
      Generates sequences like
      
        A0 const,
        A1 const, …
        AN-1 const
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_A_const(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_A_const(N) generates sequences like:
      

        
A0 const, A1 const, … AN-1 const

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_A_const.html
Part II. Boost Tools\3



Part II. Boost Tools











Home
Libraries
People
FAQ
More







Part II. Boost Tools



        Boost developers, testers, and maintainers have developed various programs to 
        help with the administration of the Boost Libraries. Like everything else about 
        Boost, these tools are available in source form, and are part of the regular 
        Boost distribution.
      

        Users may find these tools useful when porting Boost libraries to a new platform, 
        or for use with their own applications.
      

Table of Contents

47. The BoostBook Documentation Format

Introduction
Getting Started
Documenting libraries
Bringing Together a BoostBook Document
Reference

48. Quickbook 1.7

Introduction
Change Log
Command Line Usage
Syntax Summary
Document Structure
Phrase Level Elements
Block Level Elements
Language Versions
Installation and configuration
Editor Support
Frequently Asked Questions
Quick Reference












\3https://www.boost.org/doc/libs/1_84_0/doc/html/tools.html
Concept Transform\3



Concept Transform











Home
Libraries
People
FAQ
More








Concept Transform
Transform


Description

      A Transform is a PrimitiveTransform, a CallableTransform
      or an ObjectTransform.
    


Associated types

result_type
boost::result_of&lt;when&lt; _, Tn &gt;(Expr, State, Data)&gt;::type

      
The result of applying the Transform.

    



Notation

Tn
A type playing the role of transform-type in the Transform concept.
Expr
A type playing the role of expression-type in the Transform concept.
State
A type playing the role of state-type in the Transform concept.
Data
A type playing the role of data-type in the Transform concept.
expr
Object of type Expr
state
Object of type State
data
Object of type Data



Valid expressions








Name
Expression
Type
Semantics


Apply Transform
when&lt; _, Tn &gt;()(expr, state, data)
result_type
Applies the transform.




Models
boost::proto::_child(boost::proto::_left)


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/Transform.html
Chapter 3. Boost.Align\3



Chapter 3. Boost.Align











Home
Libraries
People
FAQ
More








Chapter 3. Boost.Align

Glen Fernandes

Copyright © 2014-2017 Glen
      Joseph Fernandes


        Distributed under the Boost Software License, Version 1.0.
      



Table of Contents

Introduction
Rationale
Examples
Reference

Functions
Classes
Traits
Macros

Vocabulary
Compatibility
Acknowledgments
History




Introduction


      The Boost Align C++ library provides functions, classes, templates, traits,
      and macros, for the control, inspection, and diagnostic of memory alignment.
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/align.html
Macro BOOST_DLL_ALIAS_SECTIONED\3



Macro BOOST_DLL_ALIAS_SECTIONED











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_ALIAS_SECTIONED
BOOST_DLL_ALIAS_SECTIONED — Same as  BOOST_DLL_ALIAS but puts alias name into the user specified section. 

Synopsis
// In header: &lt;boost/dll/alias.hpp&gt;

BOOST_DLL_ALIAS_SECTIONED(FunctionOrVar, AliasName, SectionName)

Description

Example: 
namespace foo {
  void bar(std::string&amp;);

  BOOST_DLL_ALIAS_SECTIONED(foo::bar, foo_bar, sect_1) // section "sect_1" now exports "foo_bar"
}

 






Parameters:







AliasName
Name of the alias. Must be a valid C identifier. 


FunctionOrVar
Function or variable for which an alias must be made. 


SectionName
Name of the section. Must be a valid C identifier without quotes not longer than 8 bytes.







Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_ALIAS_SECTIONED.html
Macro BOOST_RV_REF_BEG_IF_CXX11\3



Macro BOOST_RV_REF_BEG_IF_CXX11











Home
Libraries
People
FAQ
More








Macro BOOST_RV_REF_BEG_IF_CXX11
BOOST_RV_REF_BEG_IF_CXX11

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_RV_REF_BEG_IF_CXX11

Description
This macro expands to BOOST_RV_REF_BEG if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined, empty otherwise 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_RV_REF_BEG_IF_CXX11.html
Redirect to generated documentation\3

  
  

      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt) --
    Redirect to generated documentation
    
  
  
    Automatic redirection failed, please go to
    ../../tools/build/doc/html/index.html
  

\3https://www.boost.org/doc/libs/1_84_0/doc/html/bbv2.html
Macro BOOST_PFR_HAS_GUARANTEED_COPY_ELISION\3



Macro BOOST_PFR_HAS_GUARANTEED_COPY_ELISION











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_HAS_GUARANTEED_COPY_ELISION
BOOST_PFR_HAS_GUARANTEED_COPY_ELISION

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_HAS_GUARANTEED_COPY_ELISION

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_HAS_GUAR_idm2551.html
Macro BOOST_PROTO_a\3



Macro BOOST_PROTO_a











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_a
BOOST_PROTO_a — 
      Generates sequences like 
      
        a0,
        a1, …
        aN-1
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_a(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_a(N) generates sequences like:
      

        
a0, a1, … aN-1

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_1_3_32_5_37_15.html
Chapter 28. Boost.Process\3



Chapter 28. Boost.Process











Home
Libraries
People
FAQ
More








Chapter 28. Boost.Process

Klemens David Morgenstern

Copyright © 2006-2012 Julio M. Merino Vidal, Ilya Sokolov,
      Felipe Tanus, Jeff Flinn, Boris Schaeling
Copyright © 2016 Klemens D. Morgenstern


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Concepts

Pipes
Processes
Environment

Tutorial

Starting a
      process
Launch functions
Error
Synchronous I/O
Asynchronous I/O
Groups
Environment

Design Rationale

Scope
Interface Style
Arguments/Command
      Style
Extensions

Extensions

Structure
Simple extensions
Handler Types
Asynchronous Functionality
Error handling
Executor Overloading

Frequently Asked Questions

Why does this produce a
      deadlock?
Why does the pipe not close?
When will the codecvt be used?

Reference

Header &lt;boost/process.hpp&gt;
Header &lt;boost/process/args.hpp&gt;
Header &lt;boost/process/async.hpp&gt;
Header &lt;boost/process/async_pipe.hpp&gt;
Header &lt;boost/process/async_system.hpp&gt;
Header &lt;boost/process/child.hpp&gt;
Header &lt;boost/process/cmd.hpp&gt;
Header &lt;boost/process/env.hpp&gt;
Header &lt;boost/process/environment.hpp&gt;
Header &lt;boost/process/error.hpp&gt;
Header &lt;boost/process/exception.hpp&gt;
Header &lt;boost/process/exe.hpp&gt;
Header &lt;boost/process/extend.hpp&gt;
Header &lt;boost/process/filesystem.hpp&gt;
Header &lt;boost/process/group.hpp&gt;
Header &lt;boost/process/handles.hpp&gt;
Header &lt;boost/process/io.hpp&gt;
Header &lt;boost/process/locale.hpp&gt;
Header &lt;boost/process/pipe.hpp&gt;
Header &lt;boost/process/posix.hpp&gt;
Header &lt;boost/process/search_path.hpp&gt;
Header &lt;boost/process/shell.hpp&gt;
Header &lt;boost/process/spawn.hpp&gt;
Header &lt;boost/process/start_dir.hpp&gt;
Header &lt;boost/process/system.hpp&gt;
Header &lt;boost/process/windows.hpp&gt;

Acknowledgements
Process V2

Introduction
Quickstart
Launcher
process_start_dir
stdio
Environment
Reference






Note


      Process V2 is available as experimental
    



Introduction


      Boost.Process is a library to manage system processes. It can be used to:
    


          create child processes
        

          setup streams for child processes
        

          communicate with child processes through streams (synchronously or asynchronously)
        

          wait for processes to exit (synchronously or asynchronously)
        

          terminate processes
        


      Here's a simple example of how to start a program with Boost.Process:
    


#include &lt;boost/process.hpp&gt;

#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace boost::process;

int main()
{
    ipstream pipe_stream;
    child c("gcc --version", std_out &gt; pipe_stream);

    std::string line;

    while (pipe_stream &amp;&amp; std::getline(pipe_stream, line) &amp;&amp; !line.empty())
        std::cerr &lt;&lt; line &lt;&lt; std::endl;

    c.wait();
}


    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/process.html
Chapter 33. Boost.Ratio 2.1.0\3



Chapter 33. Boost.Ratio 2.1.0











Home
Libraries
People
FAQ
More








Chapter 33. Boost.Ratio 2.1.0

Howard Hinnant


Beman Dawes


Vicente J. Botet Escriba

Copyright © 2008 Howard Hinnant
Copyright © 2006, 2008 Beman Dawes
Copyright © 2009-2012 Vicente
      J. Botet Escriba


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Overview

Motivation
Description

User's Guide

Getting Started
Tutorial
Example
External Resources

Reference 

Standard C++11 Functionality
Ratio I/O

Appendices

Appendix A: History
Appendix B: Rationale
Appendix C: Implementation
      Notes
Appendix D: FAQ
Appendix E: Acknowledgements
Appendix F: Tests
Appendix G: Tickets
Appendix H: Future Plans





Overview


Motivation
Description



      How
      to Use This Documentation
    

      This documentation makes use of the following naming and formatting conventions.
    


          Code is in fixed width
          font and is syntax-highlighted.
        

          Replaceable text that you will need to supply is in italics.
        

          Free functions are rendered in the code font followed by (), as in free_function().
        

          If a name refers to a class template, it is specified like this: class_template&lt;&gt;;
          that is, it is in code font and its name is followed by &lt;&gt;
          to indicate that it is a class template.
        

          If a name refers to a function-like macro, it is specified like this:
          MACRO();
          that is, it is uppercase in code font and its name is followed by () to indicate that it is a function-like
          macro. Object-like macros appear without the trailing ().
        

          Names that refer to concepts in the generic programming
          sense are specified in CamelCase.
        




Note


        In addition, notes such as this one specify non-essential information that
        provides additional background or rationale.
      


      Finally, you can mentally add the following to any code fragments in this document:
    
// Include all of Ratio files
#include &lt;boost/ratio.hpp&gt;
using namespace boost;



Motivation


        Boost.Ratio aimed to implement the compile
        time ratio facility in C++11, as proposed in N2661 - A Foundation to Sleep On. That document
        provides background and motivation for key design decisions and is the source
        of a good deal of information in this documentation.
      

        Since C++11 is now universally available, this library is only retained for
        backward compatibility, and starting with Boost 1.84, it's implemented in
        terms of the standard &lt;ratio&gt; header.
      



Description


        The Boost.Ratio library provides:
      


            A class template, ratio, for specifying compile
            time rational constants such as 1/3 of a nanosecond or the number of
            inches per meter. ratio represents a compile time
            ratio of compile time constants with support for compile time arithmetic
            with overflow and division by zero protection.
          

            It provides a textual representation of boost::ratio&lt;N, D&gt; in the form of a std::basic_string
            which can be useful for I/O.
          











\3https://www.boost.org/doc/libs/1_84_0/doc/html/ratio.html
Chapter 45. Boost.YAP\3



Chapter 45. Boost.YAP











Home
Libraries
People
FAQ
More








Chapter 45. Boost.YAP

Zach Laine

Copyright © 2018 T. Zachary Laine


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
Manual

An Expression
      Template Primer
The YAP Way
Expressions
Mix-and-Match
      Expression Templates
Kinds of Expressions
Operators
Transforming
      Expressions
Evaluating Expressions
Operator Macros
How
      Expression Operands Are Treated
Printing
Examples
Header Organization
Configuration
Object Code

Concepts
Compiler Support
Dependencies
Reference
Headers
Rationale




Introduction


      "I like to start documentation with a quote. A nice, pithy one."
    

      — Eric Niebler (paraphrased)
    


      Motivation
    

      Expression templates are rad. They are used in lots of libraries; here are
      just three of the most impressive:
    


          Boost.Spirit allows you to
          write an EBNF-style grammar that gets transformed into a PEG parser.
        

          Eigen allows you to do
          linear algebra using a very natural and mathematical expression syntax
          that Eigen uses to heavily
          optimize your expressions.
        

          NT2 takes slightly
          modified MatLab code and allows it to be parsed and run as highly optimized
          C++ code.
        


      However, this can come at a high cost. Expression templates are costly to implement
      and maintain. Each of Eigen
      and Boost.Ublas has a large volume of complex expression template code that
      cannot be reused elsewhere.
    

      With the language facilities available in the C++14 and C++17 standards, an
      expression template library is now straightforward to write and use, and has
      very reasonable compile times.
    

      As a quick example, let's say we are doing a bit of matrix math, and we write
      this statement:
    
D = A * B + C;


      in which all the variables are matrices. It turns out that making a temporary
      for A *
      B and then another temporary for
      the resulting product plus C
      is very inefficient. Most matrix math libraries will have a single function
      that does it in one go:
    
mul_add_assign(D, A, B, C);


      If you use a matrix library that offers both kinds of syntax, you have to notice
      when some bit of operator-using code should be replaced with some more efficient
      function; this is tedious and error-prone. If the library does not provide
      the operator syntax at all, only providing the more-efficient function calls,
      code using the library is a lot less writable and readable.
    

      Using Boost.YAP, you can write some library code that enables expressions like
      D =
      A * B + C
      to be automatically transformed into expressions like mul_add_assign(D,
      A, B, C).
    

      Consider another example. Many of us have used Unix command line tools to remove
      duplicate lines in a file:
    
sort file_with_duplicates | uniq &gt; file_without_duplicates


      We can do something very similar with the standard algorithms, of course:
    


std::vector&lt;int&gt; v1 = {0, 2, 2, 7, 1, 3, 8};
std::sort(v1.begin(), v1.end());
auto it = std::unique(v1.begin(), v1.end());
std::vector&lt;int&gt; const v2(v1.begin(), it);
assert(v2 == std::vector&lt;int&gt;({0, 1, 2, 3, 7, 8}));


    

      However, it would be much better if our code did exactly that, but with a more
      concise syntax:
    


std::vector&lt;int&gt; v1 = {0, 2, 2, 7, 1, 3, 8};
std::vector&lt;int&gt; const v2 = sort(v1) | unique;
assert(v2 == std::vector&lt;int&gt;({0, 1, 2, 3, 7, 8}));


    

      This looks much more similar to the Unix command line above. (Let's pretend
      that Range-v3
      doesn't already do almost exactly this.)
    

      Boost.YAP can be used to do both of these things, in a pretty small amount
      of code. In fact, you can jump right into the Pipable
      Algorithms example if you want to see how the second one can be implemented.
    


      Features
    


          Simple ExpressionTemplate
          and Expression concepts
          easily modeled by user code. Member and non-member functions on ExpressionTemplates
          and Expressions can
          be added with compact macros, and a reference template that models ExpressionTemplate
          exists for prototyping or experimentation.
        

          Evaluation of Boost.YAP expressions matches the semantics of builtin C++
          expressions as closely as possible. This leads to clearer understanding
          of the semantics of expression evaluation, because the definitions are
          local to the types involved.
        

          Expressions may be transformed explicitly in a user-defined way. This is
          accomplished with overloaded call operators in a transform class, which
          are matched against subexpressions in the overall expression. While these
          member functions may transform a subexpression into anything, a common
          pattern is to transform only some subexpressions into either new subexpressions
          or appropriate values and to leave other subexpressions unchanged. This
          evaluate(transform(expr))
          idiom is expected to be one of the most common ways of using Yap to manipulate
          and evaluate expressions.
        

          Functions that operate on or create expressions. Functions are provided
          (and used within Boost.YAP) that manipulate expressions or their subexpressions.
          These simplify the process of writing user-defined transforms, for example.
        










\3https://www.boost.org/doc/libs/1_84_0/doc/html/yap.html
Macro BOOST_YAP_USER_UDT_ANY_IF_ELSE\3



Macro BOOST_YAP_USER_UDT_ANY_IF_ELSE











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_UDT_ANY_IF_ELSE
BOOST_YAP_USER_UDT_ANY_IF_ELSE

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_UDT_ANY_IF_ELSE(expr_template, udt_trait)

Description
Defines a function if_else() that acts as an analogue to the ternary operator (?:), since the ternary operator is not user-overloadable. The return type of if_else() is an expression instantiated from the expr_template expression template.
Each parameter to if_else() may be any type that is not an expression. At least on parameter must be a type T for which 
udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value

 is true. Each parameter is wrapped in a terminal expression.
Example: 









Parameters:







expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate.


udt_trait
A trait template to use to constrain which types are accepted as template parameters to if_else(). 







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_8.html
Macro BOOST_DLL_SELECTANY\3



Macro BOOST_DLL_SELECTANY











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_SELECTANY
BOOST_DLL_SELECTANY — Macro that allows linker to select any occurrence of this symbol instead of failing with 'multiple definitions' error at linktime. 

Synopsis
// In header: &lt;boost/dll/alias.hpp&gt;

BOOST_DLL_SELECTANY

Description
This macro does not work on Android, IBM XL C/C++ and MinGW+Windows because of linker problems with exporting weak symbols (See https://code.google.com/p/android/issues/detail?id=70206, https://sourceware.org/bugzilla/show_bug.cgi?id=17480) 


Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_SELECTANY.html
Concept BidirectionalIterator\3



Concept BidirectionalIterator











Home
Libraries
People
FAQ
More








Concept BidirectionalIterator
BidirectionalIterator


Description
A bidirectional iterator is an iterator that can read through a sequence
  of values.  It can move in either direction through the sequence, and can
  be either mutable (data pointed to by it can be changed) or not mutable.
An iterator represents a position in a sequence.  Therefore, the
  iterator can point into the sequence (returning a value when dereferenced
  and being incrementable), or be off-the-end (and not dereferenceable or
  incrementable).


Refinement of
ForwardIterator


Associated types


value_type
std::iterator_traits&lt;Iter&gt;::value_type
The value type of the iterator


category
std::iterator_traits&lt;Iter&gt;::iterator_category
The category of the iterator




Notation

Iter
A type playing the role of iterator-type in the BidirectionalIterator concept.

i, j

Objects of type Iter
x
Object of type value_type



Type expressions

Category tag
category must be
                  derived from std::bidirectional_iterator_tag.
                



Valid expressions










Name
Expression
Type
Precondition
Semantics
Postcondition



Predecrement
--i
Iter &amp;
i is incrementable (not
    off-the-end) and some dereferenceable iterator j exists
    such that i == ++j
 
 


Postdecrement
i--
Iter
Same as for predecrement
Equivalent to {Iter j = i; --i; return j;}
i is dereferenceable or
    off-the-end





Complexity

  All iterator operations must take amortized constant time.
  


Invariants

Predecrement must return object

  &amp;i = &amp;(--i)
  
Unique path through sequence

  i == j implies --i == --j
  
Increment and decrement are inverses

  ++i; --i; and --i; ++i; must end up with the
  value of i unmodified, if i both of the
  operations in the pair are valid.
  



Models

T *
std::list&lt;T&gt;::iterator



See also
RandomAccessIterator


Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BidirectionalIterator.html
Macro BOOST_PROTO_EXTENDS_FUNCTION\3



Macro BOOST_PROTO_EXTENDS_FUNCTION











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_EXTENDS_FUNCTION
BOOST_PROTO_EXTENDS_FUNCTION — For adding to an expression extension class a set of overloaded function call operators
      that build expression templates.

Synopsis
// In header: &lt;boost/proto/extends.hpp&gt;

BOOST_PROTO_EXTENDS_FUNCTION()

Description

        Use BOOST_PROTO_EXTENDS_FUNCTION() after 
        BOOST_PROTO_BASIC_EXTENDS() to give an expression
        extension class a set of overloaded function call operators that build expression templates.
        In addition, BOOST_PROTO_EXTENDS_FUNCTION() adds a nested
        result&lt;&gt; class template that is a metafunction for
        calculating the return type of the overloaded function call operators.
      

        See also:
        

BOOST_PROTO_BASIC_EXTENDS()
BOOST_PROTO_EXTENDS_ASSIGN()
BOOST_PROTO_EXTENDS_SUBSCRIPT()
BOOST_PROTO_EXTENDS()


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO__1_3_32_5_10_6.html
Reference\3



Reference











Home
Libraries
People
FAQ
More







Reference
Elements:

Element access - Declares an access specification for class members
Element boostbook - Defines a BoostBook book
Element class - Declares a class or class template
Element class-specialization - A specialization (partial or full) of a class template
Element code - Mimics the code tag in HTML
Element compile-fail-test - A testcase that should fail to compile
Element compile-test - A testcase that should compile correctly
Element complexity - The time/space/etc. complexity of a function
Element constructor - Declares a constructor of the enclosing class
Element copy-assignment - Declares a copy-assignment operator
Element data-member - Declares a data member of a class
Element default - The default value of a function or template parameter
Element description - Detailed description of a construct
Element destructor - Declares a destructor for the enclosing class
Element effects - Declares the side effects of a function
Element enum - Declares an enumeration type
Element enumname - References an enumeration type with the given name
Element enumvalue - A single value of an enumeration
Element free-function-group - A set of functions that are grouped together under one name
Element function - Declares a function
Element functionname - References a function with the given name
Element globalname - References a global with the given name
Element header - Declares a C++ header with the given name
Element headername - References a C++ header with the given name
Element if-fails - What it means when a testcase fails
Element inherit - Declares a base class of the enclosing class or struct
Element lib - A library dependency
Element library - Top-level element for a library
Element library-reference - Declares the reference material for a library
Element librarycategory - Declares that the enclosing library is in this category
Element librarycategorydef - Defines a new library category
Element librarycategorylist - Categorized listing of libraries
Element libraryinfo - Provides information about a library
Element librarylist - Placeholder for an alphabetical list of libraries
Element libraryname - References a library of the given name
Element librarypurpose - Describes in one short sentence or phrase the purpose of a library
Element link-fail-test - Declares a test that should compile but fail to link
Element link-test - Declares a test that should compile and link
Element macroname - References a macro with the given name
Element method - Declares a method, i.e., a member function
Element method-group - A set of methods that are grouped together under one name
Element namespace - Declares a namespace
Element notes - Non-normative notes about a function's semantics
Element overloaded-function - An overloaded function
Element overloaded-method - An overloaded method
Element parameter - A function parameter
Element paramtype - The type of a function parameter
Element postconditions - Conditions that must hold after the function returns
Element precondition - Conditions that must be met prior to executing a function
Element programlisting - A sample of program code
Element purpose - A short description of an entity's use
Element rationale - Describes the rationale for a particular function's design
Element requirement - A requirement/property in the Jamfile for a testcase
Element requires - Declares the requirements of a function
Element returns - Description of the return value of a function
Element run-fail-test - A testcase that should compile and link, but fail on execution
Element run-test - A testcase that should compile, link, and execute
Element signature - One signature of an overloaded function or method
Element snippet - Pulls in a code snippet from a programlisting element
Element source - Defines source code for a test
Element specialization - Defines the specialization arguments for a class specialization
Element static-constant - Declares a static constant, e.g., const int foo = 5;.
Element struct - Declares a C++ struct
Element struct-specialization - A specialization (full or partial) of a struct template
Element template - Declares the template parameters of a class or function
Element template-arg - A template argument in a specialization
Element template-nontype-parameter - A nontype template parameter
Element template-type-parameter - Declares a template type parameter
Element template-varargs - Declares a variable-length list of template parameters
Element testsuite - Describes a library testsuite
Element throws - Description of the exceptions thrown by a function
Element type - The type of an element or return type of a function
Element typedef - Declares a typedef
Element union - Declares a C++ union or union template
Element union-specialization - A specialization (full or partial) of a union template
Element using-class - Injects the method and function names of a class into the local scope
Element using-namespace - Injects the declared names from a namespace into the local scope


Copyright © 2003-2005 Douglas GregorDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt).
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/reference.html
Macro BOOST_MOVABLE_BUT_NOT_COPYABLE\3



Macro BOOST_MOVABLE_BUT_NOT_COPYABLE











Home
Libraries
People
FAQ
More








Macro BOOST_MOVABLE_BUT_NOT_COPYABLE
BOOST_MOVABLE_BUT_NOT_COPYABLE

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_MOVABLE_BUT_NOT_COPYABLE(TYPE)

Description
This macro marks a type as movable but not copyable, disabling copy construction and assignment. The user will need to write a move constructor/assignment as explained in the documentation to fully write a movable but not copyable class. 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_MOVABL_1_3_24_20_7_3.html
Macro BOOST_NO_CONSTEXPR_IF\3



Macro BOOST_NO_CONSTEXPR_IF











Home
Libraries
People
FAQ
More








Macro BOOST_NO_CONSTEXPR_IF
BOOST_NO_CONSTEXPR_IF

Synopsis
// In header: &lt;boost/yap/config.hpp&gt;

BOOST_NO_CONSTEXPR_IF

Description
Indicates whether the compiler supports constexpr if.
If the user does not define any value for this, we assume that the compiler does not have the necessary support. Note that this is a temporary hack; this should eventually be a Boost-wide macro. 


Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_NO_CONSTEXPR_IF.html
Chapter 36. Boost.StaticAssert\3



Chapter 36. Boost.StaticAssert











Home
Libraries
People
FAQ
More








Chapter 36. Boost.StaticAssert

John Maddock


Steve Cleary

Copyright © 2000, 2005 Steve Cleary and John Maddock


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at 
        http://www.boost.org/LICENSE_1_0.txt )
      



Table of Contents

Overview and Tutorial

Use at namespace scope.
Use at function scope
Use at class scope
Use in templates

How it works
Test Programs



    This manual is also available in printer
    friendly PDF format.
  


Overview and Tutorial

Use at namespace scope.
Use at function scope
Use at class scope
Use in templates


      The header &lt;boost/static_assert.hpp&gt;
      supplies two macros:
    
BOOST_STATIC_ASSERT(x)
BOOST_STATIC_ASSERT_MSG(x, msg)


      Both generate a compile time error message if the integral-constant-expression
      x is not true. In other words,
      they are the compile time equivalent of the assert macro; this is sometimes
      known as a "compile-time-assertion", but will be called a "static
      assertion" throughout these docs. Note that if the condition is true, then the macros will generate neither
      code nor data - and the macros can also be used at either namespace, class
      or function scope. When used in a template, the static assertion will be evaluated
      at the time the template is instantiated; this is particularly useful for validating
      template parameters.
    

      If the C++0x static_assert feature
      is available, both macros will use it. For BOOST_STATIC_ASSERT(x),
      the error message will be a stringized version of x.
      For BOOST_STATIC_ASSERT_MSG(x,
      msg),
      the error message will be the msg
      string.
    

      If the C++0x static_assert feature
      is not available, BOOST_STATIC_ASSERT_MSG(x,
      msg)
      will be treated as BOOST_STATIC_ASSERT(x).
    

      The material that follows assumes the C++0x static_assert
      feature is not available.
    

      One of the aims of BOOST_STATIC_ASSERT
      is to generate readable error messages. These immediately tell the user that
      a library is being used in a manner that is not supported. While error messages
      obviously differ from compiler to compiler, but you should see something like:
    
Illegal use of STATIC_ASSERTION_FAILURE&lt;false&gt;


      Which is intended to at least catch the eye!
    

      You can use BOOST_STATIC_ASSERT
      at any place where you can place a declaration, that is at class, function
      or namespace scope, this is illustrated by the following examples:
    


Use at namespace scope.

        The macro can be used at namespace scope, if there is some requirement must
        always be true; generally this means some platform specific requirement.
        Suppose we require that int
        be at least a 32-bit integral type, and that wchar_t
        be an unsigned type. We can verify this at compile time as follows:
      
#include &lt;climits&gt;
#include &lt;cwchar&gt;
#include &lt;limits&gt;
#include &lt;boost/static_assert.hpp&gt;

namespace my_conditions {

   BOOST_STATIC_ASSERT(std::numeric_limits&lt;int&gt;::digits &gt;= 32);
   BOOST_STATIC_ASSERT(WCHAR_MIN &gt;= 0);

} // namespace my_conditions


        The use of the namespace my_conditions here requires some comment. The macro
        BOOST_STATIC_ASSERT works
        by generating an typedef declaration, and since the typedef must have a name,
        the macro generates one automatically by mangling a stub name with the value
        of __LINE__. When BOOST_STATIC_ASSERT is used at either class
        or function scope then each use of BOOST_STATIC_ASSERT
        is guaranteed to produce a name unique to that scope (provided you only use
        the macro once on each line). However when used in a header at namespace
        scope, that namespace can be continued over multiple headers, each of which
        may have their own static assertions, and on the "same" lines,
        thereby generating duplicate declarations. In theory the compiler should
        silently ignore duplicate typedef declarations, however many do not do so
        (and even if they do they are entitled to emit warnings in such cases). To
        avoid potential problems, if you use BOOST_STATIC_ASSERT
        in a header and at namespace scope, then enclose them in a namespace unique
        to that header.
      



Use at function scope

        The macro is typically used at function scope inside template functions,
        when the template arguments need checking. Imagine that we have an iterator-based
        algorithm that requires random access iterators. If the algorithm is instantiated
        with iterators that do not meet our requirements then an error will be generated
        eventually, but this may be nested deep inside several templates, making
        it hard for the user to determine what went wrong. One option is to add a
        static assertion at the top level of the template, in that case if the condition
        is not met, then an error will be generated in a way that makes it reasonably
        obvious to the user that the template is being misused.
      
#include &lt;iterator&gt;
#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/type_traits.hpp&gt;

template &lt;class RandomAccessIterator &gt;
RandomAccessIterator foo(RandomAccessIterator from,
                         RandomAccessIterator to)
{
   // this template can only be used with
   // random access iterators...
   typedef typename std::iterator_traits&lt;
         RandomAccessIterator &gt;::iterator_category cat;
   BOOST_STATIC_ASSERT(
      (boost::is_convertible&lt;
         cat,
         const std::random_access_iterator_tag&amp;&gt;::value));
   //
   // detail goes here...
   return from;
}


        A couple of footnotes are in order here: the extra set of parenthesis around
        the assert, is to prevent the comma inside the is_convertible
        template being interpreted by the preprocessor as a macro argument separator;
        the target type for is_convertible
        is a reference type, as some compilers have problems using is_convertible when the conversion is via
        a user defined constructor (in any case there is no guarantee that the iterator
        tag classes are copy-constructible).
      



Use at class scope

        The macro is typically used inside classes that are templates. Suppose we
        have a template-class that requires an unsigned integral type with at least
        16-bits of precision as a template argument, we can achieve this using something
        like this:
      
#include &lt;limits&gt;
#include &lt;boost/static_assert.hpp&gt;

template &lt;class UnsignedInt&gt;
class myclass
{
private:
   BOOST_STATIC_ASSERT_MSG(std::numeric_limits&lt;UnsignedInt&gt;::is_specialized, "myclass can only be specialized for types with numeric_limits support.");
   BOOST_STATIC_ASSERT_MSG(std::numeric_limits&lt;UnsignedInt&gt;::digits &gt;= 16, "Template argument UnsignedInt must have at least 16 bits precision.")
   BOOST_STATIC_ASSERT_MSG(std::numeric_limits&lt;UnsignedInt&gt;::is_integer, "Template argument UnsignedInt must be an integer.");
   BOOST_STATIC_ASSERT_MSG(!std::numeric_limits&lt;UnsignedInt&gt;::is_signed, "Template argument UnsignedInt must not be signed.");
public:
   /* details here */
};




Use in templates

        Normally static assertions when used inside a class or function template,
        will not be instantiated until the template in which it is used is instantiated.
        However, there is one potential problem to watch out for: if the static assertion
        is not dependent upon one or more template parameters, then the compiler
        is permitted to evaluate the static assertion at the point it is first seen,
        irrespective of whether the template is ever instantiated, for example:
      
template &lt;class T&gt;
struct must_not_be_instantiated
{
   BOOST_STATIC_ASSERT(false);
};


        Will produce a compiler error with some compilers (for example Intel 8.1
        or gcc 3.4), regardless of whether the template is ever instantiated. A workaround
        in cases like this is to force the assertion to be dependent upon a template
        parameter:
      
template &lt;class T&gt;
struct must_not_be_instantiated
{
   // this will be triggered if this type is instantiated
   BOOST_STATIC_ASSERT(sizeof(T) == 0);
};











\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_staticassert.html
Macro BOOST_ACCUMULATORS_DEFINE_EXTRACTOR\3



Macro BOOST_ACCUMULATORS_DEFINE_EXTRACTOR











Home
Libraries
People
FAQ
More








Macro BOOST_ACCUMULATORS_DEFINE_EXTRACTOR
BOOST_ACCUMULATORS_DEFINE_EXTRACTOR

Synopsis
// In header: &lt;boost/accumulators/framework/extractor.hpp&gt;

BOOST_ACCUMULATORS_DEFINE_EXTRACTOR(Tag, Feature, ParamSeq)

Copyright © 2005, 2006 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_ACCUM_1_3_2_6_2_13_2.html
Macro BOOST_TYPE_INDEX_USER_TYPEINDEX\3



Macro BOOST_TYPE_INDEX_USER_TYPEINDEX











Home
Libraries
People
FAQ
More








Macro BOOST_TYPE_INDEX_USER_TYPEINDEX
BOOST_TYPE_INDEX_USER_TYPEINDEX

Synopsis
// In header: &lt;boost/type_index.hpp&gt;

BOOST_TYPE_INDEX_USER_TYPEINDEX

Description
BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file with user provided implementation of type_index.
See Making a custom type_index section of documentation for usage example. 


Copyright © 2012-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_TYPE_IN_1_3_41_8_2_7.html
Macro BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD\3



Macro BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD











Home
Libraries
People
FAQ
More








Macro BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD
BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD

Synopsis
// In header: &lt;boost/random/mersenne_twister.hpp&gt;

BOOST_RANDOM_MERSENNE_TWISTER_DISCARD_THRESHOLD

Copyright © 2000-2005 Jens MaurerCopyright © 2009, 2010 Steven Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_RAND_1_3_33_5_6_26_2.html
Macro BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR\3



Macro BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR
BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR(expr_template)

Description
Defines user defined literal template that creates literal placeholders instantiated from the expr_template expression template. It is recommended that you put this in its own namespace.








Parameters:






expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate. 






Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP__1_3_46_8_2_7_12.html
Concept RandomAccessIterator\3



Concept RandomAccessIterator











Home
Libraries
People
FAQ
More








Concept RandomAccessIterator
RandomAccessIterator


Description
A random access iterator is an iterator that can read through
  a sequence of values.  It can move in either direction through the
  sequence (by any amount in constant time), and can be either mutable
  (data pointed to by it can be changed) or not mutable.
An iterator represents a position in a sequence.  Therefore,
  the iterator can point into the sequence (returning a value when
  dereferenced and being incrementable), or be off-the-end (and not
  dereferenceable or incrementable).


Refinement of

BidirectionalIterator
LessThanComparable



Associated types


value_type
std::iterator_traits&lt;Iter&gt;::value_type
The value type of the iterator


category
std::iterator_traits&lt;Iter&gt;::iterator_category
The category of the iterator


difference_type
std::iterator_traits&lt;Iter&gt;::difference_type
The difference type of the iterator (measure of the number
    of steps between two iterators)




Notation

Iter
A type playing the role of iterator-type in the RandomAccessIterator concept.

i, j

Objects of type Iter
x
Object of type value_type
n
Object of type difference_type
int_off
Object of type int



Type expressions

Category tag
category must be
                  derived from std::random_access_iterator_tag.
                



Valid expressions








Name
Expression
Type
Semantics



Motion
i += n
Iter &amp;
Equivalent to applying i++ n times
    if n is positive, applying i--
    -n times if n is negative, and to a null
    operation if n is zero.


Motion (with integer offset)
i += int_off
Iter &amp;
Equivalent to applying i++ n times
    if n is positive, applying i--
    -n times if n is negative, and to a null
    operation if n is zero.


Subtractive motion
i -= n
Iter &amp;
Equivalent to i+=(-n)


Subtractive motion (with integer offset)
i -= int_off
Iter &amp;
Equivalent to i+=(-n)


Addition
i + n
Iter
Equivalent to {Iter j = i; j += n; return j;}


Addition with integer
i + int_off
Iter
Equivalent to {Iter j = i; j += n; return j;}


Addition (count first)
n + i
Iter
Equivalent to i + n


Addition with integer (count first)
int_off + i
Iter
Equivalent to i + n


Subtraction
i - n
Iter
Equivalent to i + (-n)


Subtraction with integer
i - int_off
Iter
Equivalent to i + (-n)


Distance
i - j
difference_type
The number of times i must be incremented (or
    decremented if the result is negative) to reach j.  Not
    defined if j is not reachable from
    i.


Element access
i[n]
const-if-not-mutable value_type &amp;
Equivalent to *(i + n)


Element access with integer index
i[int_off]
const-if-not-mutable value_type &amp;
Equivalent to *(i + n)





Complexity

  All iterator operations must take amortized constant time.
  


Models

T *
std::vector&lt;T&gt;::iterator
std::vector&lt;T&gt;::const_iterator
std::deque&lt;T&gt;::iterator
std::deque&lt;T&gt;::const_iterator



See also
LessThanComparable


Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/RandomAccessIterator.html
Macro BOOST_PROGRAM_OPTIONS_VERSION\3



Macro BOOST_PROGRAM_OPTIONS_VERSION











Home
Libraries
People
FAQ
More








Macro BOOST_PROGRAM_OPTIONS_VERSION
BOOST_PROGRAM_OPTIONS_VERSION

Synopsis
// In header: &lt;boost/program_options/version.hpp&gt;

BOOST_PROGRAM_OPTIONS_VERSION

Description
The version of the source interface. The value will be incremented whenever a change is made which might cause compilation errors for existing code. 


Copyright © 2002-2004 Vladimir PrusDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROGRA_1_3_30_9_12_1.html
The Boost C++ Libraries BoostBook Documentation Subset\3



The Boost C++ Libraries BoostBook Documentation Subset









Home
Libraries
People
FAQ
More






The Boost C++ Libraries BoostBook Documentation Subset



Table of Contents

What's Included in This Document
I. The Boost C++ Libraries (BoostBook Subset)

1. Boost.Accumulators
2. Boost String Algorithms Library
3. Boost.Align
4. Boost.Any 1.2
5. Boost.Array
6. Boost.Chrono 2.0.8
7. Boost.Circular Buffer
8. Boost.Container
9. The Conversion Library 1.7
10. Boost.CRC 1.5
11. Boost.Date_Time
12. Boost.DLL
13. Boost.Foreach
14. Boost.Function
15. Boost.Heap
16. Boost.Interprocess
17. Boost.Intrusive
18. Boost.Lambda
19. Boost.Lexical_Cast 1.0
20. Boost.Lockfree
21. Boost.Tribool
22. Boost.Metaparse
23. Boost.Move
24. Boost.MPI
25. Boost.MultiArray Reference Manual
26. Boost.PFR 2.2
27. Boost.PolyCollection
28. Boost.Process
29. Boost.Program_options
30. Boost.PropertyTree
31. Boost.Proto
32. Boost.Random
33. Boost.Ratio 2.1.0
34. Boost.Signals2
35. Boost.Stacktrace 1.0
36. Boost.StaticAssert
37. Boost.STLInterfaces
38. Thread 4.8.0
39. Boost.TypeErasure
40. Boost.TypeIndex 4.1
41. Boost.Typeof
42. Boost.Units 1.1.0
43. Boost.Variant
44. Boost.Xpressive
45. Boost.YAP
46. Boost.Concept_Check

II. Boost Tools

47. The BoostBook Documentation Format
48. Quickbook 1.7









\3https://www.boost.org/doc/libs/1_84_0/doc/html/index.html
Chapter 39. Boost.TypeErasure\3



Chapter 39. Boost.TypeErasure











Home
Libraries
People
FAQ
More








Chapter 39. Boost.TypeErasure

Steven Watanabe

Copyright © 2011-2013 Steven Watanabe


        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      



Table of Contents

Introduction
How to read this documentation
Basic Usage
Composing Concepts
Functions with Multiple Arguments
Concepts in Depth

Defining Custom Concepts
Overloading
Concept Maps
Associated Types

Using Any

Construction
Conversions
References
Syntax Limitations

Examples

A polymorphic
      range formatter
A type-safe printf
Boost.Function
      with multiple signatures

Concept Definitions
Predefined Concepts
Reference

Header &lt;boost/type_erasure/any.hpp&gt;
Header &lt;boost/type_erasure/any_cast.hpp&gt;
Header &lt;boost/type_erasure/binding.hpp&gt;
Header &lt;boost/type_erasure/binding_of.hpp&gt;
Header &lt;boost/type_erasure/builtin.hpp&gt;
Header &lt;boost/type_erasure/call.hpp&gt;
Header &lt;boost/type_erasure/callable.hpp&gt;
Header &lt;boost/type_erasure/check_match.hpp&gt;
Header &lt;boost/type_erasure/concept_interface.hpp&gt;
Header &lt;boost/type_erasure/concept_of.hpp&gt;
Header &lt;boost/type_erasure/config.hpp&gt;
Header &lt;boost/type_erasure/constructible.hpp&gt;
Header &lt;boost/type_erasure/deduced.hpp&gt;
Header &lt;boost/type_erasure/derived.hpp&gt;
Header &lt;boost/type_erasure/dynamic_any_cast.hpp&gt;
Header &lt;boost/type_erasure/dynamic_binding.hpp&gt;
Header &lt;boost/type_erasure/exception.hpp&gt;
Header &lt;boost/type_erasure/free.hpp&gt;
Header &lt;boost/type_erasure/is_empty.hpp&gt;
Header &lt;boost/type_erasure/is_placeholder.hpp&gt;
Header &lt;boost/type_erasure/is_subconcept.hpp&gt;
Header &lt;boost/type_erasure/iterator.hpp&gt;
Header &lt;boost/type_erasure/member.hpp&gt;
Header &lt;boost/type_erasure/operators.hpp&gt;
Header &lt;boost/type_erasure/param.hpp&gt;
Header &lt;boost/type_erasure/placeholder.hpp&gt;
Header &lt;boost/type_erasure/placeholder_of.hpp&gt;
Header &lt;boost/type_erasure/rebind_any.hpp&gt;
Header &lt;boost/type_erasure/register_binding.hpp&gt;
Header &lt;boost/type_erasure/relaxed.hpp&gt;
Header &lt;boost/type_erasure/require_match.hpp&gt;
Header &lt;boost/type_erasure/same_type.hpp&gt;
Header &lt;boost/type_erasure/static_binding.hpp&gt;
Header &lt;boost/type_erasure/tuple.hpp&gt;
Header &lt;boost/type_erasure/typeid_of.hpp&gt;

Rationale

Why
      do I have to specify the presence of a destructor explicitly?
Why
      non-member functions?
Why are the
      placeholders called _a, _b and not _1
      _2
Why not use boost::ref
      for references?

Future Work
Acknowledgements
Related Work




Introduction


      The Boost.TypeErasure library provides runtime polymorphism in C++ that is
      more flexible than that provided by the core language.
    

      C++ has two distinct kinds of polymorphism, virtual functions and templates,
      each of which has its own advantages and disadvantages.
    


          Virtual functions are not resolved until runtime, while templates are always
          resolved at compile time. If your types can vary at runtime (for example,
          if they depend on user input), then static polymorphism with templates
          doesn't help much.
        

          Virtual functions can be used with separate compilation. The body of a
          template has to be available in every translation unit in which it is used,
          slowing down compiles and increasing rebuilds.
        

          Virtual functions automatically make the requirements on the arguments
          explicit. Templates are only checked when they're instantiated, requiring
          extra work in testing, assertions, and documentation.
        

          The compiler creates a new copy of each function template every time it
          is instantiated. This allows better optimization, because the compiler
          knows everything statically, but it also causes a significant increase
          of binary sizes.
        

          Templates support Value semantics. Objects that "behave like an int"
          and are not shared are easier to reason about. To use virtual functions,
          on the other hand, you have to use (smart) pointers or references.
        

          Template libraries can allow third-party types to be adapted non-intrusively
          for seamless interoperability. With virtual functions, you have to create
          a wrapper that inherits from the base class.
        

          Templates can handle constraints involving multiple types. For example,
          std::for_each takes an iterator range and a function that can be called
          on the elements of the range. Virtual functions aren't really able to express
          such constraints.
        


      The Boost.TypeErasure library combines the superior abstraction capabilities
      of templates, with the runtime flexibility of virtual functions.
    

      Boost includes several special cases of this kind of polymorphism:
    


          boost::any for CopyConstructible types.
        

          boost::function for objects that can be called
          like functions.
        

          Boost.Range provides any_iterator.
        


      Boost.TypeErasure generalizes this to support arbitrary requirements and provides
      a predefined set of common concepts
    









\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_typeerasure.html
Macro BOOST_ACCUMULATORS_IGNORE_GLOBAL\3



Macro BOOST_ACCUMULATORS_IGNORE_GLOBAL











Home
Libraries
People
FAQ
More








Macro BOOST_ACCUMULATORS_IGNORE_GLOBAL
BOOST_ACCUMULATORS_IGNORE_GLOBAL

Synopsis
// In header: &lt;boost/accumulators/accumulators_fwd.hpp&gt;

BOOST_ACCUMULATORS_IGNORE_GLOBAL(X)

Copyright © 2005, 2006 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_ACCUMU_1_3_2_6_2_3_6.html
Boost.Container Header Reference\3



Boost.Container Header Reference











Home
Libraries
People
FAQ
More







Boost.Container Header Reference

Header &lt;boost/container/adaptive_pool.hpp&gt;
Header &lt;boost/container/allocator.hpp&gt;
Header &lt;boost/container/allocator_traits.hpp&gt;
Header &lt;boost/container/container_fwd.hpp&gt;
Header &lt;boost/container/deque.hpp&gt;
Header &lt;boost/container/pmr/deque.hpp&gt;
Header &lt;boost/container/devector.hpp&gt;
Header &lt;boost/container/pmr/devector.hpp&gt;
Header &lt;boost/container/flat_map.hpp&gt;
Header &lt;boost/container/pmr/flat_map.hpp&gt;
Header &lt;boost/container/flat_set.hpp&gt;
Header &lt;boost/container/pmr/flat_set.hpp&gt;
Header &lt;boost/container/list.hpp&gt;
Header &lt;boost/container/pmr/list.hpp&gt;
Header &lt;boost/container/map.hpp&gt;
Header &lt;boost/container/pmr/map.hpp&gt;
Header &lt;boost/container/new_allocator.hpp&gt;
Header &lt;boost/container/node_allocator.hpp&gt;
Header &lt;boost/container/node_handle.hpp&gt;
Header &lt;boost/container/options.hpp&gt;
Header &lt;boost/container/pmr/global_resource.hpp&gt;
Header &lt;boost/container/pmr/memory_resource.hpp&gt;
Header &lt;boost/container/pmr/monotonic_buffer_resource.hpp&gt;
Header &lt;boost/container/pmr/polymorphic_allocator.hpp&gt;
Header &lt;boost/container/pmr/pool_options.hpp&gt;
Header &lt;boost/container/pmr/resource_adaptor.hpp&gt;
Header &lt;boost/container/pmr/synchronized_pool_resource.hpp&gt;
Header &lt;boost/container/pmr/unsynchronized_pool_resource.hpp&gt;
Header &lt;boost/container/scoped_allocator.hpp&gt;
Header &lt;boost/container/scoped_allocator_fwd.hpp&gt;
Header &lt;boost/container/pmr/set.hpp&gt;
Header &lt;boost/container/set.hpp&gt;
Header &lt;boost/container/pmr/slist.hpp&gt;
Header &lt;boost/container/slist.hpp&gt;
Header &lt;boost/container/pmr/small_vector.hpp&gt;
Header &lt;boost/container/small_vector.hpp&gt;
Header &lt;boost/container/pmr/stable_vector.hpp&gt;
Header &lt;boost/container/stable_vector.hpp&gt;
Header &lt;boost/container/static_vector.hpp&gt;
Header &lt;boost/container/pmr/string.hpp&gt;
Header &lt;boost/container/string.hpp&gt;
Header &lt;boost/container/throw_exception.hpp&gt;
Header &lt;boost/container/uses_allocator.hpp&gt;
Header &lt;boost/container/uses_allocator_fwd.hpp&gt;
Header &lt;boost/container/pmr/vector.hpp&gt;
Header &lt;boost/container/vector.hpp&gt;



Header &lt;boost/container/adaptive_pool.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, std::size_t NodesPerBlock = ADP_nodes_per_block, 
             std::size_t MaxFreeBlocks = ADP_max_free_blocks, 
             std::size_t OverheadPercent = ADP_overhead_percent BOOST_CONTAINER_DOCIGN(  BOOST_MOVE_I unsigned Version  )&gt; 
      class adaptive_pool;
    template&lt;typename T, std::size_t NodesPerBlock = ADP_nodes_per_block, 
             std::size_t MaxFreeBlocks = ADP_max_free_blocks, 
             std::size_t OverheadPercent = ADP_overhead_percent, 
             unsigned Version = 2&gt; 
      class private_adaptive_pool;
  }
}



Header &lt;boost/container/allocator.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, unsigned Version = 2, 
             unsigned int AllocationDisableMask = 0&gt; 
      class allocator;
  }
}



Header &lt;boost/container/allocator_traits.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename Allocator&gt; struct allocator_traits;
  }
}



Header &lt;boost/container/container_fwd.hpp&gt;
This header file forward declares the following containers:

boost::container::vector
boost::container::stable_vector
boost::container::static_vector
boost::container::small_vector_base
boost::container::small_vector
boost::container::devector
boost::container::slist
boost::container::list
boost::container::set
boost::container::multiset
boost::container::map
boost::container::multimap
boost::container::flat_set
boost::container::flat_multiset
boost::container::flat_map
boost::container::flat_multimap
boost::container::basic_string
boost::container::string
boost::container::wstring



Forward declares the following allocators:

boost::container::allocator
boost::container::node_allocator
boost::container::adaptive_pool



Forward declares the following polymorphic resource classes:

boost::container::pmr::memory_resource
boost::container::pmr::polymorphic_allocator
boost::container::pmr::monotonic_buffer_resource
boost::container::pmr::pool_options
boost::container::pmr::unsynchronized_pool_resource
boost::container::pmr::synchronized_pool_resource



And finally it defines the following types 
namespace boost {
  namespace container {
    struct default_init_t;
    struct ordered_range_t;
    struct ordered_unique_range_t;

    static const ordered_range_t ordered_range;
    static const ordered_unique_range_t ordered_unique_range;
    static const default_init_t default_init;
  }
}



Header &lt;boost/container/deque.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, typename Allocator = void, typename Options = void&gt; 
      class deque;
    template&lt;typename InputIterator&gt;  deque(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename Allocator&gt; 
       deque(InputIterator, InputIterator, Allocator const &amp;);
  }
}



Header &lt;boost/container/pmr/deque.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T&gt; struct deque_of;

      typedef boost::container::deque&lt; T, polymorphic_allocator&lt; T &gt; &gt; deque;
    }
  }
}



Header &lt;boost/container/devector.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, typename A = void, typename Options = void&gt; 
      class devector;

    struct reserve_only_tag_t;
    struct reserve_uninitialized_t;
    struct review_implementation_t;
  }
}



Header &lt;boost/container/pmr/devector.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T, typename GrowthPolicy = growth_factor_60&gt; 
        struct devector_of;

      typedef boost::container::devector&lt; T, GrowthPolicy, polymorphic_allocator&lt; T &gt; &gt; devector;
    }
  }
}



Header &lt;boost/container/flat_map.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, 
             typename AllocatorOrContainer = new_allocator&lt; std::pair&lt; Key, T&gt; &gt; &gt; 
      class flat_map;
    template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, 
             typename AllocatorOrContainer = new_allocator&lt; std::pair&lt; Key, T&gt; &gt; &gt; 
      class flat_multimap;
    template&lt;typename InputIterator&gt;  flat_map(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_map(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_map(InputIterator, InputIterator, Compare const &amp;, 
                Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       flat_map(ordered_unique_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_map(ordered_unique_range_t, InputIterator, InputIterator, 
                AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_map(ordered_unique_range_t, InputIterator, InputIterator, 
                Compare const &amp;, Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       flat_multimap(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_multimap(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_multimap(InputIterator, InputIterator, Compare const &amp;, 
                     Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       flat_multimap(ordered_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_multimap(ordered_range_t, InputIterator, InputIterator, 
                     AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_multimap(ordered_range_t, InputIterator, InputIterator, 
                     Compare const &amp;, Allocator const &amp;);
  }
}



Header &lt;boost/container/pmr/flat_map.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt; &gt; 
        struct flat_map_of;
      template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt; &gt; 
        struct flat_multimap_of;

      typedef boost::container::flat_map&lt; Key, T, Compare, polymorphic_allocator&lt; std::pair&lt; Key, T &gt; &gt; &gt; flat_map;
      typedef boost::container::flat_multimap&lt; Key, T, Compare, polymorphic_allocator&lt; std::pair&lt; Key, T &gt; &gt; &gt; flat_multimap;
    }
  }
}



Header &lt;boost/container/flat_set.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, 
             typename AllocatorOrContainer = new_allocator&lt;Key&gt; &gt; 
      class flat_multiset;
    template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, 
             typename AllocatorOrContainer = new_allocator&lt;Key&gt; &gt; 
      class flat_set;
    template&lt;typename InputIterator&gt;  flat_set(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_set(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_set(InputIterator, InputIterator, Compare const &amp;, 
                Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       flat_set(ordered_unique_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_set(ordered_unique_range_t, InputIterator, InputIterator, 
                AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_set(ordered_unique_range_t, InputIterator, InputIterator, 
                Compare const &amp;, Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       flat_multiset(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_multiset(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_multiset(InputIterator, InputIterator, Compare const &amp;, 
                     Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       flat_multiset(ordered_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       flat_multiset(ordered_range_t, InputIterator, InputIterator, 
                     AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       flat_multiset(ordered_range_t, InputIterator, InputIterator, 
                     Compare const &amp;, Allocator const &amp;);
  }
}



Header &lt;boost/container/pmr/flat_set.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename Key, typename Compare = std::less&lt;Key&gt; &gt; 
        struct flat_multiset_of;
      template&lt;typename Key, typename Compare = std::less&lt;Key&gt; &gt; 
        struct flat_set_of;

      typedef boost::container::flat_set&lt; Key, Compare, polymorphic_allocator&lt; Key &gt; &gt; flat_set;
      typedef boost::container::flat_multiset&lt; Key, Compare, polymorphic_allocator&lt; Key &gt; &gt; flat_multiset;
    }
  }
}



Header &lt;boost/container/list.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, typename Allocator = void&gt; class list;
    template&lt;typename InputIterator&gt;  list(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename ValueAllocator&gt; 
       list(InputIterator, InputIterator, ValueAllocator const &amp;);
  }
}



Header &lt;boost/container/pmr/list.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T&gt; struct list_of;

      typedef boost::container::list&lt; T, polymorphic_allocator&lt; T &gt; &gt; list;
    }
  }
}



Header &lt;boost/container/map.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, 
             typename Allocator = void, 
             typename Options = tree_assoc_defaults&gt; 
      class map;
    template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, 
             typename Allocator = new_allocator&lt; std::pair&lt; const Key, T&gt; &gt;, 
             typename Options = tree_assoc_defaults&gt; 
      class multimap;
    template&lt;typename InputIterator&gt;  map(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       map(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       map(InputIterator, InputIterator, Compare const &amp;, Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       map(ordered_unique_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       map(ordered_unique_range_t, InputIterator, InputIterator, 
           AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       map(ordered_unique_range_t, InputIterator, InputIterator, 
           Compare const &amp;, Allocator const &amp;);
    template&lt;typename InputIterator&gt;  multimap(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       multimap(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       multimap(InputIterator, InputIterator, Compare const &amp;, 
                Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       multimap(ordered_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       multimap(ordered_range_t, InputIterator, InputIterator, 
                AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       multimap(ordered_range_t, InputIterator, InputIterator, 
                Compare const &amp;, Allocator const &amp;);
  }
}



Header &lt;boost/container/pmr/map.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, 
               typename Options = void&gt; 
        struct map_of;
      template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, 
               typename Options = void&gt; 
        struct multimap_of;

      typedef boost::container::map&lt; Key, T, Compare, polymorphic_allocator&lt; std::pair&lt; const Key, T &gt; &gt;, Options &gt; map;
      typedef boost::container::multimap&lt; Key, T, Compare, polymorphic_allocator&lt; std::pair&lt; const Key, T &gt; &gt;, Options &gt; multimap;
    }
  }
}



Header &lt;boost/container/new_allocator.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T&gt; class new_allocator;

    template&lt;&gt; class new_allocator&lt;void&gt;;
  }
}



Header &lt;boost/container/node_allocator.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, 
             std::size_t NodesPerBlock = NodeAlloc_nodes_per_block&gt; 
      class node_allocator;
  }
}



Header &lt;boost/container/node_handle.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename Iterator, typename NodeType&gt; 
      struct insert_return_type_base;

    template&lt;typename NodeAllocator, typename KeyMapped = void&gt; 
      class node_handle;
  }
}



Header &lt;boost/container/options.hpp&gt;
namespace boost {
  namespace container {
    template&lt;std::size_t BlockBytes&gt; struct block_bytes;
    template&lt;std::size_t BlockSize&gt; struct block_size;
    template&lt;bool Enabled&gt; struct cache_begin;
    template&lt;class ... Options&gt; struct deque_options;
    template&lt;class ... Options&gt; struct devector_options;
    template&lt;bool Enabled&gt; struct fastmod_buckets;
    template&lt;typename GrowthFactor&gt; struct growth_factor;
    struct growth_factor_100;
    struct growth_factor_50;
    struct growth_factor_60;
    template&lt;class ... Options&gt; struct hash_assoc_options;
    template&lt;std::size_t Alignment&gt; struct inplace_alignment;
    template&lt;bool Enabled&gt; struct linear_buckets;
    template&lt;bool Enabled&gt; struct optimize_size;
    template&lt;class ... Options&gt; struct small_vector_options;
    template&lt;class ... Options&gt; struct static_vector_options;
    template&lt;bool Enabled&gt; struct store_hash;
    template&lt;typename StoredSizeType&gt; struct stored_size;
    template&lt;bool ThrowOnOverflow&gt; struct throw_on_overflow;
    template&lt;class ... Options&gt; struct tree_assoc_options;
    template&lt;tree_type_enum TreeType&gt; struct tree_type;
    template&lt;class ... Options&gt; struct vector_options;

    enum tree_type_enum;
    typedef typename boost::container::tree_assoc_options&lt; Options... &gt;::type tree_assoc_options_t;
    typedef typename boost::container::hash_assoc_options&lt; Options... &gt;::type hash_assoc_options_t;
    typedef typename boost::container::vector_options&lt; Options... &gt;::type vector_options_t;
    typedef typename boost::container::small_vector_options&lt; Options... &gt;::type small_vector_options_t;
    typedef typename boost::container::static_vector_options&lt; Options... &gt;::type static_vector_options_t;
    typedef typename boost::container::devector_options&lt; Options... &gt;::type devector_options_t;
    typedef typename boost::container::deque_options&lt; Options... &gt;::type deque_options_t;
  }
}



Header &lt;boost/container/pmr/global_resource.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      memory_resource * new_delete_resource();
      memory_resource * null_memory_resource();
      memory_resource * set_default_resource(memory_resource *);
      memory_resource * get_default_resource();
    }
  }
}



Header &lt;boost/container/pmr/memory_resource.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      class memory_resource;
    }
  }
}



Header &lt;boost/container/pmr/monotonic_buffer_resource.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      class monotonic_buffer_resource;
    }
  }
}



Header &lt;boost/container/pmr/polymorphic_allocator.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T&gt; class polymorphic_allocator;
      template&lt;typename T1, typename T2&gt; 
        bool operator==(const polymorphic_allocator&lt; T1 &gt; &amp;, 
                        const polymorphic_allocator&lt; T2 &gt; &amp;);
      template&lt;typename T1, typename T2&gt; 
        bool operator!=(const polymorphic_allocator&lt; T1 &gt; &amp;, 
                        const polymorphic_allocator&lt; T2 &gt; &amp;);
    }
  }
}



Header &lt;boost/container/pmr/pool_options.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      struct pool_options;
    }
  }
}



Header &lt;boost/container/pmr/resource_adaptor.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename Allocator&gt; class resource_adaptor_imp;
      typedef resource_adaptor_imp&lt; typename allocator_traits&lt; Allocator &gt;::template rebind_alloc&lt; char &gt; &gt; resource_adaptor;
    }
    namespace pmr_dtl {
      template&lt;typename T&gt; struct max_allocator_alignment;

      template&lt;typename T&gt; 
        struct max_allocator_alignment&lt;::boost::container::new_allocator&lt; T &gt;&gt;;
      template&lt;typename T&gt; struct max_allocator_alignment&lt;std::allocator&lt; T &gt;&gt;;
    }
  }
}



Header &lt;boost/container/pmr/synchronized_pool_resource.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      class synchronized_pool_resource;
    }
  }
}



Header &lt;boost/container/pmr/unsynchronized_pool_resource.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      class unsynchronized_pool_resource;
    }
  }
}



Header &lt;boost/container/scoped_allocator.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename OuterAlloc, typename ... InnerAllocs&gt; 
      class scoped_allocator_adaptor;
    template&lt;typename OuterA1, typename OuterA2, 
             BOOST_CONTAINER_SCOPEDALLOC_ALLINNERCLASS &gt; 
      bool operator==(const scoped_allocator_adaptor&lt; OuterA1, InnerAllocs... &gt; &amp; a, 
                      const scoped_allocator_adaptor&lt; OuterA2, InnerAllocs... &gt; &amp; b);
    template&lt;typename OuterA1, typename OuterA2, 
             BOOST_CONTAINER_SCOPEDALLOC_ALLINNERCLASS &gt; 
      bool operator!=(const scoped_allocator_adaptor&lt; OuterA1, InnerAllocs... &gt; &amp; a, 
                      const scoped_allocator_adaptor&lt; OuterA2, InnerAllocs... &gt; &amp; b);
  }
}



Header &lt;boost/container/scoped_allocator_fwd.hpp&gt;
This header file forward declares boost::container::scoped_allocator_adaptor 



Header &lt;boost/container/pmr/set.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, 
               typename Options = void&gt; 
        struct multiset_of;
      template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, 
               typename Options = void&gt; 
        struct set_of;

      typedef boost::container::set&lt; Key, Compare, polymorphic_allocator&lt; Key &gt;, Options &gt; set;
      typedef boost::container::multiset&lt; Key, Compare, polymorphic_allocator&lt; Key &gt;, Options &gt; multiset;
    }
  }
}



Header &lt;boost/container/set.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, 
             typename Allocator = new_allocator&lt;Key&gt;, 
             typename Options = tree_assoc_defaults&gt; 
      class multiset;
    template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, 
             typename Allocator = new_allocator&lt;Key&gt;, 
             typename Options = void&gt; 
      class set;
    template&lt;typename InputIterator&gt;  set(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       set(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       set(InputIterator, InputIterator, Compare const &amp;, Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       set(ordered_unique_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       set(ordered_unique_range_t, InputIterator, InputIterator, 
           AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       set(ordered_unique_range_t, InputIterator, InputIterator, 
           Compare const &amp;, Allocator const &amp;);
    template&lt;typename InputIterator&gt;  multiset(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       multiset(InputIterator, InputIterator, AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       multiset(InputIterator, InputIterator, Compare const &amp;, 
                Allocator const &amp;);
    template&lt;typename InputIterator&gt; 
       multiset(ordered_range_t, InputIterator, InputIterator);
    template&lt;typename InputIterator, typename AllocatorOrCompare&gt; 
       multiset(ordered_range_t, InputIterator, InputIterator, 
                AllocatorOrCompare const &amp;);
    template&lt;typename InputIterator, typename Compare, typename Allocator, 
             typename  = dtl::require_nonallocator_t&lt;Compare&gt;, 
             typename  = dtl::require_allocator_t&lt;Allocator&gt; &gt; 
       multiset(ordered_range_t, InputIterator, InputIterator, 
                Compare const &amp;, Allocator const &amp;);
  }
}



Header &lt;boost/container/pmr/slist.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T&gt; struct slist_of;

      typedef boost::container::slist&lt; T, polymorphic_allocator&lt; T &gt; &gt; slist;
    }
  }
}



Header &lt;boost/container/slist.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, typename Allocator = void&gt; class slist;
    template&lt;typename InpIt&gt;  slist(InpIt, InpIt);
    template&lt;typename InpIt, typename Allocator&gt; 
       slist(InpIt, InpIt, Allocator const &amp;);
  }
}namespace std {
  template&lt;typename T, typename ValueAllocator&gt; 
    class insert_iterator&lt;boost::container::slist&lt; T, ValueAllocator &gt;&gt;;
}



Header &lt;boost/container/pmr/small_vector.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T, std::size_t N&gt; struct small_vector_of;

      typedef boost::container::small_vector&lt; T, N, polymorphic_allocator&lt; T &gt; &gt; small_vector;
    }
  }
}



Header &lt;boost/container/small_vector.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, std::size_t N, typename Allocator = void, 
             typename Options = void&gt; 
      class small_vector;
    template&lt;typename T, typename VoidAlloc = void, typename Options = void&gt; 
      class small_vector_allocator;
    template&lt;typename T, typename SecAlloc, typename Options&gt; 
      class small_vector_base;

    template&lt;typename T, std::size_t N, std::size_t Alignment&gt; 
      struct small_vector_storage;

    template&lt;typename T, std::size_t Alignment&gt; 
      struct small_vector_storage&lt;T, 0u, Alignment&gt;;
    namespace dtl {
      template&lt;typename Options&gt; struct get_small_vector_opt;

      template&lt;&gt; struct get_small_vector_opt&lt;void&gt;;

      template&lt;typename Options&gt; struct get_vopt_from_svopt;

      template&lt;&gt; struct get_vopt_from_svopt&lt;void&gt;;

      template&lt;typename T, typename SecAlloc, typename Options&gt; 
        struct vector_for_small_vector;
    }
  }
}



Header &lt;boost/container/pmr/stable_vector.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T&gt; struct stable_vector_of;

      typedef boost::container::stable_vector&lt; T, polymorphic_allocator&lt; T &gt; &gt; stable_vector;
    }
  }
}



Header &lt;boost/container/stable_vector.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, typename Allocator = void&gt; class stable_vector;
    template&lt;typename InputIterator&gt; 
       stable_vector(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename Allocator&gt; 
       stable_vector(InputIterator, InputIterator, Allocator const &amp;);
  }
}



Header &lt;boost/container/static_vector.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, std::size_t Capacity, typename Options = void&gt; 
      class static_vector;
    template&lt;typename V, std::size_t C1, std::size_t C2, typename O1, 
             typename O2&gt; 
      bool operator==(static_vector&lt; V, C1, O1 &gt; const &amp;, 
                      static_vector&lt; V, C2, O2 &gt; const &amp;);
    template&lt;typename V, std::size_t C1, std::size_t C2, typename O1, 
             typename O2&gt; 
      bool operator!=(static_vector&lt; V, C1, O1 &gt; const &amp;, 
                      static_vector&lt; V, C2, O2 &gt; const &amp;);
    template&lt;typename V, std::size_t C1, std::size_t C2, typename O1, 
             typename O2&gt; 
      bool operator&lt;(static_vector&lt; V, C1, O1 &gt; const &amp;, 
                     static_vector&lt; V, C2, O2 &gt; const &amp;);
    template&lt;typename V, std::size_t C1, std::size_t C2, typename O1, 
             typename O2&gt; 
      bool operator&gt;(static_vector&lt; V, C1, O1 &gt; const &amp;, 
                     static_vector&lt; V, C2, O2 &gt; const &amp;);
    template&lt;typename V, std::size_t C1, std::size_t C2, typename O1, 
             typename O2&gt; 
      bool operator&lt;=(static_vector&lt; V, C1, O1 &gt; const &amp;, 
                      static_vector&lt; V, C2, O2 &gt; const &amp;);
    template&lt;typename V, std::size_t C1, std::size_t C2, typename O1, 
             typename O2&gt; 
      bool operator&gt;=(static_vector&lt; V, C1, O1 &gt; const &amp;, 
                      static_vector&lt; V, C2, O2 &gt; const &amp;);
    template&lt;typename V, std::size_t C1, std::size_t C2, typename O1, 
             typename O2&gt; 
      void swap(static_vector&lt; V, C1, O1 &gt; &amp;, static_vector&lt; V, C2, O2 &gt; &amp;);
  }
}



Header &lt;boost/container/pmr/string.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt; &gt; 
        struct basic_string_of;

      typedef boost::container::basic_string&lt; CharT, Traits, polymorphic_allocator&lt; CharT &gt; &gt; basic_string;
      typedef basic_string_of&lt; char &gt;::type string;
      typedef basic_string_of&lt; wchar_t &gt;::type wstring;
    }
  }
}



Header &lt;boost/container/string.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;, 
             typename Allocator = void&gt; 
      class basic_string;
    typedef basic_string&lt; char,std::char_traits&lt; char &gt;,new_allocator&lt; char &gt; &gt; string;
    typedef basic_string&lt; wchar_t,std::char_traits&lt; wchar_t &gt;,new_allocator&lt; wchar_t &gt; &gt; wstring;
    template&lt;typename InputIterator&gt; 
       basic_string(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename Allocator&gt; 
       basic_string(InputIterator, InputIterator, Allocator const &amp;);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; x, 
                basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; x, 
                const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(const CharT * s, basic_string&lt; CharT, Traits, Allocator &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(basic_string&lt; CharT, Traits, Allocator &gt; x, const CharT * s);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(CharT c, basic_string&lt; CharT, Traits, Allocator &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      basic_string&lt; CharT, Traits, Allocator &gt; 
      operator+(basic_string&lt; CharT, Traits, Allocator &gt; x, const CharT c);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator==(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator==(const CharT * s, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator==(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const CharT * s);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator==(BasicStringView&lt; CharT, Traits &gt; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator==(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      BasicStringView&lt; CharT, Traits &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator!=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator!=(const CharT * s, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator!=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const CharT * s);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator!=(BasicStringView&lt; CharT, Traits &gt; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator!=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      BasicStringView&lt; CharT, Traits &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&lt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                     const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&lt;(const CharT * s, 
                     const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&lt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                     const CharT * s);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&lt;(BasicStringView&lt; CharT, Traits &gt; x, 
                     const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&lt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                     BasicStringView&lt; CharT, Traits &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&gt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                     const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&gt;(const CharT * s, 
                     const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&gt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                     const CharT * s);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&gt;(BasicStringView&lt; CharT, Traits &gt; x, 
                     const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&gt;(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                     BasicStringView&lt; CharT, Traits &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&lt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&lt;=(const CharT * s, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&lt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const CharT * s);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&lt;=(BasicStringView&lt; CharT, Traits &gt; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&lt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      BasicStringView&lt; CharT, Traits &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&gt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&gt;=(const CharT * s, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      bool operator&gt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      const CharT * s);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&gt;=(BasicStringView&lt; CharT, Traits &gt; x, 
                      const basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator, 
             template&lt; class, class &gt; class BasicStringView&gt; 
      bool operator&gt;=(const basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                      BasicStringView&lt; CharT, Traits &gt; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      void swap(basic_string&lt; CharT, Traits, Allocator &gt; &amp; x, 
                basic_string&lt; CharT, Traits, Allocator &gt; &amp; y);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      std::basic_ostream&lt; CharT, Traits &gt; &amp; 
      operator&lt;&lt;(std::basic_ostream&lt; CharT, Traits &gt; &amp; os, 
                 const basic_string&lt; CharT, Traits, Allocator &gt; &amp; s);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      std::basic_istream&lt; CharT, Traits &gt; &amp; 
      operator&gt;&gt;(std::basic_istream&lt; CharT, Traits &gt; &amp; is, 
                 basic_string&lt; CharT, Traits, Allocator &gt; &amp; s);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      std::basic_istream&lt; CharT, Traits &gt; &amp; 
      getline(std::istream &amp; is, basic_string&lt; CharT, Traits, Allocator &gt; &amp; s, 
              CharT delim);
    template&lt;typename CharT, typename Traits, typename Allocator&gt; 
      std::basic_istream&lt; CharT, Traits &gt; &amp; 
      getline(std::basic_istream&lt; CharT, Traits &gt; &amp; is, 
              basic_string&lt; CharT, Traits, Allocator &gt; &amp; s);
    template&lt;typename Ch, typename Allocator&gt; 
      std::size_t hash_value(basic_string&lt; Ch, std::char_traits&lt; Ch &gt;, Allocator &gt; const &amp; v);
  }
}



Header &lt;boost/container/throw_exception.hpp&gt;
namespace boost {
  namespace container {
    class bad_alloc;
    class exception;
    class length_error;
    class logic_error;
    class out_of_range;
    class runtime_error;

    typedef bad_alloc bad_alloc_t;
    typedef out_of_range out_of_range_t;
    typedef length_error length_error_t;
    typedef logic_error logic_error_t;
    typedef runtime_error runtime_error_t;
    void throw_bad_alloc();
    void throw_out_of_range(const char *);
    void throw_length_error(const char *);
    void throw_logic_error(const char *);
    void throw_runtime_error(const char *);
  }
}



Header &lt;boost/container/uses_allocator.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T&gt; struct constructible_with_allocator_prefix;
    template&lt;typename T&gt; struct constructible_with_allocator_suffix;
    template&lt;typename T, typename Allocator&gt; struct uses_allocator;
  }
}



Header &lt;boost/container/uses_allocator_fwd.hpp&gt;
This header forward declares boost::container::constructible_with_allocator_prefix, boost::container::constructible_with_allocator_suffix and boost::container::uses_allocator. Also defines the following types: 
namespace boost {
  namespace container {
    struct erased_type;
    typedef unspecified allocator_arg_t;

    static allocator_arg_t allocator_arg;
  }
}



Header &lt;boost/container/pmr/vector.hpp&gt;
namespace boost {
  namespace container {
    namespace pmr {
      template&lt;typename T&gt; struct vector_of;

      typedef boost::container::vector&lt; T, polymorphic_allocator&lt; T &gt; &gt; vector;
    }
  }
}



Header &lt;boost/container/vector.hpp&gt;
namespace boost {
  namespace container {
    template&lt;typename T, typename A = void, typename Options = void&gt; 
      class vector;
    template&lt;typename InputIterator&gt;  vector(InputIterator, InputIterator);
    template&lt;typename InputIterator, typename Allocator&gt; 
       vector(InputIterator, InputIterator, Allocator const &amp;);
  }
}


Copyright © 2009-2018 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/boost_container_header_reference.html
Chapter 46. Boost.Concept_Check\3



Chapter 46. Boost.Concept_Check











Home
Libraries
People
FAQ
More








Chapter 46. Boost.Concept_Check

Jeremy Siek



Table of Contents

Concept reference
Concepts





Concept reference
Copyright © 2001, 2002 Indiana University
Copyright © 2000, 2001 University of Notre Dame du Lac
Copyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew Lumsdaine
Copyright © 1996-1999 Silicon Graphics Computer Systems, Inc.
Copyright © 1994 Hewlett-Packard Company

Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.


Concepts


Concepts

Assignable
InputIterator
OutputIterator
ForwardIterator
BidirectionalIterator
RandomAccessIterator
DefaultConstructible
CopyConstructible
EqualityComparable
LessThanComparable
SignedInteger











\3https://www.boost.org/doc/libs/1_84_0/doc/html/concept_check.html
Macro BOOST_PFR_FUNCTIONS_FOR\3



Macro BOOST_PFR_FUNCTIONS_FOR











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_FUNCTIONS_FOR
BOOST_PFR_FUNCTIONS_FOR

Synopsis
// In header: &lt;boost/pfr/functions_for.hpp&gt;

BOOST_PFR_FUNCTIONS_FOR(T)

Description
Defines comparison and stream operators for T along with hash_value function.
Example: 
#include &lt;boost/pfr/functions_for.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
BOOST_PFR_FUNCTIONS_FOR(comparable_struct)
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
comparable_struct s2 {0, 1, "Hello", false, 6,7,8,9,10,11111};
assert(s1 &lt; s2);
std::cout &lt;&lt; s1 &lt;&lt; std::endl; // Outputs: {0, 1, H, e, l, l, o, , , 0, 6, 7, 8, 9, 10, 11}

See Also :   'Three ways of getting operators'   for other ways to define operators and more details.
Defines following for T: 
bool operator==(const T&amp; lhs, const T&amp; rhs);
bool operator!=(const T&amp; lhs, const T&amp; rhs);
bool operator&lt; (const T&amp; lhs, const T&amp; rhs);
bool operator&gt; (const T&amp; lhs, const T&amp; rhs);
bool operator&lt;=(const T&amp; lhs, const T&amp; rhs);
bool operator&gt;=(const T&amp; lhs, const T&amp; rhs);

template &lt;class Char, class Traits&gt;
std::basic_ostream&lt;Char, Traits&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Char, Traits&gt;&amp; out, const T&amp; value);

template &lt;class Char, class Traits&gt;
std::basic_istream&lt;Char, Traits&gt;&amp; operator&gt;&gt;(std::basic_istream&lt;Char, Traits&gt;&amp; in, T&amp; value);

// helper function for Boost unordered containers and boost::hash&lt;&gt;.
std::size_t hash_value(const T&amp; value);

 


Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_FUNCTIONS_FOR.html
Macro BOOST_STL_INTERFACES_USE_DEDUCED_THIS\3



Macro BOOST_STL_INTERFACES_USE_DEDUCED_THIS











Home
Libraries
People
FAQ
More








Macro BOOST_STL_INTERFACES_USE_DEDUCED_THIS
BOOST_STL_INTERFACES_USE_DEDUCED_THIS

Synopsis
// In header: &lt;boost/stl_interfaces/config.hpp&gt;

BOOST_STL_INTERFACES_USE_DEDUCED_THIS

Copyright © 2019 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_STL__1_3_38_15_2_2_2.html
Concept InputIterator\3



Concept InputIterator











Home
Libraries
People
FAQ
More








Concept InputIterator
InputIterator


Description
An input iterator is an iterator that can read through a sequence of
  values.  It is single-pass (old values of the iterator cannot be
  re-used), and read-only.
An input iterator represents a position in a sequence.  Therefore, the
  iterator can point into the sequence (returning a value when dereferenced
  and being incrementable), or be off-the-end (and not dereferenceable or
  incrementable).


Refinement of

Assignable
DefaultConstructible
EqualityComparable



Associated types


value_type
std::iterator_traits&lt;Iter&gt;::value_type
The value type of the iterator (not necessarily what
    *i returns)


difference_type
std::iterator_traits&lt;Iter&gt;::difference_type
The difference type of the iterator


category
std::iterator_traits&lt;Iter&gt;::iterator_category
The category of the iterator




Notation

Iter
A type playing the role of iterator-type in the InputIterator concept.

i, j

Objects of type Iter
x
Object of type value_type



Type expressions

Category tag
category must be
                  derived from std::input_iterator_tag,  a model  of DefaultConstructible,  and  a model  of CopyConstructible.
                
Value type copy constructibility
value_type must be
                   a model  of CopyConstructible.
                
Difference type properties
difference_type must be
                   a model  of SignedInteger.
                



Valid expressions










Name
Expression
Type
Precondition
Semantics
Postcondition



Dereference
*i
Convertible to value_type
i is incrementable (not
    off-the-end)
 
 


Preincrement
++i
Iter &amp;
i is incrementable (not
    off-the-end)
 
 


Postincrement
i++

i is incrementable (not
    off-the-end)
Equivalent to (void)(++i)
i is dereferenceable or
    off-the-end


Postincrement and dereference
*i++
Convertible to value_type
i is incrementable (not
    off-the-end)
Equivalent to {value_type t = *i; ++i; return t;}
i is dereferenceable or
    off-the-end





Complexity

  All iterator operations must take amortized constant time.
  


Models
std::istream_iterator


See also

DefaultConstructible
EqualityComparable



Copyright © 2001, 2002 Indiana UniversityCopyright © 2000, 2001 University of Notre Dame du LacCopyright © 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright © 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright © 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at 
      http://www.boost.org/LICENSE_1_0.txt)
      
This product includes software developed at the University
      of Notre Dame and the Pervasive Technology Labs at Indiana
      University. For technical information contact Andrew Lumsdaine
      at the Pervasive Technology Labs at Indiana University.  For
      administrative and license questions contact the Advanced
      Research and Technology Institute at 351 West 10th Street.
      Indianapolis, Indiana 46202, phone 317-278-4100, fax
      317-274-5902.
Some concepts based on versions from the MTL draft manual
      and Boost Graph and Property Map documentation, the SGI Standard
      Template Library documentation and the Hewlett-Packard STL,
      under the following license: 
        
Permission to use, copy, modify, distribute and
        sell this software and its documentation for any purpose is
        hereby granted without fee, provided that the above copyright
        notice appears in all copies and that both that copyright
        notice and this permission notice appear in supporting
        documentation.  Silicon Graphics makes no representations
        about the suitability of this software for any purpose.  It is
        provided "as is" without express or implied
        warranty.







\3https://www.boost.org/doc/libs/1_84_0/doc/html/InputIterator.html
Macro BOOST_DLL_FORCE_NO_WEAK_EXPORTS\3



Macro BOOST_DLL_FORCE_NO_WEAK_EXPORTS











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_FORCE_NO_WEAK_EXPORTS
BOOST_DLL_FORCE_NO_WEAK_EXPORTS

Synopsis
// In header: &lt;boost/dll/alias.hpp&gt;

BOOST_DLL_FORCE_NO_WEAK_EXPORTS

Description
Define this macro to disable exporting weak symbols and start using the  BOOST_DLL_FORCE_ALIAS_INSTANTIATION. This may be useful for working around linker problems or to test your program for compatibility with linkers that do not support export of weak symbols. 


Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_FORCE_NO_idm4168.html
Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT\3



Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT











Home
Libraries
People
FAQ
More








Macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT
BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT — Indicates
        make_recursive_variant operates in
        an implementation-defined manner.

Synopsis
// In header: &lt;boost/variant/variant_fwd.hpp&gt;

BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT

Description
Defined only if
        make_recursive_variant does not
        operate as documented on the target compiler, but rather in an
        implementation-defined manner.
Implementation Note: If
        BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT is
        defined for the target compiler, the current implementation uses the
        MPL lambda mechanism to approximate the
        desired behavior. (In most cases, however, such compilers do not have
        full lambda support either.)


Copyright © 2002, 2003 Eric Friedman, Itay MamanCopyright © 2014-2023 Antony PolukhinDistributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at 
    http://www.boost.org/LICENSE_1_0.txt)
    







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_VARIANT_1_3_44_5_3_7.html
Macro BOOST_CRC_PARM_TYPE\3



Macro BOOST_CRC_PARM_TYPE











Home
Libraries
People
FAQ
More








Macro BOOST_CRC_PARM_TYPE
BOOST_CRC_PARM_TYPE

Synopsis
// In header: &lt;boost/crc.hpp&gt;

BOOST_CRC_PARM_TYPE

Copyright © 2001, 2003, 2012 Daryle Walker
        Distributed under the Boost Software License, Version 1.0. (See the accompanying
        file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_CRC_PARM_TYPE.html
Macro BOOST_UNITS_DEFAULT_CONVERSION\3



Macro BOOST_UNITS_DEFAULT_CONVERSION











Home
Libraries
People
FAQ
More








Macro BOOST_UNITS_DEFAULT_CONVERSION
BOOST_UNITS_DEFAULT_CONVERSION

Synopsis
// In header: &lt;boost/units/conversion.hpp&gt;

BOOST_UNITS_DEFAULT_CONVERSION(Source, Dest)

Description
Specifies the default conversion to be applied when no direct conversion is available. Source is a base unit. Dest is any unit with the same dimensions. 


Copyright © 2003-2008 Matthias Christian SchabelCopyright © 2007-2010 Steven
      Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_UNIT_1_3_43_10_2_7_5.html
Macro BOOST_PROTO_A_const_ref\3



Macro BOOST_PROTO_A_const_ref











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_A_const_ref
BOOST_PROTO_A_const_ref — 
      Generates sequences like
      
        A0 const &amp;,
        A1 const &amp;, …
        AN-1 const &amp;
      .
    

Synopsis
// In header: &lt;boost/proto/repeat.hpp&gt;

BOOST_PROTO_A_const_ref(N)

Description

        Intended for use with the BOOST_PROTO_REPEAT()
        and BOOST_PROTO_LOCAL_ITERATE() macros.
      

        BOOST_PROTO_A_const_ref(N) generates sequences like:
      

        
A0 const &amp;, A1 const &amp;, … AN-1 const &amp;

      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_A_const_ref.html
Macro BOOST_FWD_REF\3



Macro BOOST_FWD_REF











Home
Libraries
People
FAQ
More








Macro BOOST_FWD_REF
BOOST_FWD_REF

Synopsis
// In header: &lt;boost/move/core.hpp&gt;

BOOST_FWD_REF(TYPE)

Description
This macro is used to implement portable perfect forwarding as explained in the documentation. 


Copyright © 2008-2014 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_FWD_REF.html
MultiArray Concept\3



MultiArray Concept











Home
Libraries
People
FAQ
More







MultiArray Concept

Notation
Associated Types
Valid expressions
Complexity guarantees
Invariants
Associated Types for Views
Models

The MultiArray
concept defines an interface to hierarchically nested
containers.  It specifies operations for accessing elements,
traversing containers, and creating views
of array data.
MultiArray defines
a flexible memory model that accomodates
a variety of data layouts.


At each level (or dimension) of a MultiArray's
container hierarchy lie a set of ordered containers, each of which
contains the same number and type of values. The depth of this
container hierarchy is the MultiArray's dimensionality. 
MultiArray is recursively defined; the
containers at each level of the container hierarchy model
MultiArray as well. While each dimension of a MultiArray
has its own size, the list of sizes for all dimensions 
defines the shape of the entire MultiArray.
At the base of this hierarchy lie 1-dimensional
MultiArrays.  Their values are the contained
objects of interest and not part of the container hierarchy. These are
the MultiArray's elements.


Like other container concepts, MultiArray exports
iterators to traverse its values. In addition, values can be
addressed directly using the familiar bracket notation.


MultiArray also specifies
routines for creating
specialized views. A view lets you treat a 
subset of the underlying
elements in a MultiArray as though it were a separate
MultiArray. Since a view refers to the same underlying elements,
changes made to a view's elements will be reflected in the original
MultiArray. For
example, given a 3-dimensional "cube" of elements, a 2-dimensional
slice can be viewed as if it were an independent
MultiArray.

Views are created using index_gen and
index_range objects.
index_ranges denote elements from a certain
dimension that are to be included in a
view. index_gen aggregates range data and performs
bookkeeping to determine the view type to be returned.

MultiArray's operator[]
 must be passed the result
of N chained calls to 
index_gen::operator[], i.e.


indices[a0][a1]...[aN];



where N is the 
MultiArray's dimensionality and
indices an object of type index_gen.

The view type is dependent upon the number of degenerate dimensions
specified to index_gen.  A degenerate dimension
occurs when a single-index is specified to
index_gen for a certain dimension.  For example, if
indices is an object of type
index_gen, then the following example:


indices[index_range(0,5)][2][index_range(0,4)];



has a degenerate second dimension.  The view generated from the above
specification will have 2 dimensions with shape 5 x 4.
If the "2" above were replaced with
another index_range object, for example:


indices[index_range(0,5)][index_range(0,2)][index_range(0,4)];



then the view would have 3 dimensions.

MultiArray exports
information regarding the memory
layout of its contained elements. Its memory model for elements is
completely defined by 4 properties: the origin, shape, index bases,
and strides.  The origin is the address in memory of the element
accessed as a[0][0]...[0], where
a is a MultiArray. The shape is a list of numbers
specifying the size of containers at each dimension.  For example, the
first extent is the size of the outermost container, the second extent
is the size of its subcontainers, and so on. The index bases are a
list of signed values specifying the index of the first value in a
container. All containers at the same dimension share the same index
base.  Note that since positive index bases are
possible, the origin need not exist in order to determine the location
in memory of the MultiArray's elements.
  The strides determine how index values are mapped to memory offsets. 
They accomodate a
number of possible element layouts.  For example, the elements of a 2
dimensional array can be stored by row (i.e., the elements of each row
are stored contiguously) or by column (i.e., the elements of each
column are stored contiguously).


Two concept checking classes for the MultiArray concepts
(ConstMultiArrayConcept and
MutableMultiArrayConcept) are in the namespace
boost::multi_array_concepts in
&lt;boost/multi_array/concept_checks.hpp&gt;.



Notation
What follows are the descriptions of symbols that will be used
to describe the MultiArray interface.

Table 25.1. Notation







A
A type that is a model of MultiArray



a,b
Objects of type A



NumDims
The numeric dimension parameter associated with
A.


Dims
Some numeric dimension parameter such that 
0&lt;Dims&lt;NumDims.



indices
An object created by some number of chained calls
to index_gen::operator[](index_range).


index_list
An object whose type models
Collection



idx
A signed integral value.


tmp
An object of type
	      boost::array&lt;index,NumDims&gt;









Associated Types



Table 25.2. Associated Types






Type
Description



value_type
This is the value type of the container.
  If NumDims == 1, then this is
element. Otherwise, this is the value type of the
immediately nested containers.




reference


This is the reference type of the contained value. 
If NumDims == 1, then this is 
element&amp;. Otherwise, this is the same type as
template subarray&lt;NumDims-1&gt;::type.




const_reference


This is the const reference type of the contained value.
If NumDims == 1, then this is  
const element&amp;. Otherwise, this is the same
type as
template const_subarray&lt;NumDims-1&gt;::type.




size_type


This is an unsigned integral type.  It is primarily used to specify array shape.




difference_type


This is a signed integral type used to represent the distance between two
iterators. It is the same type as
std::iterator_traits&lt;iterator&gt;::difference_type.



iterator

This is an iterator over the values of A.
If NumDims == 1, then it models 

Random Access Iterator. 
Otherwise it models 

Random Access Traversal Iterator,

Readable Iterator,

Writable Iterator, and 

Output Iterator.




const_iterator


This is the const iterator over the values of A.




reverse_iterator


This is the reversed iterator, used to iterate backwards over the values of 
A.




const_reverse_iterator


This is the reversed const iterator.
A.




element


This is the type of objects stored at the base of the
hierarchy of MultiArrays. It is the same as
template subarray&lt;1&gt;::value_type




index


This is a signed integral type used for indexing into A. It 
is also used to represent strides and index bases.




index_gen


This type is used to create a tuple of index_ranges 
passed to operator[] to create
an array_view&lt;Dims&gt;::type object.




index_range


This type specifies a range of indices over some dimension of a
MultiArray.  This range will be visible through an 
array_view&lt;Dims&gt;::type object.




template subarray&lt;Dims&gt;::type


This is subarray type with Dims dimensions.
It is the reference type of the (NumDims - Dims)
dimension of A and also models
MultiArray.




template const_subarray&lt;Dims&gt;::type


This is the const subarray type.




template array_view&lt;Dims&gt;::type


This is the view type with Dims dimensions.  It is
returned by calling operator[](indices).
It models MultiArray.




template
const_array_view&lt;Dims&gt;::type


This is the const view type with Dims dimensions.









Valid expressions

Table 25.3. Valid Expressions







Expression
Return type
Semantics



A::dimensionality
size_type
This compile-time constant represents the number of
dimensions of the array (note that 
A::dimensionality == NumDims).


a.shape()
const size_type*

This returns a list of NumDims elements specifying the
extent of each array dimension.



a.strides()
const index*

This returns a list of NumDims elements specifying the
stride associated with each array dimension. When accessing values,
strides is used to calculate an element's location in memory.



a.index_bases()
const index*

This returns a list of NumDims elements specifying the
numeric index of the first element for each array dimension.



a.origin()

element* if a is mutable,
const element* otherwise.


This returns the address of the element accessed by the expression
a[0][0]...[0].. If the index bases are positive,
this element won't exist, but the address can still be used to locate
a valid element given its indices.



a.num_dimensions()
size_type
This returns the number of dimensions of the array
(note that a.num_dimensions() == NumDims).


a.num_elements()
size_type
This returns the number of elements contained
in the array. It is equivalent to the following code:

std::accumulate(a.shape(),a.shape+a.num_dimensions(),
    size_type(1),std::multiplies&lt;size_type&gt;());




a.size()
size_type

This returns the number of values contained in
a. It is equivalent to a.shape()[0];



a(index_list)

element&amp;;  if a is mutable,
const element&amp; otherwise.
            

This expression accesses a specific element of
a.index_list is the unique set
of indices that address the element returned.  It is 
equivalent to the following code (disregarding intermediate temporaries):

    // multiply indices by strides
    std::transform(index_list.begin(), index_list.end(),
      a.strides(), tmp.begin(), std::multiplies&lt;index&gt;()),

    // add the sum of the products to the origin
    *std::accumulate(tmp.begin(), tmp.end(), a.origin());




a.begin()

iterator if a is mutable,
const_iterator otherwise.
            
This returns an iterator pointing to the beginning of
a.


a.end()

iterator if a is mutable,
const_iterator otherwise.
            
This returns an iterator pointing to the end of
a.


a.rbegin()

reverse_iterator if a is mutable, 
const_reverse_iterator otherwise.
            
This returns a reverse iterator pointing to the
beginning of a reversed.



a.rend()

reverse_iterator if a is mutable, 
const_reverse_iterator otherwise.


This returns a reverse iterator pointing to the end of a
reversed.



a[idx]

reference if a is mutable,
const_reference otherwise.
            

This returns a reference type that is bound to the index
idx value of a.  Note that if
i is the index base for this dimension, the above
expression returns the (idx-i)th element (counting
from zero).  The expression is equivalent to
*(a.begin()+idx-a.index_bases()[0]);.



a[indices]

array_view&lt;Dims&gt;::type if
a is mutable,
const_array_view&lt;Dims&gt;::type otherwise.
            

This expression generates a view of the array determined by the
index_range and index values
 used to construct indices.



a == b
bool
This performs a lexicographical comparison of the
values of a and b.  The element
type must model EqualityComparable for this
expression to be valid.


a &lt; b
bool
This performs a lexicographical comparison of the
values of a and b.  The element
type must model LessThanComparable for this
expression to be valid.


a &lt;= b
bool
This performs a lexicographical comparison of the
values of a and b.  The element
type must model EqualityComparable and
LessThanComparable for this
expression to be valid.


a &gt; b
bool
This performs a lexicographical comparison of the
values of a and b.  The element
type must model EqualityComparable and 
LessThanComparable for this
expression to be valid.


a &gt;= b
bool
This performs a lexicographical comparison of the
values of a and b.  The element
type must model LessThanComparable for this
expression to be valid.








Complexity guarantees
begin() and end() execute in amortized
constant time.
size() executes in at most linear time in the 
MultiArray's size. 



Invariants

Table 25.4. Invariants







Valid range

[a.begin(),a.end()) is a valid range.
            


Range size

a.size() == std::distance(a.begin(),a.end());.



Completeness

Iteration through the range 
[a.begin(),a.end()) will traverse across every
value_type of a.



Accessor Equivalence

Calling a[a1][a2]...[aN] where N==NumDims
yields the same result as calling 
a(index_list), where index_list
is a Collection containing the values a1...aN.









Associated Types for Views

index_range
index_gen

The following MultiArray  associated 
types define the interface for creating views of existing
MultiArrays. Their interfaces and roles in the
concept are described below.


index_range

index_range objects represent half-open
strided intervals.  They are aggregated (using an
index_gen object) and passed to 
a MultiArray's operator[]
to create an array view. When creating a view, 
each index_range denotes a range of
valid indices along one dimension of a MultiArray.
Elements that are accessed through the set of ranges specified will be 
included in the constructed view. In some cases, an
index_range is created without specifying start
or finish values.  In those cases, the object is interpreted to
start at the beginning of a MultiArray dimension
and end at its end.

index_range objects can be constructed and modified 
several ways in order to allow convenient and clear expression of a
range of indices.  To specify ranges, index_range
supports a set of constructors, mutating member functions, and a novel 
specification involving inequality operators.  Using inequality
operators,  a half open range [5,10) can be specified as follows:

5 &lt;= index_range() &lt; 10;
 or

4 &lt; index_range() &lt;= 9;
 and so on.

The following describes the
index_range interface.


Table 25.5. Notation







i
An object of type index_range.


idx,idx1,idx2,idx3
Objects of type index.





Table 25.6. Associated Types






Type
Description



index
This is a signed integral type. It is used to
specify the start, finish, and stride values.


size_type
This is an unsigned integral type. It is used to
report the size of the range an index_range 
represents.





Table 25.7. Valid Expressions







Expression
Return type
Semantics



index_range(idx1,idx2,idx3)
index_range
This constructs an index_range
	    representing the interval [idx1,idx2)
 with stride idx3.


index_range(idx1,idx2)
index_range
This constructs an index_range
	    representing the interval [idx1,idx2)
 with unit stride. It is equivalent to
	    index_range(idx1,idx2,1).


index_range()
index_range
This construct an index_range
with unspecified start and finish values.


i.start(idx1)
index&amp;
This sets the start index of i to
	    idx.


i.finish(idx)
index&amp;
This sets the finish index of i to 
            idx.


i.stride(idx)
index&amp;
This sets the stride length of i to
            idx.


i.start()
index
This returns the start index of i.


i.finish()
index
This returns the finish index of i.


i.stride()
index
This returns the stride length of i.


i.get_start(idx)
index
If i specifies a start
value, this is equivalent to i.start(). Otherwise it
returns idx.


i.get_finish(idx)
index
If i specifies a finish
value, this is equivalent to i.finish(). Otherwise it
returns idx.


i.size(idx)
size_type
If i specifies a both finish and
start values, this is equivalent to
(i.finish()-i.start())/i.stride(). Otherwise it
returns idx.


i &lt; idx
index
This is another syntax for specifying the finish
value. This notation does not include 
idx in the range of valid indices. It is equivalent to 
index_range(r.start(), idx, r.stride())



i &lt;= idx
index
This is another syntax for specifying the finish
value. This notation includes 
idx in the range of valid indices. It is equivalent to 
index_range(r.start(), idx + 1, r.stride())



idx &lt; i
index
This is another syntax for specifying the start
value. This notation does not include 
idx in the range of valid indices. It is equivalent to 
index_range(idx + 1, i.finish(), i.stride()).


idx &lt;= i
index
This is another syntax for specifying the start
value. This notation includes
idx1 in the range of valid indices. It is equivalent to 
index_range(idx, i.finish(), i.stride()).


i + idx
index
This expression shifts the start and finish values
of i up by idx. It is equivalent to 
index_range(r.start()+idx1, r.finish()+idx, r.stride())



i - idx
index
This expression shifts the start and finish values
of i up by idx. It is equivalent to 
index_range(r.start()-idx1, r.finish()-idx, r.stride())









index_gen

 index_gen aggregates 
index_range objects in order to specify view
parameters.  Chained calls to operator[] store
range and dimension information used to 
instantiate a new view into a MultiArray.


Table 25.8. Notation







Dims,Ranges
Unsigned integral values.


x
An object of type 
template gen_type&lt;Dims,Ranges&gt;::type.


i
An object of type 
index_range.


idx
Objects of type index.





Table 25.9. Associated Types






Type
Description



index
This is a signed integral type. It is used to
specify degenerate dimensions.


size_type
This is an unsigned integral type. It is used to
report the size of the range an index_range 
represents.



template gen_type::&lt;Dims,Ranges&gt;::type

This type generator names the result of 
Dims chained calls to
index_gen::operator[].  The
Ranges parameter is determined by the number of
degenerate ranges specified (i.e. calls to
operator[](index)). Note that  
index_gen and
gen_type&lt;0,0&gt;::type are the same type.





Table 25.10. Valid Expressions







Expression
Return type
Semantics



index_gen()
gen_type&lt;0,0&gt;::type
This constructs an index_gen
object. This object can then be used to generate tuples of
index_range values.


x[i]

gen_type&lt;Dims+1,Ranges+1&gt;::type

Returns a new object containing all previous
index_range objects in addition to
i. Chained calls to
operator[] are the means by which
index_range objects are aggregated.


x[idx]

gen_type&lt;Dims,Ranges+1&gt;::type

Returns a new object containing all previous
index_range objects in addition to a degenerate
range, index_range(idx,idx). Note that this is NOT
equivalent to x[index_range(idx,idx)]., which will
return an object of type
gen_type&lt;Dims+1,Ranges+1&gt;::type.










Models

multi_array
multi_array_ref
const_multi_array_ref
template array_view&lt;Dims&gt;::type
template const_array_view&lt;Dims&gt;::type
template subarray&lt;Dims&gt;::type
template const_subarray&lt;Dims&gt;::type



Copyright © 2002 The Trustees of Indiana University






\3https://www.boost.org/doc/libs/1_84_0/doc/html/MultiArray.html
Macro BOOST_PROTO_EXTENDS_ASSIGN\3



Macro BOOST_PROTO_EXTENDS_ASSIGN











Home
Libraries
People
FAQ
More








Macro BOOST_PROTO_EXTENDS_ASSIGN
BOOST_PROTO_EXTENDS_ASSIGN — For adding to an expression extension class an overloaded assignment operator that
      builds an expression template.

Synopsis
// In header: &lt;boost/proto/extends.hpp&gt;

BOOST_PROTO_EXTENDS_ASSIGN()

Description

        Use BOOST_PROTO_EXTENDS_ASSIGN() after 
        BOOST_PROTO_BASIC_EXTENDS() to give an expression
        extension class an overloaded assignment operator that builds an expression template.
      

        See also:
        

BOOST_PROTO_BASIC_EXTENDS()
BOOST_PROTO_EXTENDS_SUBSCRIPT()
BOOST_PROTO_EXTENDS_FUNCTION()
BOOST_PROTO_EXTENDS()


      


Copyright © 2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PROTO_EXTENDS_ASSIGN.html
Macro BOOST_YAP_USER_ASSIGN_OPERATOR\3



Macro BOOST_YAP_USER_ASSIGN_OPERATOR











Home
Libraries
People
FAQ
More








Macro BOOST_YAP_USER_ASSIGN_OPERATOR
BOOST_YAP_USER_ASSIGN_OPERATOR

Synopsis
// In header: &lt;boost/yap/user_macros.hpp&gt;

BOOST_YAP_USER_ASSIGN_OPERATOR(this_type, expr_template)

Description
Defines operator overloads for operator=() that each produce an expression instantiated from the expr_template expression template. One overload is defined for each of the qualifiers const &amp;, &amp;, and &amp;&amp;. For the lvalue reference overloads, *this is captured by reference into the resulting expression. For the rvalue reference overload, *this is moved into the resulting expression.
The rhs parameter to each of the defined overloads may be any type, including an expression, except that the overloads are constrained by std::enable_if&lt;&gt; not to conflict with the assignment and move assignement operators. If rhs is a non-expression, it is wrapped in a terminal expression.
Example: 









Parameters:







expr_template
The expression template to use to instantiate the result expression. expr_template must be an ExpressionTemplate. 


this_type
The type of the class the operator is a member of; this is required to avoid clashing with the assignment and move assignement operators.







Copyright © 2018 T. Zachary Laine
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_YAP_U_1_3_46_8_2_7_3.html
Macro BOOST_DLL_ALIAS\3



Macro BOOST_DLL_ALIAS











Home
Libraries
People
FAQ
More








Macro BOOST_DLL_ALIAS
BOOST_DLL_ALIAS — Makes an alias name for exported function or variable. 

Synopsis
// In header: &lt;boost/dll/alias.hpp&gt;

BOOST_DLL_ALIAS(FunctionOrVar, AliasName)

Description
This macro is useful in cases of long mangled C++ names. For example some void boost::foo(std::string) function name will change to something like N5boostN3foosE after mangling. Importing function by N5boostN3foosE name does not looks user friendly, especially assuming the fact that different compilers have different mangling schemes. AliasName is the name that won't be mangled and can be used as a portable import name.
Can be used in any namespace, including global. FunctionOrVar must be fully qualified, so that address of it could be taken. Multiple different aliases for a single variable/function are allowed.
Make sure that AliasNames are unique per library/executable. Functions or variables in global namespace must not have names same as AliasNames.
Same AliasName in different translation units must point to the same FunctionOrVar.
Puts all the aliases into the "boostdll" read only section of the binary. Equal to  BOOST_DLL_ALIAS_SECTIONED(FunctionOrVar, AliasName, boostdll).

Example: 
namespace foo {
  void bar(std::string&amp;);

  BOOST_DLL_ALIAS(foo::bar, foo_bar)
}

BOOST_DLL_ALIAS(foo::bar, foo_bar_another_alias_name)

See:  BOOST_DLL_ALIAS_SECTIONED for making alias in a specific section. 






Parameters:







AliasName
Name of the alias. Must be a valid C identifier.


FunctionOrVar
Function or variable for which an alias must be made. 







Copyright © 2014 Renato Tegon Forti, Antony PolukhinCopyright © 2015 Antony PolukhinCopyright © 2016 Antony Polukhin, Klemens MorgensternCopyright © 2017-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_DLL_ALIAS.html
Macro BOOST_PFR_MAYBE_UNUSED\3



Macro BOOST_PFR_MAYBE_UNUSED











Home
Libraries
People
FAQ
More








Macro BOOST_PFR_MAYBE_UNUSED
BOOST_PFR_MAYBE_UNUSED

Synopsis
// In header: &lt;boost/pfr/config.hpp&gt;

BOOST_PFR_MAYBE_UNUSED

Copyright © 2016-2023 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      







\3https://www.boost.org/doc/libs/1_84_0/doc/html/BOOST_PFR_MAYBE_UNUSED.html
